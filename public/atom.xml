<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Zhixingheyi</title>
 <link href="http://liuxuan.info/atom.xml" rel="self"/>
 <link href="http://liuxuan.info/"/>
 <updated>2012-12-22T19:27:38+08:00</updated>
 <id>http://liuxuan.info/</id>
 <author>
   <name>Foredoomed</name>
   <email>mc.liuxuan@gmail.com</email>
 </author>

 
 <entry>
   <title>Hashing谜团</title>
   <link href="/blog/2012/10/21/hashing-myths/"/>
   <updated>2012-10-21T20:33:00+08:00</updated>
   <id>http://liuxuan.info/blog/2012/10/21/hashing-myths</id>
   <content type="html">&lt;p&gt;最近许多网站的用户名和秘密都被泄露，这也引发了一场对密码的存储问题的大讨论。其中的核心就是hashing，所以就让我们来看看关于hashing的几个常见的误解吧。这篇博文是一篇英文帖子的翻译，原文请戳&lt;a href=&quot;http://webdevrefinery.com/forums/topic/4850-hashing-myths/page_hl_hashing&quot; title=&quot;Hashing Myths&quot;&gt;Hashing Myths&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;hashing&quot;&gt;谜团#1：Hashing后的结果是独一无二的&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;大错特错&lt;/strong&gt;。让我们用简单的逻辑来解释。比如有一个32位长的hash，如果再对33位长的字符串hash的话，就有可能产生相同的hash(又叫“碰撞”)。道理很简单，33位长字符串的排列组合比32位长的字符串要多得多，因为可以在32位长字符串的尾部加上一个任意字符就是33位长的字符串。所以打个比方来说，如果有90000个33位长字符串和20000个32位长字符串，前者其中的某些字符串一定跟后者中的一些字符串的hash值相同。Hashing算法的目的是尽量减少碰撞，&lt;strong&gt;但是不可能完全消除碰撞&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;md5&quot;&gt;谜团#2：MD5是不安全的&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;大错特错&lt;/strong&gt;。MD5是比SHA-256来说没那么负责(因此速度更快)的算法，但是这个算法是安全的。一个不安全的hash代表这个hash可以被逆向破解，或者可以仅凭hash值就可以用一个字符串产生相同的hash，而在MD5下不行。事实上最接近的是修改一个存在的大文件，但是并不改变它已有的hash值。人类历史上还没有一个人能够逆向破解MD5。产生这个误解是因为MD5是一个常见的秘密破解攻击对象，这就又产生了下一个误解。&lt;/p&gt;

&lt;h2 id=&quot;md5hashsha&quot;&gt;谜团#3：MD5没有其他hash算法(像SHA)安全&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;大错特错&lt;/strong&gt;。如果你有秘密的hash值的话，那么确定就有三种攻击手段来找出密码原文。&lt;br /&gt;
1. 查hash数据库。你可以到在线的hash数据库里查有没有你的hash。对于这种攻击的常见防范手段就是对秘密hash时加&lt;a href=&quot;http://en.wikipedia.org/wiki/Salt_(cryptography)&quot; title=&quot;salt&quot;&gt;salt&lt;/a&gt;。&lt;br /&gt;
2. Brute force算法。对字典中的所有单词hash，比较是否符合。如果没用的话就对5，6，7，8位长所有可能的字符串hash。这种攻击需要消耗大量时间，而且经常得不到想要的结果，而且很容易的用salt来防范。&lt;br /&gt;
3. Rainbow tables。这是hashing和rehashing方法，它可以找到不同单词的hash值的相似之处，并最终找到秘密原文。salt在这种攻击下作用不大。  &lt;/p&gt;

&lt;h2 id=&quot;hashsha-256&quot;&gt;谜团#4：复杂超常的hash值(像SHA-256)不容易被攻击&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;大错特错&lt;/strong&gt;。Hash破解的最大威胁是Rainbow table，它是时间和空间的折衷，经常在1分钟之内就能破解密码。但是Rainbow table并不神奇，大多数人更容易去相信，而不是理解它的原理。如果你有15分钟的话可以看下&lt;a href=&quot;http://en.wikipedia.org/wiki/Rainbow_table&quot; title=&quot;rainbow table&quot;&gt;介绍&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果你已经知道Rainbow table的原理的话，你就会知道它最大的弱点就是hash碰撞。所以安全密码的hash是一个折折衷：你希望的是一个算法产生的碰撞越少越好，这样两个秘密就不会产生相同的hash；但你又希望这个算法能产生足够的碰撞，这样的话rainbow table就会陷入死循环，密码被破解的可能性也就降低了。就这两点说，SHA-256是可怕的。因为它几乎不产生碰撞，不管有没有salt，所以更容易被攻击。SHA-256适用与hash大文件而不是密码。&lt;/p&gt;

&lt;h2 id=&quot;sha-1md5md5&quot;&gt;谜团#5：SHA-1仍然比MD5更好，因为MD5更容易被破解&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;大错特错&lt;/strong&gt;。再一次你搞错了。SHA-1有160位，碰撞比MD5少，而且hash数据库和rainbow table对与SHA-1和MD5是一样的。这个误解在程序员中被广泛传播的原因是他们没有花时间去研究事实的真相。事实上，SHA产生的较长的hash对hash数据库和rainbow table的攻击几乎无用。与MD5相比，SHA-1只是多了一些存储空间，因为SHA-1有160位，而MD5才128位长。长度的增加可以减少碰撞的产生，相对大文件来说这对于密码的hash根本没用。&lt;/p&gt;

&lt;h2 id=&quot;hash&quot;&gt;谜团#6：用多个算法hash就更安全&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;大错特错&lt;/strong&gt;。我看到过这样的hash： sha1(md5(“Password”))，这样的计算方式是非常荒谬的。你在把128位转换成160位，这会非常容易被破解。你不能多次hash。你为了防止被破解会在hash时多加一个处理步骤，但是最终结果还是一样的。不要猜什么更安全，要去理解什么更安全。&lt;/p&gt;

&lt;h2 id=&quot;saltsaltsalt&quot;&gt;谜团#7：全局salt和用户salt的组合比单个用户salt更安全&lt;/h2&gt;

&lt;p&gt;最近在一篇文章里有人支持用全局salt加上用户salt的方法，但是我认为这是没用的。我的观点遭到了强烈的反对，他们说黑客窃取数据库而不是源代码更安全。我同意，但是这种方式提供的安全性可以忽略不计。下面就是原因：&lt;/p&gt;

&lt;p&gt;上面的三个hash攻击中，只有brute force法是用了全局salt比不用更难破解，但同时这个方法也是最难成功的方法。全局salt只是把几乎不可能变成非常不可能。我承认有点作用，但是黑客们的常用攻击手段是rainbow table而不是brute force，不然他们会发疯的。在rainbow table的攻击下，全局salt不比用户salt安全多少。如果有人可以窃取到你的数据库的拷贝，他们也可以轻易地窃取你源代码的拷贝。&lt;/p&gt;

&lt;p&gt;如果你在寻找保护你数据库被窃取的方法的话，一个非常非常非常有效的方法就是对称加密hash。选择一个速度快，简单的对称加密算法(RC4,Blowfish等)，创建ke并保存在配置文件中，用它加密数据库中所有加过salt的密码hash。当从数据库中读取他们时，只要用key解密出来就可以了。现在即使有人入侵了数据库或服务器，就连rainbow table的攻击也对你的hash无效，这对在公共软件仍然有效，而且比全局salt要有效的多的多。&lt;/p&gt;

&lt;h2 id=&quot;hashing-1&quot;&gt;那么密码hashing的最佳实践是什么呢?&lt;/h2&gt;

&lt;p&gt;对于密码来说只有两个hash算法是比较好的选择：MD5和SHA-1，而你应该让你的编程语言来决定选择哪个算法。对于PHP和大多数语言来说，MD5比SHA-1快，所以MD5是比较好的选择。保证密码安全的关键是用一个合适长度的salt。安全的保存密码，避免字典和brute force的攻击是相对rainbow table来说比较安全的折衷点是用生成一个2倍于原本hash长度的hash。比如MD5的话，可以hash两个MD5生成的hash。你可以为它生成一个128位的salt(对许多用户来说会占用非常多的存储空间)，或者你可以hash一个字符串来生成salt。我最喜欢的方法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$finalHash = md5(md5($salt), md5($password))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法的有点是：用两个MD5生成一个新的hash，它非常容易移植，因为任何一个语言(包括SQL)都支持上面的方法，3次MD5仍然是一个相对速度快的处理过程，而且如果是web的话，在密码发送到服务器之前，你可以用javascript来hash密码，而且仍然可以用它来生成最终的hash。&lt;/p&gt;

&lt;p&gt;是否在最终hash上做对称加密完全取决于你。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>字符串搜索算法</title>
   <link href="/blog/2012/10/20/string-searching-algorithms/"/>
   <updated>2012-10-20T22:30:00+08:00</updated>
   <id>http://liuxuan.info/blog/2012/10/20/string-searching-algorithms</id>
   <content type="html">&lt;h2 id=&quot;brute-force-search-bfs&quot;&gt;Brute-force search (BFS)&lt;/h2&gt;

&lt;p&gt;BFS应该是字符串搜索算法中最简单的一个，维基百科上的描述是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;a trivial but very general problem-solving technique that consists of systematically enumerating all possible candidates for the solution and checking whether each candidate satisfies the problem’s statement.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以BFS算法就是用模式串去和搜索串逐一比较，直到找到模式串为止。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1256.photobucket.com/albums/ii494/Foredoomed/bruteforcesearch_zps3f5d214f.png&quot; alt=&quot;BFS&quot; title=&quot;BFS&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;bfs&quot;&gt;BFS的特点：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;模式串不做预处理&lt;/li&gt;
  &lt;li&gt;从左边开始一个字符一个字符的匹配&lt;/li&gt;
  &lt;li&gt;最差情况下需要比较mn次&lt;/li&gt;
  &lt;li&gt;返回的是第一次匹配的字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BSF的优点和缺点都很明显：优点就是简单；缺点速度慢，不稳定。&lt;/p&gt;

&lt;h2 id=&quot;knuth-morris-pratt-kmp&quot;&gt;Knuth-Morris-Pratt (KMP)&lt;/h2&gt;

&lt;p&gt;维基百科上的描述是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;searches for occurrences of a “word” W within a main “text string” S by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;BFS算法最大的问题就是当匹配失败时，需要把模式串右移一位重新开始匹配。但是很有可能匹配失败，然后再右移一位匹配。这当中重复了很多不必要的匹配过程，这也是造成BFS算法效率差的原因(当搜索串不是很大时，BFS应该比其他算法更有优势)。&lt;/p&gt;

&lt;p&gt;KMP解决了不必要匹配过多的问题，大大提高了算法的效率。显然，匹配的核心问题就是当匹配失败出现时，模式串右移多少位再开始重新匹配。KMP算法是通过对模式串的预处理，建立一张前缀表来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i    0  1  2  3  4  5  6
W[i] A  B  C  D  A  B  D   
T[i] -1 0  0  0  0  1  2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立这张表的算法是：从左往右遍历模式串，观察前i-1长子串中，最长前缀子串和后缀子串匹配的长度。如上图所示，匹配串W[i]=ABCDABD的第一个字符是a，约定T[0]=-1；W[1]之前的字串是A，因为只有一个字符，它没有前缀子串和后缀子串，所以T[1]=0；同理T[2]=0，T[3]=0，T[4]=0；当W[5]=ABCDA时，有前缀和后缀字串A，所以T[5]=1；同理T[6]=2。&lt;/p&gt;

&lt;p&gt;我们来看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0	1	2	3	4	5	6	7	8	9
a	b	c	a	b	c	a	b	d		
a	b	c	a	b	d					
        a	b	c	a	b	d&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当i=5时匹配失败，又T[5]=2，所以模式串往右移i-T[5]=5-2=3位继续匹配。&lt;/p&gt;

&lt;h4 id=&quot;kmp&quot;&gt;KMP算法的特点：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;从左往右匹配&lt;/li&gt;
  &lt;li&gt;预处理模式串，时间负责度Θ(m)&lt;/li&gt;
  &lt;li&gt;搜索时间负责度Θ(m+n)`&lt;/li&gt;
  &lt;li&gt;最多比较2n-1`次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;KMP算法的优点有：简单，速度快，对处理大文件有优势；缺点是随着字符种类增加，匹配失败的几率也随之增加。&lt;/p&gt;

&lt;h2 id=&quot;boyer-moore-bm&quot;&gt;Boyer-Moore (BM)&lt;/h2&gt;

&lt;p&gt;维基百科上的描述是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;is an efficient string searching algorithm that is the standard benchmark for practical string search literature. It was developed by Robert S. Boyer and J Strother Moore in 1977. The algorithm preprocesses the string being searched for (the pattern), but not the string being searched in (the text). It is thus well-suited for applications in which the text does not persist across multiple searches. The Boyer-Moore algorithm uses information gathered during the preprocess step to skip sections of the text, resulting in a lower constant factor than many other string algorithms. In general, the algorithm runs faster as the pattern length increases.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说，BM算法是从模式串的右边开始往左边匹配搜索串，如果搜索串中的字符与模式串最右的字符不匹配，并且模式串里不包含这个字符的话，那么模式串可以右移m(模式串的长度)位。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0	1	2	3	4	5	6	7	8	9	
a	b	b	a	d	a	b	a	c	b	a
b	a	b	a	c						
                b	a	b	a	c&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;bad-character-&quot;&gt;0.Bad character 搜索法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;0	1	2	3	4	5	6	7	8	9  
a	b	b	a	b	a	b	a	c	b	a
b	a	b	a	c						
        b	a	b	a	c&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先匹配i=4位置上的b和c，显然不相等，然后我们发觉b在模式串中出现在了0和2的位置上，所以我们可以把搜索串i=4位置上的b和模式串i=2位置上的b对齐。&lt;/p&gt;

&lt;h3 id=&quot;good-suffix-&quot;&gt;1.Good suffix 搜索法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;0	1	2	3	4	5	6	7	8	9   
a	b	a	a	b	a	b	a	c	b	a  
c	a	b	a	b						
        c	a	b	a	b&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从右开始匹配到i=2时匹配失败，这时后缀ab匹配成功，我们可以把模式串中的下一个ab(如果有的话)与搜索串的ab对齐。但是如果碰到下面这种情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0	1	2	3	4	5	6	7	8	9  
a	a	b	a	b	a	b	a	c	b	a
a	b	b	a	b						
        a	b	b	a	b&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到后缀bab匹配成功，但是模式串中没有第二个bab，所以我们可以在模式串中寻找bab的字串，就像上面的ab，然后把它与搜索串对齐。&lt;/p&gt;

&lt;h4 id=&quot;bm&quot;&gt;BM算法的特点：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;从右往左匹配&lt;/li&gt;
  &lt;li&gt;预处理模式串，时间负责度Θ(m+σ)&lt;/li&gt;
  &lt;li&gt;搜索时间负责度Θ(m*n)`&lt;/li&gt;
  &lt;li&gt;最多比较3n次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BM算法是字符串搜索算法里效率最高的算法，但是缺点是比较复杂(需要考虑的情况很多)，对good suffix的预处理比较难理解和实现。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Brute-force_search&quot; title=&quot;Wikipedia，Brute-force searching algorithm&quot;&gt;Wikipedia-Brute-force searching algorithm&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm&quot; title=&quot;Wikipedia，Knuth–Morris–Pratt algorithm&quot;&gt;Wikipedia-Knuth–Morris–Pratt algorithm&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot; title=&quot;Wikipedia，Boyer–Moore string search algorithm&quot;&gt;Wikipedia-Boyer–Moore string search algorithm&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/&quot; title=&quot;algorithms&quot;&gt;algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Skip List原理简述</title>
   <link href="/blog/2012/08/26/skip-list-in-a-netshell/"/>
   <updated>2012-08-26T14:05:00+08:00</updated>
   <id>http://liuxuan.info/blog/2012/08/26/skip-list-in-a-netshell</id>
   <content type="html">&lt;p&gt;Skip List(以下简称SL)是由&lt;a href=&quot;http://en.wikipedia.org/wiki/William_Pugh&quot; title=&quot;William Pugh&quot;&gt;William Pugh&lt;/a&gt;在1989年提出的，从字面上解释的话差不多就是“跳跃链表”，它是普通有序链表的一种改进，目的是为了提高搜索，插入和删除的速度。我们知道，普通List的搜索，插入和删除的时间复杂度都是O(n)，而SL则可以提高到O(log n)，这就使得SL变成了一个非常有用的数据结构，像现在大热的NoSQL之一&lt;a href=&quot;http://redis.io/&quot; title=&quot;Redis&quot;&gt;Redis&lt;/a&gt;就是使用了SL。JDK6之后也加入了&lt;a href=&quot;http://g.oswego.edu/&quot; title=&quot;Doug Lea&quot;&gt;Doug Lea&lt;/a&gt;的SL实现&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentSkipListSet.html&quot; title=&quot;ConcurrentSkipListSet&quot;&gt;ConcurrentSkipListSet&lt;/a&gt;和&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentSkipListMap.html&quot; title=&quot;ConcurrentSkipListMap&quot;&gt;ConcurrentSkipListMap&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1256.photobucket.com/albums/ii494/Foredoomed/Skip_list.png&quot; alt=&quot;skip list&quot; title=&quot;skip list&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面这张图是维基上的SL结构示意图，我们可以清楚地看到与普通链表不同的是，SL是由多层链表组成，而且元素会重复出现在多个层次上，只不过越往上层元素出现的概率越低。通常情况下在&lt;code&gt;i&lt;/code&gt;层出现的元素也出现在i+1层的概率p取1/2或1/4，然后根据&lt;a href=&quot;http://en.wikipedia.org/wiki/Geometric_distribution&quot; title=&quot;Geometric distribution&quot;&gt;几何分布&lt;/a&gt;的公式逆运算来求出元素出现在第几层。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;搜索&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://i1256.photobucket.com/albums/ii494/Foredoomed/search42.gif&quot; alt=&quot;skip list&quot; title=&quot;skip list&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每次搜索都从最上层开始，知道遇到大于要搜索的元素才转入下一层搜索。首先从第3层(层数从0开始)开始搜索42，首先遇到的是9，再后面就到底了，而42&amp;gt;9，所以转入下一层往右搜索；下一层首先遇到的是19，而42&amp;gt;19，所以再转入下一层，如此反复最终找到了我们所需要的元素42。其实在这个搜索过程中已经能够看出这个搜索的过程有点像&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot; title=&quot;Binary Search&quot;&gt;二分查找&lt;/a&gt;，但不完全相同。但是可以控制元素出现的概率使SL和二分查找完全相同。而我们知道二分查找的时间复杂度为O(log n)，所以SL的搜索时间复杂度也为O(log n)。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;插入&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://i1256.photobucket.com/albums/ii494/Foredoomed/insert.gif&quot; alt=&quot;skip list&quot; title=&quot;skip list&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们需要通过计算来得出元素在哪个层次出现，一般来说几何分布是比较好的元素分布情况，因为这样的话有50%的元素只出现在第0层，25%的元素出现在第0层和第1层，12.5%的元素出现在第0，1，2层，以此类推，这样一来就跟二叉排序树差不多了。根据几何分布公式F(k) = 1 - (1 - p)^k，我们可以得到层数k = log (1 - F(k)) / log (1 - p)。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;删除&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://i1256.photobucket.com/albums/ii494/Foredoomed/delete.gif&quot; alt=&quot;skip list&quot; title=&quot;skip list&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在SL中删除一个元素需要把在所有层次上的该元素都删除。如上图所示，要删除元素9，则需要把所以层次上的9全部都删除。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;实现&lt;/h2&gt;

&lt;p&gt;网上有很多种的SL实现，但是我认为最简单直观的还是&lt;a href=&quot;http://igoro.com/archive/skip-lists-are-fascinating&quot;&gt;这里&lt;/a&gt;，虽然他用的是C#实现的，但改成Java不是一件难事。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot;&gt;Skip List on Wikipedia&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sable.mcgill.ca/~dbelan2/cs251/skip_lists.html&quot;&gt;DATA STRUCTURES AND ALGORITHMS Project #25: SKIP LISTS&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://igoro.com/archive/skip-lists-are-fascinating/&quot;&gt;Skip lists are fascinating&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>深入浅出Coroutine</title>
   <link href="/blog/2012/08/18/head-first-coroutine/"/>
   <updated>2012-08-18T22:55:00+08:00</updated>
   <id>http://liuxuan.info/blog/2012/08/18/head-first-coroutine</id>
   <content type="html">&lt;p&gt;说到coroutine(中文一般翻译成&lt;strong&gt;协程&lt;/strong&gt;)，对于Java程序员来说可能有点陌生，因为Java语言本身并不支持coroutine，但是早在1963年这个想法就被提出来了。到目前为止，已经有很多语言提供了对coroutine的支持，比如Ruby，Python，Go，Erlang等。所以，理解coroutine是很有必要的。Lua是原生支持coroutine的语言之一，下面关于coroutine的例子都将使用Lua。&lt;/p&gt;

&lt;p&gt;维基上给出的Coroutine定义是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Coroutines are computer program components that generalize subroutines to allow multiple entry points for suspending and resuming execution at certain locations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面这段中包含了另一个名词：subroutine，所以先来看一下subroutine的定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In computer science, a subroutine, also termed procedure, function, routine, method, or subprogram, is a part of source code within a larger computer program that performs a specific task and is relatively independent of the remaining code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说subroutine就是方法或代码片段，方法或代码片段就是subroutine。现在就能翻译coroutine的定义了：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Coroutine是允许多入口，即使方法或代码片段能够在某个地方挂起和继续执行的特性的程序组件。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这句话对于Java程序员来说是具有颠覆性作用的，因为对于Java和那些不支持coroutine的语言来说，方法只有一个入口，也就是从方法体的大括号开始到结束的大括号为止。比如有个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void foo(){
	System.out.print(&amp;quot;hello&amp;quot;);
	System.out.print(&amp;quot;world&amp;quot;);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每当foo方法被调用的时候，方法体中的语句都会被执行，即每次都会打印“helloworld”。然而coroutine允许方法执行到一半就挂起(通常是碰到yield关键字)，然后上下文状态会被保存下来，并且可以在之后恢复这个coroutine。考虑下面这段lua代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo()
	print(&amp;quot;hello&amp;quot;)
	coroutine.yield() -- 在这里挂起coroutine
	print(&amp;quot;world&amp;quot;) 
end

local co = coroutine.create(foo) -- co保存的是上下文变量
coroutine.resume(co)         -- 只打印出 hello
coroutine.resume(co)         -- 只打印出 world&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次执行coroutine.resume(co)的时候，会从头开始执行foo函数，当遇到yield关键字时就会挂起coroutine，等到第二次执行coroutine.resume(co)的时候，会从上次coroutine挂起的地方继续执行，直到再次遇到yield或着函数结束。&lt;/p&gt;

&lt;p&gt;coroutine在yield时还可以指定另一个coroutine，下面是维基上的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var q := new queue

coroutine produce
    loop
        while q is not full
            create some new items
            add the items to q
        yield to consume

coroutine consume
    loop
        while q is not empty
            remove some items from q
            use the items
        yield to produce&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到Lua的coroutine不支持上面的这种指定另外coroutine的特性，所以类似Lua的coroutine实现又被称为asymmetric coroutine(非对称协程)。&lt;/p&gt;

&lt;p&gt;其实也可以使用多线程来实现上面例子中的生产者-消费者问题，但线程相比于协程的实现又有哪些区别呢？一般来说有以下几点不同：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程需要有操作系统来调度，而coroutine则是由程序自己来调度&lt;/li&gt;
  &lt;li&gt;线程的上下文切换开销较大，coroutine则要小的多&lt;/li&gt;
  &lt;li&gt;线程会有竞争，coroutine则没有&lt;/li&gt;
  &lt;li&gt;多线程的实现在某一时刻会有多个线程在运行，而coroutine则是只有一个&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Coroutine&quot; title=&quot;Coroutine From Wikipedia&quot;&gt;Coroutine From Wikipedia&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.lua.org/manual/5.2/manual.html#2.6&quot; title=&quot;Lua Coroutines Documentation&quot;&gt;Lua Coroutines Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>用Munin监控VPS的运行情况</title>
   <link href="/blog/2012/06/17/install-munin-on-vps/"/>
   <updated>2012-06-17T13:42:00+08:00</updated>
   <id>http://liuxuan.info/blog/2012/06/17/install-munin-on-vps</id>
   <content type="html">&lt;p&gt;因为换了vps，所以还要重新安装监控软件。而Linux平台上的系统监控软件还是很多的，比如大名顶顶的&lt;a href=&quot;http://www.nagios.org/&quot;&gt;Nagios&lt;/a&gt;，&lt;a href=&quot;http://www.cacti.net/&quot;&gt;Cacti&lt;/a&gt;和&lt;a href=&quot;http://www.zabbix.com/&quot;&gt;Zabbix&lt;/a&gt;,还有&lt;a href=&quot;http://oss.oetiker.ch/mrtg/&quot;&gt;MRTG&lt;/a&gt;。Nagios是一个比较重量级的软件，而且还必须搭配许多插件才能满足需求，所以在小内存vps上不适用；Cacti是通过&lt;a href=&quot;http://en.wikipedia.org/wiki/Simple_Network_Management_Protocol&quot;&gt;SNMP&lt;/a&gt;协议来监控系统，这意味着还要为它在后台开启SNMP进程，这对于小内存vps也不可取，还有cacti需要数据库的支持，web前端还需要php，所以综上也放弃；Zabbix虽然不错，但它也需要有数据库的支持，所以也放弃；而MRTG只能够监控网络使用情况，不能够监控CPU，磁盘等设备，所以还是放弃。最后我选择的是&lt;a href=&quot;http://munin-monitoring.org/&quot;&gt;Munin&lt;/a&gt;,它的有点是不仅轻量，不需要数据库，可以直接生成静态页面，应该说Munin是小内存vps上的理想选择。&lt;/p&gt;

&lt;p&gt;如果想要安装Munin的最新版本就需要自己编译安装，软件库里的版本还是有点旧。但是自己编译安装会比较麻烦，因为要安装编译所需要的很多依赖库，所以我还是选择从软件库里直接安装。好了，下面就开始安装Munin，操作系统是CentOS 6 32位。&lt;/p&gt;

&lt;p&gt;首先安装EPEL软件库，如果已经装过就跳过此步&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-7.noarch.rpm&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装munin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install munin munin-node&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置开机启动和目录权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chkconfig munin-node on

chown -R munin:munin /var/www/html/munin/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来就是配置munin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /etc/munin

vim munin.conf

# 打开下面几行的注释
dbdir   /var/lib/munin
htmldir /var/www/html/munin
logdir  /var/log/munin
rundir  /var/run/munin

tmpldir /etc/munin/templates

# 修改munin页面上显示的munin
[liuxuan.info]
    address 127.0.0.1
    use_node_name yes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置munin-node&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 修改hostname
host_name   liuxuan.info

# 如果有多台机器需要监控的话还需要加上他们的IP地址
allow ^xxx\.xxx\.xxx\.xxx$&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置对nginx的监控&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /etc/munin/plugins/
ln -s /usr/share/munin/plugins/nginx_request nginx_request
ln -s /usr/share/munin/plugins/nginx_status nginx_status

# 修改nginx_request里的hostname，搜索$URL,把其中的$fqdn改为localhost
# 然后输入下面的命令，如果输出yes则说明配置成功
perl nginx_request autoconf

# 配置nginx
cd /etc/nginx/conf.d
vim munin.conf
# 然后加入下面的配置
server {
        listen 127.0.0.1;
        server_name localhost;
        location /nginx_status {
                stub_status on;
                access_log   off;
                allow 127.0.0.1;
                deny all;
        }
        
	    location /munin {
        	root /var/www/html/munin;
  			expires off;
  			access_log   off;
  			auth_basic &amp;quot;Munin&amp;quot;;
  			auth_basic_user_file /etc/nginx/.htpasswd;
		 }
}

# 重启nginx使配置生效
nginx -s reload

# 设置访问munin的用户名和秘密
htpasswd -c /etc/nginx/.htpasswd username&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后设置计划任务每5分钟获取数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo -u munin crontab -e
*/5 * * * *  /usr/bin/munin-cron
# 一定要先执行下面这行命令，否则不会生成index.html，访问会报403错误
sudo -u munin munin-cron&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到现在为止配置基本完成了，启动munin试下吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/init.d/munin-node restart&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开浏览器访问http://your.domain/munin/，输入用户名和密码后就应可以看到munin的首页了，一开始是没有数据的，耐心等待几分钟后数据就会更新了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;参考文章&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.darkcoding.net/software/setting-up-munin-on-ubuntu/&quot;&gt;Setting up Munin on Ubuntu&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://munin-monitoring.org/wiki/Documentation&quot;&gt;Munin Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Linux常用命令</title>
   <link href="/blog/2012/06/16/linux-frequently-used-commands/"/>
   <updated>2012-06-16T14:16:00+08:00</updated>
   <id>http://liuxuan.info/blog/2012/06/16/linux-frequently-used-commands</id>
   <content type="html">&lt;p&gt;不定期更新一些在Linux下经常会用到的命令，其中一些也是在别的地方看到就加入到这个集合来了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;系统&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;uname -a               # 查看内核/操作系统/CPU信息  
head -n 1 /etc/issue   # 查看操作系统版本  
cat /proc/cpuinfo      # 查看CPU信息  
hostname               # 查看计算机名  
lspci -tv              # 列出所有PCI设备  
lsusb -tv              # 列出所有USB设备  
lsmod                  # 列出加载的内核模块  
env                    # 查看环境变量&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;资源&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;free -m                       # 查看内存使用量和交换区使用量  
df -h                         # 查看各分区使用情况  
du -sh &amp;lt;folder&amp;gt;               # 查看指定目录的大小  
grep MemTotal /proc/meminfo   # 查看内存总量  
grep MemFree /proc/meminfo    # 查看空闲内存量  
uptime                        # 查看系统运行时间、用户数、负载  
cat /proc/loadavg             # 查看系统负载&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;磁盘和分区&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mount | column -t      # 查看挂接的分区状态  
fdisk -l               # 查看所有分区  
swapon -s              # 查看所有交换分区  
hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备)  
dmesg | grep IDE       # 查看启动时IDE设备检测状况&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;网络&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ifconfig               # 查看所有网络接口的属性  
iptables -L            # 查看防火墙设置  
route -n               # 查看路由表  
netstat -lntp          # 查看所有监听端口  
netstat -antp          # 查看所有已经建立的连接  
netstat -s             # 查看网络统计信息  
进程
ps -ef                 # 查看所有进程  
top                    # 实时显示进程状态&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;用户&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;w                         # 查看活动用户  
id &amp;lt;username&amp;gt;             # 查看指定用户信息  
last                      # 查看用户登录日志  
cut -d: -f1 /etc/passwd   # 查看系统所有用户  
cut -d: -f1 /etc/group    # 查看系统所有组  
crontab -l                # 查看当前用户的计划任务&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;服务&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;chkconfig --list              # 列出所有系统服务  
chkconfig --list | grep on    # 列出所有启动的系统服务&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-6&quot;&gt;程序&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;rpm -Uvh http://xxx.rpm   # 添加软件库&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>快速搭建Octopress博客环境</title>
   <link href="/blog/2012/06/14/setup-octopress-on-vps/"/>
   <updated>2012-06-14T23:04:00+08:00</updated>
   <id>http://liuxuan.info/blog/2012/06/14/setup-octopress-on-vps</id>
   <content type="html">&lt;p&gt;这次为一个新买的VPS安装博客环境，特此记录如下。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;删除和替换已有软件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;servive sendmail stop
yum remove sendmail

service httpd stop
yum remove httpd

service rsyslog stop
yum remove rsyslog

# 添加EPEL软件库
rpm -Uvh http:#dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-7.noarch.rpm

# 安装syslog-ng代替rsyslog
yum install syslog-ng
chkconfig syslog-ng on

# 安装dropbear代替openssh
yum install dropbear
chkconfig dropbear on

# 等dropbear配置好后
service sshd stop
yum remove openssh

# 安装vsftpd作为ftp服务器
yum install vsftpd
chkconfig vsftpd on

# 添加用户
groupadd www
useradd -g www username
passwd username

# 设定ftp登陆目录权限
chown -R usernmae /path/to/ftp/folder

# 安装yum-utils
yum install yum-utils

# 更新软件
yum upgrade

# 安装ppp
rpm -ivh http:#poptop.sourceforge.net/yum/stable/rhel6/i386/ppp-2.4.5-17.0.rhel6.i686.rpm

# 安装pptpd
rpm -ivh http:#poptop.sourceforge.net/yum/stable/rhel6/i386/pptpd-1.3.4-2.el6.i686.rpm&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;octopress&quot;&gt;安装Octopress所需软件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 安装git
yum install git

# 安装RVM
curl -L get.rvm.io | bash -s stable

# 安装ruby的依赖包
yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel libyaml-devel libffi-devel openssl-devel make bzip2 autoconf automake libtool bison

# 添加nginx软件库
rpm -Uvh http:#nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm

# 安装nginx
yum install nginx

# 安装ruby
rvm install 1.9.2

# 安装Octopress的依赖包
yum install python-devel

# 安装Octopress
mkdir /data
cd /data
git clone git:#github.com/imathis/octopress.git octopress

gem install bundler
rbenv rehash #If you use rbenv, rehash to be able to run the bundle command
bundle install
rake install

cd octopress
rake generate&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vps&quot;&gt;VPS设置&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 配置vim
vim /etc/vimrc

# 加入下面几行
syntax on
set nu
set mouse=a
set tabstop=4

# 禁用IPv6
vim /etc/sysconfig/network
NETWORKING_IPV6=&amp;quot;no&amp;quot;

# 设置文件最大打开数
vim /etc/security/limits.conf
# 加入下面两行
* soft nofile 65535
* hard nofile 65535

# 把服务器时间改为上海时间
cp -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime

# 关闭不需要的服务
ntsysv  #按空格选择和取消，按F12退出&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;其他设置&lt;/h2&gt;

&lt;p&gt;因为众所周知的原因在天朝twitter是无法访问的，所以最好去掉内置的twitter插件，这样就不会去请求twitter的js文件。方法是修改source/_includes文件夹下_twitter_sharing.html的文件名。&lt;/p&gt;

&lt;p&gt;关于dropbear/vsftp/pptp的配置可以参考&lt;a href=&quot;http://liuxuan.info/blog/2011/08/21/install-dropbear-vsftp-pptpd-on-vps/&quot;&gt;这里&lt;/a&gt;，nginx的配置则可以参考&lt;a href=&quot;http://liuxuan.info/blog/2011/11/08/switching-from-wordpress-to-octopress/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>2011年终总结加2012年计划</title>
   <link href="/blog/2011/12/30/plans-for-2012/"/>
   <updated>2011-12-30T10:31:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/30/plans-for-2012</id>
   <content type="html">&lt;p&gt;时间那是一个飞逝，光阴那是一个荏苒。一转眼，我写博客已经有一年的时间了。期间我的博客也有很大的变化，从最初的独立空间到现在的VPS，从Wordpress变到了Octopress，应该说折腾的不算少，但也乐在其中。&lt;/p&gt;

&lt;p&gt;现在回头看我在年初写的这篇&lt;a href=&quot;http://liuxuan.info/blog/2011/01/01/plans-for-2011/&quot; title=&quot;2011年计划&quot;&gt;2011年计划&lt;/a&gt;，其中的计划基本上都完成了。不过也有点遗憾的是，因为工作比较忙，韩语的学习被耽搁了，希望今年能够加强韩语的学习。还有为了找寻我理想中的工作，今年我换了两份工作，但是情况都不是很理想，跟我理想的还是有不小的差距，希望明年在这方面也有改善。&lt;/p&gt;

&lt;p&gt;2011年中国发生了很多事，很多事，但是2012年注定是更加不平静的一年。对于我来说只有静下心来，多读一点书，是自己更加充实，这是当下最好的应对方式了吧。&lt;/p&gt;

&lt;p&gt;我给自己制定的2012年计划如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;继续多读书，目标50本&lt;/li&gt;
  &lt;li&gt;加强韩语的学习&lt;/li&gt;
  &lt;li&gt;写一个MVC和ORM框架&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就这样吧，一切贵在坚持！&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>编程经验</title>
   <link href="/blog/2011/12/25/programming-experience/"/>
   <updated>2011-12-25T15:09:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/25/programming-experience</id>
   <content type="html">&lt;p&gt;今天在整理移动硬盘时发现的一篇收藏的旧文，再次读完后发现写的太好了，基本上涵盖了程序员会碰到的问题，不过可惜的是原文已经找不到了。我觉得把这篇文章作为编程指导更合适，所以记录在这里。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;估算解决问题所需要的时间&lt;/h2&gt;

&lt;p&gt;不要怕，承认吧！我曾见过一些程序员为了解决一个特殊问题而坐在显示器前面8小时。为自己定一个时间限制吧，1小时、30分钟或甚至15分钟。如果在这期间你不能解决问题，那就去寻求帮助，或到网上找答案，而不是尝试去做“超级堆码员”。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;编程语言是一种语言，只是一种语言&lt;/h2&gt;

&lt;p&gt;随着时光推移，只要你理解了一种语言的原理，你会发现各种语言之间的相似之处 。你所选择的语言，你应该觉得“舒服”，并且能够写出有效（而且简洁）的代码。最重要的，让语言去适应项目，反之亦然。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;不要过于注重程序的“设计模式”&lt;/h2&gt;

&lt;p&gt;有时候，写一个简单的算法，要比引入某种模式更容易。在多数情况下，程序代码应是简单易懂，甚至清洁工也能看懂。 &lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;经常备份代码&lt;/h2&gt;

&lt;p&gt;在我年轻时，我就有过因硬盘故障而丢了大量代码的经历，这经历很恐怖的。只要你一次没有备份，就应当像有着严格的期限，客户明天就需要。此时就该版本控制软件大显身手了。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;承认自己并不是最顶尖的程序员-知不足&lt;/h2&gt;

&lt;p&gt;我常想，我对编程了解已足够多，但是总有其他人比你优秀。正所谓，“一山总比一山高”。所以，向他们看齐吧！&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;学习再学习&lt;/h2&gt;

&lt;p&gt;正如第5点所说，我经常会在手里拿一本计算机或编程相关的杂志或书（不信，可以问我的朋友）。诚然，总有很多你不知道的技术，你可以从中学习以保持不落后。如果你有一种灵巧的方式来获取你需要的新技术，那你每天都应该坚持学习。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;永恒的变化&lt;/h2&gt;

&lt;p&gt;你对待技术和编程知识，就应像你对待股票一样：多样化。不要在某一特定技 术上自我感觉良好。如果那种技术或语言已经没有足够支持，那你还不如现在就开始更新你的简历，并启动培训新计划。我能保持前行的主要原则是什么呢？至少了 解两到三种语言，所以，如果某种语言过时了，你在学习新技术的时候还可以依靠另一种语言。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;提携新人&lt;/h2&gt;

&lt;p&gt;协助并且培养初级/入门的开发人员学习优秀的编程方法和技巧。也许你还不知道，在帮助他们向更高一层前进时，你自己也在向更高一层提升，你会更加自信。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;简化算法&lt;/h2&gt;

&lt;p&gt;代码如恶魔，在你完成编码后，应回头并且优化它。从长远来看，这里或那里一些的改进，会让后来的支持人员更加轻松。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;编写文档&lt;/h2&gt;

&lt;p&gt;无论是Web服务的API，还是一个简单的类，你尽量编写相应文档。我曾经引以为豪的代码注释，因过度注释而有人指责。给三行代码加一行注释，只需要你几秒时间。如果那是一个比较难以理解的技术，千万别担心过多注释。如果你能很好做好自己的工作，大多数架 构师、后备程序员、支持组都会感激你。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;测试、测试再测试&lt;/h2&gt;

&lt;p&gt;我是一名黑盒测试粉丝。当你完成编码后，你“被认可”的时候就开始了。如果你们公司有QA部门，如果你的代码中有错误，那你得到的评论，会比项目经理还多。如果你不彻底测试自己的代码，那恐怕你开发的就不只是代码，可能还会声名狼藉。&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;庆祝每一次成功&lt;/h2&gt;

&lt;p&gt;我见过很多程序员在解决编程技术难题后，会和同伴握手、击掌或甚至手舞足蹈。每个人在生命中都会碰到“顿悟”。如果一个程序员高兴地跑来叫你去看他的非凡代码，也许你已经看过这样的代码100遍了，但你也应该为了这个家伙而庆祝第101次。（编者注：《庆祝成功的九种方式》。）&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;经常检查代码&lt;/h2&gt;

&lt;p&gt;在公司，你的代码要经常检查（包括自查和其他同事检查）。不要把别人的检查，看成是对代码风格的苛求。应该把它们看作是有建设性的批评。对个人来说，经常检查你的代码并且自问，“我怎样才能写得更好呢？” 这会让你加速你的成长，让你成为一个更优秀的程序员。&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;回顾你的代码&lt;/h2&gt;

&lt;p&gt;在看到自己以前的代码时，通常会有两种方式：“难以至信，这代码是我写的”和“难以至信，这代码是我写的”。第一种往往是厌恶的语气，并在想如何改进它。你也许会惊叹，旧代码也能复活成为一种更好的程序，甚至是一个完整的产品。第二种通常带着惊奇和成 就感。开发人员应该一到两个自己完成的项目成果，能让众人不禁而立并注目而观的项目。同样，基于你优越的编程能力，你可以把过去的程序或项目拿出来，把它们更新为更加优秀的产品或想法。&lt;/p&gt;

&lt;h2 id=&quot;section-14&quot;&gt;幽默是不可缺的&lt;/h2&gt;

&lt;p&gt;在我20年的开发生涯中，我还没有碰到哪位程序员是没有幽默感的。实际上，干我们这行，幽默是一项必备品。&lt;/p&gt;

&lt;h2 id=&quot;section-15&quot;&gt;谨防那些无所不知的程序员，不愿分享的程序员，还有经验不足的程序员&lt;/h2&gt;

&lt;p&gt;当你遇到这几种程序员时，你自己要谦虚。无所不知的程序员，更想当一个英雄而不是团队成员；保守的程序员则是在编写着他们独享的代码；而经验不足的程序员则会每十分钟就来问你一下，当代码完成后，代码已经是你的，而不是他们。&lt;/p&gt;

&lt;h2 id=&quot;section-16&quot;&gt;任何项目都不会那么简单&lt;/h2&gt;

&lt;p&gt;朋友、家人和同事曾请求我仓促做一些事情，仓促做一个程序或者网站。对于这样的事，应该 从双方做计划，才能做出令两方都会满意的东西。如果某人起初只是需要一个使用Microsoft Access的、只有有3个页面的网站，但来就很可能变成一个有15个页面的网站，并使用SQL Server，有一个论坛，还有一个定制的CMS（内容管理系统）。&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;任何时候不要想当然&lt;/h2&gt;

&lt;p&gt;假如你承接一个简单的项目，你可能会认为某个部分可以轻松完成。千万别这样想！除非你有一个类、组件、或者一段已经写好的代码，并且在现有的项目已经测试通过。不要认为这将是很容易的。&lt;/p&gt;

&lt;h2 id=&quot;section-18&quot;&gt;没有已经完成的软件&lt;/h2&gt;

&lt;p&gt;曾经有一位程序员告诉我，没有软件是已经完成的，它只是“暂时完成了”。这是明智的忠告。如果客户还在使用你写的程序，并经受了时间的考验。如果有机会，你仍在更新它，这并不是什么坏事，这让你不断地前行。&lt;/p&gt;

&lt;h2 id=&quot;section-19&quot;&gt;耐心是一种美德&lt;/h2&gt;

&lt;p&gt;当客户、朋友或家庭成员用电脑的时候，他们也许会受挫，进而想砸电脑，或气冲冲地离开。我一直在告诉他们，“是你掌控电脑，不是电脑掌控你。”对于用作编程的电脑，你要有一定的耐心。一旦程序员知道问题所在后，他们就会站在电脑的角度看问题，并且说 “哦，这就是为什么它是这样做。”&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>快速排序复习笔记</title>
   <link href="/blog/2011/12/17/quicksort-note/"/>
   <updated>2011-12-17T14:27:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/17/quicksort-note</id>
   <content type="html">&lt;p&gt;最近晚上躺在床上没事就拿着手机看了几节MIT的公开课《Introduction to Algorithms》，看着看着就觉得自己关于排序算法的原理基本上都忘光了。顿感非常失落，所以特意又对算法复习了一遍，特别是快速排序，这篇博客就是复习笔记，毕竟发表是最好的记忆嘛。&lt;/p&gt;

&lt;p&gt;这门课是由两位老师来上的的，一位是&lt;a href=&quot;http://people.csail.mit.edu/cel/&quot; title=&quot;Charles E.Leiserson&quot;&gt;Charles E.Leiserson&lt;/a&gt;教授，光听这个名字可能有点陌生，但是如果提到他参与编写的《算法导论》这本书，对于学计算机的人来说那是无人不知无人不晓的经典著作；另一位是80后的Erik Demaine&lt;a href=&quot;http://www.csail.mit.edu/user/666&quot; title=&quot;Erik Demaine&quot;&gt;Erik Demaine&lt;/a&gt;，据说此人在20岁时就当上了MIT的教授，真是牛人啊，而且大多数的课也都是由他来讲的。还有一点我比较在意的是一节课的时间大约是1个小时20分钟左右，这跟中国大学的45分钟一节课很不一样，个人觉得这样的时间安排可以使一节课更加连贯，学习效率也会更好。&lt;/p&gt;

&lt;p&gt;好了，回到正题快速排序上。话说快速排序是被广泛实际应用的排序算法，究其原因就是优秀的时间复杂度，平均为O(n*log(n))和O(n)的空间负责度，但是快速排序不是稳定排序，因为不能保证相同的元素在排序后还是原来的顺序。&lt;/p&gt;

&lt;p&gt;快速排序有三个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从元素列表中选择一个元素，这个元素被称为pivot。&lt;/li&gt;
  &lt;li&gt;把所有小于pivot的元素都放到pivot的左边，所有大于pivot的元素都放到pivot的右边，这个过程称为partition。&lt;/li&gt;
  &lt;li&gt;在左右两个子列表中迭代步骤2。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面举个例子来说明快速排序的排序过程，假如我们有这样一组数：&lt;code&gt;6 10 13 5 8 3 2 11&lt;/code&gt;，并且选取左端点元素&lt;code&gt;6&lt;/code&gt;作为初始pivot，那么上面步骤2的过程应该是下面这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;6  5  13  10  8   3   2  11  
6  5   3  10  8  13   2  11  
6  5   3   2  8  13  10  11  
2  5   3   6  8  13  10  11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为要把小于pivot的数都放到pivot的左边，而大于等于pivot的数都放到pivot的右边，所以在保证空间复杂度O(n)的前提下，采用一个变量&lt;code&gt;j&lt;/code&gt;，初始为pivot的后一个位置，当循环这个数组发现有小于pivot的数时就和&lt;code&gt;j&lt;/code&gt;这个位置上的数交换，然后&lt;code&gt;j + 1&lt;/code&gt;，等到循环结束后再交换pivot和&lt;code&gt;j&lt;/code&gt;位置上的数。当然如果空间够多的话，直接创建两个新数组往里塞更容易一点。到了上面最后一步后，pivot就变成了&lt;code&gt;6&lt;/code&gt;，然后再在它的左右子数组中迭代步骤2。&lt;/p&gt;

&lt;p&gt;好了，现在我们可以来写代码了，根据上面的思想不难得出下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void quickSort1(int[] array, int p, int q) {

  if (p &amp;gt; q) {
    return;
  }

  // 选取左端点为pivot
  int pivot = array[p];
  int j = p;

  for (int i = j + 1; i &amp;lt;= q; i++) {
    if (array[i] &amp;lt; pivot) {
      // 如果小于pivot则与j+1位置上数交换
      swap(array, ++j, i);

    }
}

  // 交换pivot与j位置上的数
  swap(array, p, j);

  // 迭代左右子数组
  quickSort1(array, p, j - 1);
  quickSort1(array, j + 1, q);
}

public static void swap(int[] array, int i, int j) {
  int temp = array[i];
  array[i] = array[j];
  array[j] = temp;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这个算法有个缺陷，在已经排序好的数组上性能非常差。所以人们就对原始快速排序算法进行了改进，改进的地方就是pivot的选取，用随机数或者中间位置的数取代最左端的数；还有就是初始化两个指针，分别从数组的两端向pivot扫描，小于pivot的数和大于等于pivot的数直接交换等，具体可以参看这篇文章：&lt;a href=&quot;http://www.blogjava.net/killme2008/archive/2010/09/08/quicksort_optimized.html&quot; title=&quot;快速排序及优化&quot;&gt;快速排序及优化&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我们来看一下经过上述两个方法优化过的快速排序算法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void quickSort2(int[] array, int p, int q) {

  int i = p, j = q;
		
  // 选中间数为pivot
  int pivot = array[i + (q - p) / 2];

  while (i &amp;lt;= j) {
			
    while (array[i] &amp;lt; pivot) {
      i++;
    }
			
    while (array[j] &amp;gt; pivot) {
      j--;
    }

    // 交换小于pivot的数和大于pivot的数
    if (i &amp;lt;= j) {
      swap(array, i, j);
      i++;
      j--;
	 }
  }
		
  // 迭代
  if (p &amp;lt; j)
    quickSort2(array, p, j);
  if (i &amp;lt; q)
    quickSort2(array, i, q);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是这样，快速排序其实蛮简单的，它和冒泡排序的区别就是：在冒泡排序中，数组中的数需要和其他多个数比较，越前面的数比较的次数越多；而快速排序在一次排序中比较的是一个固定的pivot，所以效率要比冒泡排序高很多。&lt;/p&gt;

&lt;p&gt;下面是排序算法的比较：&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;th /&gt;
        &lt;th colspan=&quot;3&quot;&gt;Time&lt;/th&gt;
        &lt;th colspan=&quot;4&quot; /&gt;
    &lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Sort&lt;/td&gt;
        &lt;td&gt;Average&lt;/td&gt;
        &lt;td&gt;Best&lt;/td&gt;
        &lt;td&gt;Worst&lt;/td&gt;
        &lt;td&gt;Space&lt;/td&gt;
        &lt;td&gt;Stability&lt;/td&gt;
        &lt;td&gt;Remarks&lt;/td&gt;
    &lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cprogramming.com/tutorial/computersciencetheory/sorting1.html&quot;&gt;Bubble
                sort&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;Constant&lt;/td&gt;
        &lt;td&gt;Stable&lt;/td&gt;
        &lt;td&gt;Always use a modified bubble sort&lt;/td&gt;
    &lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cprogramming.com/tutorial/computersciencetheory/sorting1.html&quot;&gt;Modified
                Bubble sort&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;O(n)&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;Constant&lt;/td&gt;
        &lt;td&gt;Stable&lt;/td&gt;
        &lt;td&gt;Stops after reaching a sorted array&lt;/td&gt;
    &lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cprogramming.com/tutorial/computersciencetheory/sorting2.html&quot;&gt;Selection
                Sort&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;Constant&lt;/td&gt;
        &lt;td&gt;Stable&lt;/td&gt;
        &lt;td&gt;Even a perfectly sorted input requires scanning the entire array&lt;/td&gt;
    &lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cprogramming.com/tutorial/computersciencetheory/sorting2.html&quot;&gt;Insertion
                Sort&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;O(n)&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;Constant&lt;/td&gt;
        &lt;td&gt;Stable&lt;/td&gt;
        &lt;td&gt;In the best case (already sorted), every insert requires constant time&lt;/td&gt;
    &lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cprogramming.com/tutorial/computersciencetheory/heapsort.html&quot;&gt;Heap
                Sort&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;O(n*log(n))&lt;/td&gt;
        &lt;td&gt;O(n*log(n))&lt;/td&gt;
        &lt;td&gt;O(n*log(n))&lt;/td&gt;
        &lt;td&gt;Constant&lt;/td&gt;
        &lt;td&gt;Instable&lt;/td&gt;
        &lt;td&gt;By using input array as storage for the heap, it is possible to
            achieve constant space&lt;/td&gt;
    &lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cprogramming.com/tutorial/computersciencetheory/mergesort.html&quot;&gt;Merge
                Sort&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;O(n*log(n))&lt;/td&gt;
        &lt;td&gt;O(n*log(n))&lt;/td&gt;
        &lt;td&gt;O(n*log(n))&lt;/td&gt;
        &lt;td&gt;Depends&lt;/td&gt;
        &lt;td&gt;Stable&lt;/td&gt;
        &lt;td&gt;On arrays, merge sort requires O(n) space; on linked lists, merge
       sort requires constant space&lt;/td&gt;
    &lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cprogramming.com/tutorial/computersciencetheory/quicksort.html&quot;&gt;Quicksort&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;O(n*log(n))&lt;/td&gt;
        &lt;td&gt;O(n*log(n))&lt;/td&gt;
        &lt;td&gt;O(n^2)&lt;/td&gt;
        &lt;td&gt;Constant&lt;/td&gt;
        &lt;td&gt;Stable&lt;/td&gt;
        &lt;td&gt;Randomly picking a pivot value (or shuffling the array prior to
            sorting) can help avoid worst case scenarios such as a perfectly
            sorted array.&lt;/td&gt;
    &lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h2 id=&quot;section&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.blogjava.net/killme2008/archive/2010/09/08/quicksort_optimized.html&quot; title=&quot;快速排序及优化&quot;&gt;快速排序及优化&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.vogella.de/articles/JavaAlgorithmsQuicksort/article.html&quot; title=&quot;Quicksort in Java&quot;&gt;Quicksort in Java&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cprogramming.com/tutorial/computersciencetheory/sortcomp.html&quot; title=&quot;Sorting Algorithm Comparison&quot;&gt;Sorting Algorithm Comparison&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>浏览器是如何工作的(十)</title>
   <link href="/blog/2011/12/16/how-browsers-work-ten/"/>
   <updated>2011-12-16T00:26:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/16/how-browsers-work-ten</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;6 绘制&lt;/h2&gt;

&lt;p&gt;在绘制阶段会遍历渲染树和调用renderer的paint方法来把他们的内容显示在屏幕上。绘制使用的是UI基础组件。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;6.1 全局和增量&lt;/h3&gt;

&lt;p&gt;像布局一样，可以全局绘(绘制整个渲染树)，也可以是增量绘制。在增量绘制中，一部分renderer的变化不会影响这棵渲染树。变化过的renderer会使它在屏幕上的矩形区域无效，这就会造成OS把它当作“脏区域”(dirty region)并且生成paint事件。OS会聪明地把多个脏区域合并成一个。在Chrome中则更复杂一点，因为renderer不是在主进程中，而是在其他进程中。Chrome模拟OS行为并且扩展它们，表现层监听这些事件而且把消息代理给渲染树的根元素。遍历渲染树直到遇见相关的renderer，渲染树重新绘制自己(经常连同它的孩子节点)。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;6.2 绘制顺序&lt;/h3&gt;

&lt;p&gt;CSS2的规范中规定了绘制的顺序。这个顺序实际上就是元素在上下文中堆积的顺序。因为是从后往前绘制的，所以这个顺序会影响绘制。renderer的堆积顺序是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;background color&lt;/li&gt;
  &lt;li&gt;background image&lt;/li&gt;
  &lt;li&gt;border&lt;/li&gt;
  &lt;li&gt;children&lt;/li&gt;
  &lt;li&gt;outline&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;firefox&quot;&gt;6.3 Firefox的显示列表&lt;/h3&gt;

&lt;p&gt;Firefox会再次遍历渲染树，然后构造一个已经绘制的矩形区域的显示列表。其中包含矩形区域相关的renderer，从右往左的绘制顺序(背景，边框等)。这种方式只需要遍历一次渲染树就可以重新绘制(所有背景，再所有图片，再所有边框等)。&lt;/p&gt;

&lt;p&gt;Firefox通过不把hidden的元素加入到列表中来优化这个过程。&lt;/p&gt;

&lt;h3 id=&quot;webkit&quot;&gt;6.4 Webkit的矩形存储&lt;/h3&gt;

&lt;p&gt;在重新绘制之前，webkit把旧的矩形保存为一个bitmap，然后只重新绘制新旧矩形的不同之处。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;7 动态变化&lt;/h2&gt;

&lt;p&gt;对应一个修改，浏览器会做尽可能少的动作，所以改变元素的颜色只会重新绘制这个元素。元素位置的改变会使元素重新布局和绘制，包括它的孩子和同辈元素。添加一个DOM节点会导致重新布局和绘制这个节点，主要的变化，比如改变html元素的字体大小，会导致缓存失效，重新布局和绘制整棵渲染树。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;8 渲染引擎的线程&lt;/h2&gt;

&lt;p&gt;渲染引擎是单线程的，除了网络操作，大多数情况下是单线程的。在Firefox和Safari里，渲染线程是浏览器的主线程，但是在Chrome里它则是标签页进程的主线程。&lt;/p&gt;

&lt;p&gt;网络操作可以被多个线程并行执行，并行连接的数量是限定的(一般是2到6个连接，例如Firefox 3采用的是6个连接)。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;8.1 事件循环&lt;/h3&gt;

&lt;p&gt;浏览器的主线程是一个事件循环，而且这个循环是无限的来保持进程能一直存活下去。它等待事件(比如布局和绘制事件)的到来，然后处理他们。下面是Firefox的主事件循环代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (!mExiting)
    NS_ProcessNextEvent(thread);&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;css2&quot;&gt;9 CSS2的视觉模型&lt;/h2&gt;

&lt;h3 id=&quot;canvas&quot;&gt;9.1 画布(canvas)&lt;/h3&gt;

&lt;p&gt;根据CSS2的规范，画布是指：格式化结构被渲染的空间，也就是浏览器绘制内容的地方。画布在空间的任意维度上都是无限的，但是浏览器会在viewport的维度上选择一个初始宽度。&lt;/p&gt;

&lt;p&gt;根据&lt;a href=&quot;www.w3.org/TR/CSS2/zindex.html&quot; title=&quot;z-index&quot;&gt;z-index&lt;/a&gt;上所说，如果一个画布内包含了另一个画布的话，那么它内部的画布就会边透明；而如果没有包含其他画布的话，浏览器会给它一个浏览器定义的颜色。&lt;/p&gt;

&lt;h3 id=&quot;cssbox-model&quot;&gt;9.2 CSS的盒子模型(box model)&lt;/h3&gt;

&lt;p&gt;CSS的盒子模型描述的是在文档树中为元素生成的矩形盒子，并且根据视觉格式模型被展现出来。&lt;/p&gt;

&lt;p&gt;每个盒子有一个内容区域(比如：文字，图片等)和可选的padding，border以及margin区域。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7005/6505395185_30710fe726.jpg&amp;quot; width=&amp;quot;500&amp;quot; height=&amp;quot;342&amp;quot;&quot; alt=&quot;box model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个节点都会生成0到n个这样的盒子。所有的元素都有一个display属性，这个属性决定了要生成盒子的类型。例如：&lt;/p&gt;

&lt;p&gt;block  - generates a block box.
inline - generates one or more inline boxes.
none - no box is generated.&lt;/p&gt;

&lt;p&gt;默认的盒子是inline类型的，但是浏览器自带的样式标会设置成其他默认值。例如：div元素的display默认值是block。你可以在&lt;a href=&quot;www.w3.org/TR/CSS2/sample.html&quot;&gt;这里&lt;/a&gt;找到默认样式表的例子。&lt;/p&gt;

&lt;h3 id=&quot;scheme&quot;&gt;9.3 确定scheme的位置&lt;/h3&gt;

&lt;p&gt;有三种类型的scheme：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;普通： 对象是根据它在文档中的位置来确定位置的，也就是说它在渲染树中的位置就好像它在DOM树中的位置，然后根据它的盒子类型和维度展现出来。&lt;/li&gt;
  &lt;li&gt;浮动： 对象一开始是普通类型，然后尽可能地往左边或右边移动。&lt;/li&gt;
  &lt;li&gt;绝对： 对象在渲染树中的位置和它在DOM树中的位置不同。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;scheme的位置是通过设置position属性和float属性来确定的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态和相对的值生成普通流&lt;/li&gt;
  &lt;li&gt;绝对和固定的值生成绝对的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在静态位置确定过程中，position没有被定义，而且使用默认值，在其他scheme里，开发者指定了position(top,bottom,left,right)。&lt;/p&gt;

&lt;p&gt;盒子展现的方式是由以下条件决定的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;盒子的类型&lt;/li&gt;
  &lt;li&gt;盒子的维度&lt;/li&gt;
  &lt;li&gt;scheme的位置&lt;/li&gt;
  &lt;li&gt;外部信息(比如：图片大小和屏幕尺寸)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;9.4 盒子的类型&lt;/h3&gt;

&lt;p&gt;Block：在浏览器窗口中有自己的矩形区域&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7018/6505506095_ba7907c252_m.jpg&amp;quot; width=&amp;quot;150&amp;quot; height=&amp;quot;127&amp;quot;&quot; alt=&quot;block box&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Inline：没有自己的block，但是被其他block包含&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7029/6505521245_8a3aee3173_m.jpg&amp;quot; width=&amp;quot;240&amp;quot; height=&amp;quot;186&amp;quot;&quot; alt=&quot;inline box&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Block垂直方向上一个排列，Inline在水平方向上排列&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7003/6505539833_92df259ca6_m.jpg&amp;quot; width=&amp;quot;240&amp;quot; height=&amp;quot;222&amp;quot;&quot; alt=&quot;block and inline formatting&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Inline盒子被放在一行行中，所以又叫”line boxes”。行的高度至少要和最高的盒子一样，但是可以更高。当盒子和基准行(baseline)对齐时，意味着元素的底部和其他盒子不是底部的某个点对齐。为了防止容器的宽度不够，inline的盒子会被放在多行中，这一般发生在有段落的情况下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7160/6505571567_7834c0cae3_m.jpg&amp;quot; width=&amp;quot;240&amp;quot; height=&amp;quot;166&amp;quot;&quot; alt=&quot;lines&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;9.5 确定位置&lt;/h3&gt;

&lt;h4 id=&quot;section-8&quot;&gt;9.5.1 相对盒子&lt;/h4&gt;

&lt;p&gt;相对位置是：先像通常一样放置，然后根据差异移动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7010/6505597613_10dab9cd61_m.jpg&amp;quot; width=&amp;quot;240&amp;quot; height=&amp;quot;125&amp;quot;&quot; alt=&quot;relative positioning&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;9.5.2 漂浮盒子&lt;/h4&gt;

&lt;p&gt;漂浮盒子是偏移到一行左边或右边，有趣的特性是其他盒子环绕在它的旁边。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
  &amp;lt;img style=&amp;quot;float:right&amp;quot; src=&amp;quot;images/image.gif&amp;quot; width=&amp;quot;100&amp;quot; height=&amp;quot;100&amp;quot;&amp;gt;
  Lorem ipsum dolor sit amet, consectetuer...
&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;的结果会是下面这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7160/6505635961_734095bce0_m.jpg&amp;quot; width=&amp;quot;240&amp;quot; height=&amp;quot;110&amp;quot;&quot; alt=&quot;float&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;9.5.3 绝对和固定盒子&lt;/h4&gt;

&lt;p&gt;绝对和固定盒子的定义独立于普通流，元素也不参与普通流，它的维度是相对于容器的。固定盒子的容器是viewport。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7164/6505656271_8a14ca32f2_m.jpg&amp;quot; width=&amp;quot;240&amp;quot; height=&amp;quot;165&amp;quot;&quot; alt=&quot;fixed positioning&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：固定盒子不会移动，即使下拉窗口！&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;9.6 基于层次的表现形式&lt;/h3&gt;

&lt;p&gt;它是用CSS中的z-index来指定的，它代表了盒子的第三维度，它的位置是沿着Z轴的。盒子被分成很多堆(称为堆积上下文)，在每个堆里最后一个元素首先被绘制，然后是前面的元素，所以前面的元素更靠近用户。为了防止重叠，先绘制的元素将被隐藏。&lt;/p&gt;

&lt;p&gt;堆是根据z-index属性来排序的，盒子是和z-index属性一起存放在本地堆中，viewport则有外部堆。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
      div { 
        position: absolute; 
        left: 2in; 
        top: 2in; 
      }
&amp;lt;/style&amp;gt;

&amp;lt;p&amp;gt;   
    &amp;lt;div style=&amp;quot;z-index: 3;background-color:red; width: 1in; height: 1in; &amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;z-index: 1;background-color:green;width: 2in; height: 2in;&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
 &amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果会是下面这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7021/6505743937_a87c962997_m.jpg&amp;quot; width=&amp;quot;240&amp;quot; height=&amp;quot;214&amp;quot;&quot; alt=&quot;fixed positioning&quot; /&gt;&lt;/p&gt;

&lt;p&gt;尽管红色div声明在绿色之前而且会被首先绘制，但是它z-index属性值更大，所以它在根盒子持有的堆中位置更靠前。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;全文完&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>浏览器是如何工作的(九)</title>
   <link href="/blog/2011/12/15/how-browsers-work-nine/"/>
   <updated>2011-12-15T22:19:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/15/how-browsers-work-nine</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;5 布局&lt;/h2&gt;

&lt;p&gt;当renderer被创建和加入到树中时，它是没有位置和大小的，计算这两个值称为布局或回流(reflow)。&lt;/p&gt;

&lt;p&gt;HTML使用的是基于布局模型的流，这意味着大多数时间内，单一路径下计算几何值是可能的。后进入流的元素不会影响比它先进入流的元素的几何属性值，所以布局文档可以被从左到右，从上到下处理。但是也有例外：比如，HTML的table元素可能需要多条路径。&lt;/p&gt;

&lt;p&gt;坐标系统是和根框架相关的，而且使用的是上坐标和左坐标。&lt;/p&gt;

&lt;p&gt;布局是一个迭代的过程，它从根renderer(对应于HTML文档的&amp;lt;html&amp;gt;元素)开始。布局迭代部分或整个框架，计算每个renderer的几何信息。&lt;/p&gt;

&lt;p&gt;根renderer的位置是0,0，它的范围是viewport(浏览器窗口的可视区域)。所有的renderer都有layout或reflow方法，每个renderer调用需要生成布局的孩子的layout方法。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5.1 脏位系统&lt;/h3&gt;

&lt;p&gt;为了在细小的改动是不重新生成整个布局，浏览器使用一个叫脏位(dirty bit)的系统。一个被修改或添加的renderer，它和它的孩子都会被标记为”dirty”，意思是说需要重新布局。&lt;/p&gt;

&lt;p&gt;浏览器有2个标志位：“dirty”和”children are dirty”。后者的意思是也许这个renderer本身不需要重新布局，但是它的孩子中至少有一个需要重新布局。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;5.2 全局和增量布局&lt;/h3&gt;

&lt;p&gt;布局可以在整个渲染树上被触发，这就叫做全局(global)布局。全局布局的触发条件为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;全局样式的改变影响了所有的renderer，例如修改字体大小。&lt;/li&gt;
  &lt;li&gt;窗口大小的改变。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;布局可以是增量式的，只有脏renderer会被设置布局(这样会造成需要做额外布局的危害)。&lt;/p&gt;

&lt;p&gt;当renderer被标记为脏时，增量布局被异步触发。例如在从网络上获取内容后，新renderer被附加到渲染树，并且被加入到DOM树中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7167/6498973627_ca37c1cac5.jpg&amp;quot; width=&amp;quot;326&amp;quot; height=&amp;quot;341&amp;quot;&quot; alt=&quot;reflow&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;5.3 异步和同步布局&lt;/h3&gt;

&lt;p&gt;增量布局的过程是异步的，Firefox把reflow命令放入队列，然后用一个调度器批量的执行这些命令。Webkit也有一个计时器来实现增量布局，遍历渲染树把脏renderer重新布局。&lt;/p&gt;

&lt;p&gt;脚本请求样式信息，比如offsetHeight，会触发同步的增量布局。全部布局一般都是同步触发的，有些时候因为一些属性的原因，布局在初始后被作为回调函数触发，比如下拉位置的改变。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;5.4 优化&lt;/h3&gt;

&lt;p&gt;当布局是因为大小改变或者renderer的位置改变而触发，那么renderer的大小将从cache从读取，不会重新计算。&lt;/p&gt;

&lt;p&gt;在一些情况下，比如只有子树被修改和布局不是从根开始，这是由于修改是在本地而且没有影响到周围元素，比如文本插入到文本区域。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;5.5 布局过程&lt;/h3&gt;

&lt;p&gt;布局总是有下面的模式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;双亲renderer决定自己的宽度。&lt;/li&gt;
  &lt;li&gt;双亲转为孩子并且：
    &lt;ol&gt;
      &lt;li&gt;设置孩子renderer的x和y&lt;/li&gt;
      &lt;li&gt;如果被标记为脏或者在全局布局中等原因，则调用孩子的layout方法，这会导致计算孩子的高度。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;双亲使用孩子累积的height，margin和padding来设置自己的对应值。&lt;/li&gt;
  &lt;li&gt;设置脏位为false。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Firefox使用一个状态对象(nsHTMLReflowState)作为布局的一个参数，在其他状态中包括了双亲的宽度。Firefox布局的输出是一个metrics对象(nsHTMLReflowMetrics)，它包含了renderer的高度。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;5.6 宽度计算&lt;/h3&gt;

&lt;p&gt;renderer的宽度是用容器宽度来计算的，renderer的width样式属性，margin和border属性。&lt;/p&gt;

&lt;p&gt;例如计算下面div的宽度：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;width:30%&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Webkit是这样计算的(RenderBox类的calcWidth方法)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;容器的宽度取容器可以达到的最大宽度与0两者之间较大的那个，可以达到的最大宽度就是内容宽度，它的计算方式是：clientWidth() - paddingLeft() - paddingRight()，clientWidth和clientHeight表示的是除了border和scrollbar之外的内部对象。&lt;/li&gt;
  &lt;li&gt;元素的宽度是有样式属性width决定的，它是计算容器宽度的百分比得出的一个绝对数值。&lt;/li&gt;
  &lt;li&gt;然后加入水平边框和缩进&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到目前为止是偏好宽度(preferred width)的计算，然后最小和最大宽度值会被计算。如果偏好宽度比最大宽度大，那么就会使用最大宽度，同样如果小于最小宽度，那么就会使用最小宽度。&lt;/p&gt;

&lt;p&gt;以防万一宽度没有改变的情况下需要重新布局，所以宽度的值都会被缓存。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;5.7 换行&lt;/h3&gt;

&lt;p&gt;当一个renderer在布局的中间时就需要被分开，这时它会停止布局并告诉双亲它需要被分开，然后双亲就会创建额外的renderer和在他们身上调用layout方法。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>浏览器是如何工作的(八)</title>
   <link href="/blog/2011/12/14/how-browsers-work-eight/"/>
   <updated>2011-12-14T21:32:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/14/how-browsers-work-eight</id>
   <content type="html">&lt;h3 id=&quot;section&quot;&gt;4.3.3 简单规则匹配的例子&lt;/h3&gt;

&lt;p&gt;样式规则有下面几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CSS规则，外部表单或style元素&lt;/p&gt;

    &lt;p&gt;p {color:blue}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内联style属性&lt;/p&gt;

    &lt;p style=&quot;color:blue&quot; /&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTML的视觉属性(会被映射到相关的样式规则)&lt;/p&gt;

    &lt;p bgcolor=&quot;blue&quot; /&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后两种很容易和元素匹配，因为元素有style属性和HTML属性，他们可以用元素作为key来映射。&lt;/p&gt;

&lt;p&gt;前面提到过的问题#2，CSS规则匹配可以是很复杂的。为了解决这个难题，所以对规则做一些处理，让获取规则更容易。&lt;/p&gt;

&lt;p&gt;在解析样式表后，根据选择器规则会被加入到一个或多个hashmap中。这些map有以id为key的，有以class名key的，有以tag名为key的，还有一个通用map，它的key可以是任何类型。如果选择器是id选择器，那么规则会被加入到以id为key的map中，以此类推。&lt;/p&gt;

&lt;p&gt;这个处理会使匹配规则变得更加容易。现在就没有必要查看每个定义，我们可以从map中得到相关的规则。这个优化消除了超过95%的规则，所以他们甚至在匹配过程中都不需要被考虑。&lt;/p&gt;

&lt;p&gt;让我们看下面一个样式规则的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p.error {color:red}
#messageDiv {height:50px}
div {margin:5px}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面第一个规则会被插入到以class为key的map中，第二个规则会被插入到以id为key的map中，第三个规则会被插入到以tag名为key的map中。&lt;/p&gt;

&lt;p&gt;对于下面的HTML片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p class=&amp;quot;error&amp;quot;&amp;gt;an error occurred &amp;lt;/p&amp;gt;
&amp;lt;div id=&amp;quot; messageDiv&amp;quot;&amp;gt;this is a message&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先尝试寻找对应p元素的规则，在以class为key的map里找到一个以error为key的规则p.error。div元素在id的map和tag名的map中都有相关规则，所以剩下要做的只是找到哪个规则是真正匹配的规则。&lt;/p&gt;

&lt;p&gt;例如下面的div样式规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;table div {margin:5px}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更好匹配的是tag名的map，因为tag名是最右端的选择器，但是如果div元素没有table锚点的话就不会匹配。&lt;/p&gt;

&lt;p&gt;Webkit和Firefox都会做这个处理。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;4.3.4 在正确的层级顺序中应用规则&lt;/h3&gt;

&lt;p&gt;style对象有对应于视觉属性的属性，如果属性没有对应的规则，那么一些属性可以继承双亲元素的style对象，其他的属性有默认值。&lt;/p&gt;

&lt;p&gt;当有多个定义的时候问题就来了，解决这个问题靠的是层级顺序。&lt;/p&gt;

&lt;p&gt;样式表的层级顺序&lt;/p&gt;

&lt;p&gt;style属性的声明可以在多个样式表中被声明，有时在一个样式表中，这意味着应用规则的顺序变得非常重要。这被称为层级顺序，根据CSS2的规范说明，层级顺序是(从低到高)：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;浏览器定义&lt;/li&gt;
  &lt;li&gt;用户普通定义&lt;/li&gt;
  &lt;li&gt;开发者普通定义&lt;/li&gt;
  &lt;li&gt;开发者重要定义&lt;/li&gt;
  &lt;li&gt;用户重要定义&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;浏览器定义是最不重要的，用户定义的样式如果被标记为重要的就可以覆盖开发者定义的样式。如果是相同顺序的定义会被&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Specificity&quot; title=&quot;specificity&quot;&gt;特征(specificity)&lt;/a&gt;排序，经过排序后的顺序是特征化的。HTML视觉属性被翻译成匹配的CSS声明，他们是以低优先级的开发者规则被对待的。&lt;/p&gt;

&lt;p&gt;特征(Specificity)&lt;/p&gt;

&lt;p&gt;选择器的特征在&lt;a href=&quot;http://www.w3.org/TR/CSS2/cascade.html#specificity&quot; title=&quot;CSS2&quot;&gt;CSS2规范&lt;/a&gt;中被定义为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果样式声明是从style属性中来，而不是一个选择器的规则，那么特征就为1，否则就为0(= a)&lt;/li&gt;
  &lt;li&gt;计算选择器的ID属性的数量(= b)&lt;/li&gt;
  &lt;li&gt;计算选择器中其他属性和pseudo-class的数量(= c)&lt;/li&gt;
  &lt;li&gt;计算选择器中元素名和pseudo-element的数量(= d)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后特征值就是把上面四个数字连起来：a-b-c-d&lt;/p&gt;

&lt;p&gt;数的进制是上面四个数的最大值决定的。例如，如果a = 14，那么就可以使用16进制；而如果a = 17的话，就需要使用18或更高进制。后一种情况在选择器类似于html body div div p … 的情况下会发生。&lt;/p&gt;

&lt;p&gt;一些例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*             {}  /* a=0 b=0 c=0 d=0 -&amp;gt; specificity = 0,0,0,0 */
 li            {}  /* a=0 b=0 c=0 d=1 -&amp;gt; specificity = 0,0,0,1 */
 li:first-line {}  /* a=0 b=0 c=0 d=2 -&amp;gt; specificity = 0,0,0,2 */
 ul li         {}  /* a=0 b=0 c=0 d=2 -&amp;gt; specificity = 0,0,0,2 */
 ul ol+li      {}  /* a=0 b=0 c=0 d=3 -&amp;gt; specificity = 0,0,0,3 */
 h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -&amp;gt; specificity = 0,0,1,1 */
 ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -&amp;gt; specificity = 0,0,1,3 */
 li.red.level  {}  /* a=0 b=0 c=2 d=1 -&amp;gt; specificity = 0,0,2,1 */
 #x34y         {}  /* a=0 b=1 c=0 d=0 -&amp;gt; specificity = 0,1,0,0 */
 style=&amp;quot;&amp;quot;          /* a=1 b=0 c=0 d=0 -&amp;gt; specificity = 1,0,0,0 */&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;规则排序&lt;/p&gt;

&lt;p&gt;在所有的规则匹配之后，他们会根据层级规则被排序。Webkit使用冒泡排序法对小的集合排序，用归并排序法对大的集合排序。Webkit依靠重写&lt;code&gt;&amp;gt;&lt;/code&gt;操作符来实现排序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static bool operator &amp;gt;(CSSRuleData&amp;amp; r1, CSSRuleData&amp;amp; r2)
{
    int spec1 = r1.selector()-&amp;gt;specificity();
    int spec2 = r2.selector()-&amp;gt;specificity();
    return (spec1 == spec2) : r1.position() &amp;gt; r2.position() : spec1 &amp;gt; spec2; 
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;4.4 渐进的过程&lt;/h2&gt;

&lt;p&gt;Webkit使用一个标志来标记所有顶层样式表(包括@imports)被加载完成。如果在样式没有完全被加载时就去访问它，那么站位符就会被使并且在文档中被标记，在样式表被加载完成后重新计算。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>浏览器是如何工作的(七)</title>
   <link href="/blog/2011/12/13/how-browsers-work-seven/"/>
   <updated>2011-12-13T15:13:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/13/how-browsers-work-seven</id>
   <content type="html">&lt;h2 id=&quot;dom&quot;&gt;4.1 渲染树和DOM树的关系&lt;/h2&gt;

&lt;p&gt;renderer对应于DOM的元素，但并不是一对一的关系。非视觉DOM元素不会被插入渲染树，比如head元素。元素的视觉属性是”none”的元素不会出现在树中(视觉属性是”hidden”话会出现在树中)。&lt;/p&gt;

&lt;p&gt;DOM元素对应多个视觉对象。一般情况下，复杂结构的元素不能在单个矩形中被描述清楚。比如select元素有3个renderer：一个是显示区域；一个是下拉框；还有一个是按钮。当文字被分成多行的时候(在一行里显示的宽度不够)，新的行会被作为附加renderer加入到树中。&lt;/p&gt;

&lt;p&gt;另一个有许多renderer的例子例子是不完整的HTML。根据CSS规范，内联元素必须包含块元素或着只包含内联元素。为了防止混合的内容，匿名块renderer会被创建来包裹内敛元素。&lt;/p&gt;

&lt;p&gt;有些渲染对象对应于DOM节点，但不是在树中的相同位置。浮动元素和绝对固定位置的元素会被放置在树中的不同的位置，而且映射到实际的frame中去，所以它应该是有站位符的frame。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7156/6486727487_c447bed064.jpg&amp;quot; width=&amp;quot;500&amp;quot; height=&amp;quot;271&amp;quot;&quot; alt=&quot;render tree corresponding dom tree&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;4.2 构造树的流程&lt;/h2&gt;

&lt;p&gt;在Firefox中，展示层为了DOM更新而注册成了一个监听器。展示层把frame的创建代理给了FrameConstructor，而且构造器处理样式和创建frame。&lt;/p&gt;

&lt;p&gt;在Webkit中，处理样式和创建renderer被称为“attachment”。每个DOM节点都有一个”attach”方法。“attachment”是同步的，节点被添加到DOM树中被称为新节点”attach”方法。&lt;/p&gt;

&lt;p&gt;处理html和body标签会造成渲染树根节点的构造。根渲染对象对应于在CSS规范中的containing block(最上端包含其他所有block的block)。跟节点的大小就是viewport(浏览器窗口显示的区域大小)，Firefox把它称作ViewPortFrame，而Webkit把它称为RenderView。这就是文档指向的渲染对象，树的其余部分是通过插入DOM节点来构造的。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;4.3 样式的计算&lt;/h2&gt;

&lt;p&gt;构建渲染树的时候需要计算渲染对象的视觉属性，这是通过计算每个元素的style属性完成的。&lt;/p&gt;

&lt;p&gt;样式包括各种样式表源，内联样式元素和HTML里的视觉属性(比如”bgcolor”属性)，然后再被转换匹配CSS里的属性。&lt;/p&gt;

&lt;p&gt;样式表源是浏览器的默认样式表，样式表由开发者和用户样式表提供。用户样式表是由浏览器使用者提供(浏览器允许自定义样式，比如在Firefox中，可以通过在”Firefox Profile”文件夹下放置样式表来实现)。&lt;/p&gt;

&lt;p&gt;样式的计算有一些难点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;样式数据结构非常庞大，持有大量的样式属性会有内存问题。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为每个元素找到对应的规则在没有优化的情况下会有性能问题。为每个元素遍历整个规则表是一个非常繁重的工作。选择器的结构有的非常负责，这会造成匹配过程从一个看上去有希望的路径开始，但最后证明是无效的，然后尝试另一个路径。&lt;/p&gt;

    &lt;p&gt;例如下面这个组合选择器：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;div div div div{
...
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;上面例子的样式意味着要应用到一个被3个div包含的&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;上去。假如你想检查这个规则被应用到了一个给定的div元素上，你需要选择某个路径向上查找。你可能会向上遍历节点树，发现只有2个div元素，然后尝试另一条路径。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;应用规则包括非常复杂的层级规则，它定义了规则的继承关系。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;让我们来看一下浏览器是怎么处理这些问题的：&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;4.3.1 共享样式数据&lt;/h3&gt;

&lt;p&gt;Webkit的节点引用样式对象(RenderStyle)，这些对象可以在某些条件下被节点共享。这些节点是兄弟或同辈节点，而且：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;元素必须在相同的鼠标状态下(比如，一个有&lt;code&gt;:hover&lt;/code&gt;而另一个没有)&lt;/li&gt;
  &lt;li&gt;两个元素都不应该有id&lt;/li&gt;
  &lt;li&gt;标签名要匹配&lt;/li&gt;
  &lt;li&gt;class属性要匹配&lt;/li&gt;
  &lt;li&gt;映射过的属性要一致&lt;/li&gt;
  &lt;li&gt;link要匹配&lt;/li&gt;
  &lt;li&gt;focus要匹配&lt;/li&gt;
  &lt;li&gt;两个元素都不能被属性选择器影响，影响的是定义为拥有任何选择器匹配使用一个属性的选择器。&lt;/li&gt;
  &lt;li&gt;元素没有内联样式属性&lt;/li&gt;
  &lt;li&gt;必须有兄弟选择器，当遇到任何的兄弟选择器，WebCore简单的抛出一个全局switch，当他们出现时对整个文档禁用样式共享。这包括+选择器和:first-child，:last-child选择器。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;firefox&quot;&gt;4.3.2 Firefox规则树&lt;/h3&gt;

&lt;p&gt;为了更简单地计算样式，Firefox有两个额外的树：规则树和样式上下文树。Webkit也有样式对象，不过他们都不保存在树中，只有DOM节点指向与它相关的样式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7031/6490768261_6bb541748b.jpg&amp;quot; width=&amp;quot;500&amp;quot; height=&amp;quot;318&amp;quot;&quot; alt=&quot;style context tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;样式上下文树包含最终值。这个值是通过应用在正确顺序上的所有匹配的规则和把逻辑值转换成具体的值。比如，如果逻辑值是屏幕的百分比，那它会被计算和转换成绝对值。规则树的想法真的是非常聪明，它使得在节点间共享这些值，避免了再次的计算，也节省了空间。&lt;/p&gt;

&lt;p&gt;所有匹配的规则被保存在一个树中，叶子节点在路径上有更高的优先级。这棵树包含所有已经找到并且匹配的路径。规则是延迟保存的，这棵树不会在一开始为每个节点计算，只是当一个节点的样式需要被计算时，计算路径才会被加入到树中。&lt;/p&gt;

&lt;p&gt;这个查找路径的想法就像在字典中查单词一样，让我看一下已经计算好的规则树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7152/6490816137_053bb01868.jpg&amp;quot; width=&amp;quot;400&amp;quot; height=&amp;quot;261&amp;quot;&quot; alt=&quot;rule tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设我们需要为一个上下文树中的元素匹配规则，并且找到了匹配的规则是B - E - I。我们已经在树中有这个路径，因为我们已经计算了路径A - B - E - I - L，所以现在剩下的工作变得轻松很多。&lt;/p&gt;

&lt;p&gt;让我看一下这棵树是怎么减轻我们的工作量的。&lt;/p&gt;

&lt;p&gt;分配成为结构(Division into structs)&lt;/p&gt;

&lt;p&gt;样式上下文被分配成为结构。这些结构包含了某个种类的样式信息，比如border或color。所有的属性在结构中要么被继承，要么没有被继承。继承的属性除非是被元素定义，否则继承自他的父亲。没有继承的属性(被称为”reset”属性)在某有定义的情况下使用默认值。&lt;/p&gt;

&lt;p&gt;这棵树的作用是缓存树中的整个结构(包含计算完成的最终值)。这个想法就是，如果底端的节点不能满足一个结构的定义，那么就可以使用缓存结构中更上层的节点。&lt;/p&gt;

&lt;p&gt;用规则树计算样式上下文&lt;/p&gt;

&lt;p&gt;当为某个元素计算样式上下文时，我们首先计算规则树中的一个路径，或者使用现有的一个路径。然后开始应用路径上的规则来填充新样式上下文的结构。我们从路径的底部节点开始(最高的优先级，通常是最具体的选择器)向上遍历整棵树直到结构被填充满。如果在规则节点中没有结构的规范，我们就可以做巨大的优化(向上遍历树直到找到一个完全匹配的节点，然后简单地指向它，这是最优优化，因为整个结构被共享了，节省计算最终值的工作量和内存）。&lt;/p&gt;

&lt;p&gt;如果只找到部分定义就向上查找知道结构被填满。&lt;/p&gt;

&lt;p&gt;如果没有找到对结构的任何定义，为了防止结构是一个继承类型，就把它指向上下文树的双亲结构，在这种情况下我们也能共享结构，如果是一个reset结构，那么将会使用默认值。&lt;/p&gt;

&lt;p&gt;如果大多数特定的节点加入了值，我们需要做一些额外的计算把它转换成实际值，然后在缓存结果在树节点中，然后就可以被子节点使用。&lt;/p&gt;

&lt;p&gt;为了防止一个元素有兄弟，把它指向同一个节点，这样的话整个样式上下文可以被他们共享。&lt;/p&gt;

&lt;p&gt;让我看个例子，假设有下面的HTML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;err&amp;quot; id=&amp;quot;div1&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;
        this is a &amp;lt;span class=&amp;quot;big&amp;quot;&amp;gt; big error &amp;lt;/span&amp;gt;
        this is also a
        &amp;lt;span class=&amp;quot;big&amp;quot;&amp;gt; very  big  error&amp;lt;/span&amp;gt; error
      &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;err&amp;quot; id=&amp;quot;div2&amp;quot;&amp;gt;another error&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和下面的规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. div {margin:5px;color:black}
2. .err {color:red}
3. .big {margin-top:3px}
4. div span {margin-bottom:4px}
5. #div1 {color:blue}
6. #div2 {color:green}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了简便，我们之需要填充两个结构：color和margin结构。color结构只包含一个成员color；margin结构包含四个方面。&lt;/p&gt;

&lt;p&gt;规则树的结果大致是下面的样子(节点用节点名标记，#号后的数字是它指向的规则)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7163/6490941481_7c897aeef6.jpg&amp;quot; width=&amp;quot;500&amp;quot; height=&amp;quot;294&amp;quot;&quot; alt=&quot;rule tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上下文树则是下面的的样子(冒号后的是它指向的规则节点)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7172/6490949269_a4116c1fd5.jpg&amp;quot; width=&amp;quot;400&amp;quot; height=&amp;quot;305&amp;quot;&quot; alt=&quot;context tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设解析HTML而且要得到第二个div标签，我们需要为这个节点创建一个样式上下文，然后填充它的样式结构。&lt;/p&gt;

&lt;p&gt;匹配规则后发现与这个div匹配的规则是1，2和6。这意味着在树中已经有一个存在的路径供我们的元素使用，只要加入另一个节点6到规则树中(规则树的节点F)。&lt;/p&gt;

&lt;p&gt;我们将会创建一个样式上下文，并把它加入到上下文树中，新的样式上下文将指向规则树的节点F。&lt;/p&gt;

&lt;p&gt;现在需要填充样式结构了。我们从填充margin结构开始，因为最后的规则节点F没有加入到margin结构，我们向上查找节点直到找到在上一次节点插入是已经缓存的计算完成的结构，然后使用这个结构。这个节点就是B，它是margin规则的最上层节点。&lt;/p&gt;

&lt;p&gt;我们有一个color结构的定义，所以我们不能使用缓存的结构。因为color有一个属性，所以不需要向上查找节点填充其他属性。我们只要计算最终值(把字符串转换成RGB等)，并且缓存这个节点的结构。&lt;/p&gt;

&lt;p&gt;第二个span元素的工作更容易。匹配规则的结果是像前一个span一样指向G。因为我们有兄弟节点指向相同节点，我们可以共享整个样式上下文，只需要指向上一个span的上下文。&lt;/p&gt;

&lt;p&gt;对于包含继承它双亲的规则的结构来说，缓存是在上下文树中完成的。(coloor属性是被继承的，但是Firefox把它当作reset，缓存在规则树上)。&lt;/p&gt;

&lt;p&gt;例如，如果我们在一个段落里加入字体规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p {font-family:Verdana;font size:10px;font-weight:bold}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;段落元素是上下文树中div节点的孩子节点，所以如果段落没有定义字体规则的情况下，可以共享它双亲相同的字体结构。&lt;/p&gt;

&lt;p&gt;Webkit没有规则树，所以匹配的定义要遍历4次。首先是非重要高优先级属性先于高优先级重要属性(被其他的属性依赖的属性先要被生成节点，比如display)被生成节点。然后一般优先级非重要属性，再是一般优先级重要属性。这意味着出现多次的属性会被处理多次，但是结果由最后一次决定。&lt;/p&gt;

&lt;p&gt;所以总结来说：共享样式对象(全部或者部分结构)可以解决问题1和3。Firefox的规则树则会帮助在正确的顺序下应用属性。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>浏览器是如何工作的(六)</title>
   <link href="/blog/2011/12/12/how-browsers-work-six/"/>
   <updated>2011-12-12T20:57:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/12/how-browsers-work-six</id>
   <content type="html">&lt;h2 id=&quot;css&quot;&gt;3.3 CSS解析&lt;/h2&gt;

&lt;p&gt;和HTML不同，CSS是内容无关的语法，所以可以被一般解析器解析。CSS规范定义了词法和语法。&lt;/p&gt;

&lt;p&gt;让我们来看一些例子：&lt;/p&gt;

&lt;p&gt;CSS的文法(词汇)是用正则表达式定义的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;comment   \/\*[^*]*\*+([^/*][^*]*\*+)*\/
num   [0-9]+|[0-9]*&amp;quot;.&amp;quot;[0-9]+
nonascii  [\200-\377]
nmstart   [_a-z]|{nonascii}|{escape}
nmchar    [_a-z0-9-]|{nonascii}|{escape}
name    {nmchar}+
ident   {nmstart}{nmchar}*&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ident是identifier的缩写，比如class的名字；name是元素id(#号引用)。而语法使用BNF描述的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]? 
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ] ']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
  ;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如下面的CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div.error , a.error {
  color:red;
  font-weight:bold;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;div.error和a.error是选择器，大括号里包含的就是ruleset里定义的规则，它适用于下面的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，ruleset是一个或多个选择器，他们由逗号隔开，S代表空格。ruleset包括大括号和其中的一个或多个，由分号隔开的声明。”声明”和”选择器“会在下面的BNF定义中介绍。&lt;/p&gt;

&lt;h3 id=&quot;webkitcss&quot;&gt;3.3.1 Webkit的CSS解析器&lt;/h3&gt;

&lt;p&gt;Webkit使用Flex和Bison解析器生成器，从CSS语法文件自动创建解析器，而Bison创建的是自下而上的shift-reduce解析器。Firefox使用手动写的自上而下的解析器。两种情况下，每个CSS文件都会被解析成为StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含选择器和声明对象，还有其他CSS语法中对应的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7145/6486240717_22094df7b7.jpg&amp;quot; width=&amp;quot;500&amp;quot; height=&amp;quot;393&amp;quot;&quot; alt=&quot;parsing css&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;scriptsstyle-sheets&quot;&gt;3.4 处理scripts和style sheets的顺序&lt;/h2&gt;

&lt;h3 id=&quot;scripts&quot;&gt;3.4.1 Scripts&lt;/h3&gt;

&lt;p&gt;web的模型是异步的。开发者希望当遇到&lt;script&gt;标签后，脚本能够立即被解析和执行。文档的解析会被挂起，知道脚本执行完毕。如果脚本是从外部引用的，那么必须先从网络上把拿到这个脚本，这个过程是同步的，直到脚本被抓取到本地后才会开始解析。这个模型已经存在了很多年，而且在HTML4和5规范中也有定义。开发者可以把脚本标记为”differ”，这样的话就不会挂起文档解析，脚本解析完后就会执行。HTML5加入了一个可以标记脚本为异步的选项，所以它会被另一个线程解析和执行。&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&quot;speculative-parsing&quot;&gt;3.4.2 Speculative parsing&lt;/h3&gt;

&lt;p&gt;Webkit和Firefox都会做这种优化。当脚本在执行时，另一个线程解析剩下的文档和找出其他需要从网络上加载的资源，并且加载他们。在这种方式下，资源可以在并行连接的情况下加载，而且总的速度会更好。注意，speculative parser不会修改DOM树，然后把它交给主解析器，它只解析外部资源的引用，比如外部脚本，样式表和图片。&lt;/p&gt;

&lt;h3 id=&quot;style-sheets&quot;&gt;3.4.3 Style sheets&lt;/h3&gt;

&lt;p&gt;没有理由等待DOM树和停止文档解析。有个脚本的问题就是在文档解析阶段脚本请求样式的信息。如果样式还没有被加载和解析，脚本会获得错误的结果，这样明显会产生许多问题。这看上去是一个边界条件，但又是非常普遍。Firefox在CSS加载和解析的时候会阻塞所有的脚本。Webkit只在尝试获取某个特定的CSS属性，而这个属性会被未加载的CSS影响到时阻塞脚本。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;4 渲染构造树&lt;/h2&gt;

&lt;p&gt;当DOM树被构造完成后，浏览器会构造另一棵树，即渲染树。这棵树是按顺序的视觉元素构成的，而且他们会被显示。它是文档的视觉展现。渲染树的目的是使内容在正确的顺序上绘制。&lt;/p&gt;

&lt;p&gt;Firefox把渲染树里的元素称为”frames”，Webkt则是render或render object。
Webkit的RenderObject类是renderer的基本类，它的定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个renderer代表了一个矩形区域，类似于节点的CSS盒子模型。它包括了几何信息，比如宽度，高度和位置。&lt;/p&gt;

&lt;p&gt;盒子的类型会被”display”样式的属性影响(参看style computation部分)。下面的Webkit代码是决定的是，根据显示属性，什么类型的renderer应该被创建为DOM节点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node-&amp;gt;document();
    RenderArena* arena = doc-&amp;gt;renderArena();
    ...
    RenderObject* o = 0;

    switch (style-&amp;gt;display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }

    return o;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;元素类型也是会被考虑的，例如，form控制和table有特殊的框架。在Webkit中，如果元素想要创建特殊的renderer，它会覆盖createRenderer方法。renderer指向包含非几何信息的style object。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>浏览器是如何工作的(五)</title>
   <link href="/blog/2011/12/11/how-browsers-work-five/"/>
   <updated>2011-12-11T17:14:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/11/how-browsers-work-five</id>
   <content type="html">&lt;h3 id=&quot;section&quot;&gt;3.2.6 标记算法&lt;/h3&gt;

&lt;p&gt;这个算法的输出是一个HTML标记，它可以用状态机来表示。每个状态消费输入流的一个或多个字符，然后根据这些字符更新下一个状态。状态的更新是由当前标记状态和树构造状态决定的。这意味着根据当前状态，同样的字符会对下一个正确的状态产生不同的结果。这个算法太复杂，所以不能完全描述清楚，所以让我来看一个简单的例子，这个例子会帮助我们理解这个算法。&lt;/p&gt;

&lt;p&gt;标记下面的HTML：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    Hello world
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始状态是“&lt;strong&gt;Data state&lt;/strong&gt;”。当遇到字符 &amp;lt; 后，状态被改变成”&lt;strong&gt;Tag open state&lt;/strong&gt;”。消费一个a到z的字符会创建”&lt;strong&gt;Start tag token&lt;/strong&gt;”，而状态会变成”&lt;strong&gt;Tag name state&lt;/strong&gt;”。然后状态一直保持到遇到 &amp;gt; 字符。每个字符被加在了新标记名称之后，在这个例子中，被创建的标记是html。&lt;/p&gt;

&lt;p&gt;当遇到 &amp;gt; 字符后，当前状态被改回成”&lt;strong&gt;Data state&lt;/strong&gt;”。下面的&amp;lt;body&amp;gt;标签是同样的处理步骤。到目前为止，&amp;lt;html&amp;gt;和&amp;lt;body&amp;gt;标签处理完成了，回到了”&lt;strong&gt;Data state&lt;/strong&gt;”状态。然后碰到的是Hello world中的H字符，这会导致标记的创建直到遇到&amp;lt;/body&amp;gt;标签的 &amp;lt; 字符，然后为Hello world的每个字符释放字符标记。&lt;/p&gt;

&lt;p&gt;我们现在回到了”&lt;strong&gt;Tag open state&lt;/strong&gt;”状态。下面一个遇到的字符是/，这会导致创建 end tag token 并且状态改变为”&lt;strong&gt;Tag name state&lt;/strong&gt;”。同样，这个状态持续到遇到 &amp;gt; 字符。然后新的标签会被释放，回到”&lt;strong&gt;Data state&lt;/strong&gt;”状态。&amp;lt;/html&amp;gt;标签是同样的处理流程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7145/6485458369_9f574b3101.jpg&amp;quot; width=&amp;quot;500&amp;quot; height=&amp;quot;309&amp;quot;&quot; alt=&quot;tokenizing state machine&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;3.2.7 树的构造算法&lt;/h3&gt;

&lt;p&gt;当解析器被创建的时候，文档对象就被创建了。在整个构造树的过程中，DOM树的根结点会被修改或者添加元素。每个节点的释放由树构造器处理。对于每个标记，规范定义了与之相对应的DOM元素，所以会创建相对应的DOM元素。除了向DOM树中添加元素外，还会向开放元素的栈中添加。这个栈是被用来纠正嵌套错误和未关闭的标签。这个算法也被描述为一个状态机，那些状态被称为&lt;strong&gt;插入模式&lt;/strong&gt;(insertion modes)。&lt;/p&gt;

&lt;p&gt;让我们来看一下树的构造过程，比如下面的输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    Hello world
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入对于构造树的阶段来说，是一个初始模式是”&lt;strong&gt;initial mode&lt;/strong&gt;”的标记序列。获取HTML标记会引发向”&lt;strong&gt;before html&lt;/strong&gt;”模式的移动，并且在那个模式下的再次处理。这会造成HTMLHtmlElement元素的创建，然后被附加到对象模型的根结点上去。&lt;/p&gt;

&lt;p&gt;然后状态会变成”&lt;strong&gt;before head&lt;/strong&gt;”。尽管没有head标记，当得到body标记，HTMLHeadElement元素会被隐式地创建，然后加入到树中。&lt;/p&gt;

&lt;p&gt;现在模式移动，从”&lt;strong&gt;in head&lt;/strong&gt;”模式再到”&lt;strong&gt;after head&lt;/strong&gt;”模式。body标记被再次处理，HTMLBodyElement元素被创建，并且模式被转移到了”&lt;strong&gt;in body&lt;/strong&gt;”。&lt;/p&gt;

&lt;p&gt;现在碰到的是Hello world字符串的字符标记。首先会创建和插入Text节点，其他字符会附加到这个节点上去。&lt;/p&gt;

&lt;p&gt;如果碰到body的关闭标记的话会使模式转入”&lt;strong&gt;after body&lt;/strong&gt;”。然后碰到html关闭标签，模式转换成”&lt;strong&gt;after after body&lt;/strong&gt;“。碰到文件结束标记后，解析结束。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7156/6485575299_706ab0d663.jpg&amp;quot; width=&amp;quot;346&amp;quot; height=&amp;quot;500&amp;quot;&quot; alt=&quot;tree construction&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3.2.8 解析结束后&lt;/h3&gt;

&lt;p&gt;解析结束后会标记文档为interactive，然后开始解析应该在文档解析完成后执行的脚本。这个文档状态会被设置成”complete”，而且”load”事件会被触发。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.2.9 浏览器的容错性&lt;/h3&gt;

&lt;p&gt;你永远不会在HTML页面上得到一个”Invalid Syntax”错误。浏览器会修复任何一个非法的文档，使它能够正常运行。&lt;/p&gt;

&lt;p&gt;拿下面这个例子来说：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;mytag&amp;gt;
  &amp;lt;/mytag&amp;gt;
  &amp;lt;div&amp;gt;
  &amp;lt;p&amp;gt;
  &amp;lt;/div&amp;gt;
    Really lousy HTML
  &amp;lt;/p&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中我犯了许多错误：mytag不是标准标签，p和div元素都嵌套错误。但即使这样，浏览器也能正确执行这段HTML，所以这些错误都被浏览器给纠正了。&lt;/p&gt;

&lt;p&gt;错误处理在各个浏览器中是非常一致的，但是令人惊奇的是这并不是HTML当前规范的一部分。就像书签和前进/后退按钮一样，这是在浏览器多年进化的结果。&lt;/p&gt;

&lt;p&gt;HTML5规范定义了一些上述的需求。Webkit在它的HTML解析类的开头美妙地总结如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The parser parses tokenized input into the document, building up the document tree. If the document is well-formed, parsing it is straightforward.  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unfortunately, we have to handle many HTML documents that are not well-formed, so the parser has to be tolerant about errors.  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;We have to take care of at least the following error conditions:  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;The element being added is explicitly forbidden inside some outer tag. In this case we should close all tags up to the one, which forbids the element, and add it afterwards.&lt;/li&gt;
    &lt;li&gt;We are not allowed to add the element directly. It could be that the person writing the document forgot some tag in between (or that the tag in between is optional). This could be the case with the following tags: HTML HEAD BODY TBODY TR TD LI (did I forget any?).&lt;/li&gt;
    &lt;li&gt;We want to add a block element inside to an inline element. Close all inline elements up to the next higher block element.&lt;/li&gt;
    &lt;li&gt;If this doesn’t help, close elements until we are allowed to add the element or ignore the tag.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;让我们来看一些Webkit的容错例子:&lt;/p&gt;

&lt;h4 id=&quot;brbr&quot;&gt;&amp;lt;/br&amp;gt;代替&amp;lt;br&amp;gt;&lt;/h4&gt;

&lt;p&gt;有些站点使用&amp;lt;/br&amp;gt;代替&amp;lt;br&amp;gt;，为了跟IE和Firefox兼容，Webkit会把&amp;lt;/br&amp;gt;处理成&amp;lt;br&amp;gt;。&lt;/p&gt;

&lt;p&gt;Webkit代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (t-&amp;gt;isCloseTag(brTag) &amp;amp;&amp;amp; m_document-&amp;gt;inCompatMode()) {
     reportError(MalformedBRError);
     t-&amp;gt;beginTag = true;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：错误处理只在内部执行，不会展现给用户。&lt;/p&gt;

&lt;h4 id=&quot;a-stray-table&quot;&gt;A stray table&lt;/h4&gt;

&lt;p&gt;stras table指的是一个table元素里直接里包含了另一个table元素，就像下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;table&amp;gt;
        &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;inner table&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;outer table&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Webkit会改变它的继承结构为两个同级别的table：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;outer table&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;inner table&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;处理这部分的代码为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (m_inStrayTableContent &amp;amp;&amp;amp; localName == tableTag)
        popBlock(tableTag);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Webkit利用栈来保存当前内容，它会弹出内部的table，这样的话这两个table就是同级别的了。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;从元素嵌套&lt;/h4&gt;

&lt;p&gt;为了防止用户把一个form放到另一个form内，内部的form将被丢弃，代码为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!m_currentFormElement) {
        m_currentFormElement = new HTMLFormElement(formTag,    m_document);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;过深的标签嵌套&lt;/h4&gt;

&lt;p&gt;注释说明的非常清楚：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// www.liceo.edu.mx is an example of a site that achieves a level of nesting of about 
// 1500 tags, all from a bunch of &amp;lt;b&amp;gt;s. We will only allow at most 20 nested tags   
// of the same type before just ignoring them all together.
bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp;amp; tagName)
{

unsigned i = 0;
for (HTMLStackElem* curr = m_blockStack;
         i &amp;lt; cMaxRedundantTagDepth &amp;amp;&amp;amp; curr &amp;amp;&amp;amp; curr-&amp;gt;tagName == tagName;
     curr = curr-&amp;gt;next, i++) { }
return i != cMaxRedundantTagDepth;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;htmlbody&quot;&gt;html或者body的关闭标签位置错误&lt;/h4&gt;

&lt;p&gt;同样，注释说明的非常清楚：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Support for really broken html. We never close the body tag, since some stupid web pages 
// close it before the actual end of the doc. Let's rely on th//e end() call to close things.
if (t-&amp;gt;tagName == htmlTag || t-&amp;gt;tagName == bodyTag )
        return;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以web开发人员要注意，除非你想作为Webkit的容错代码片段的例子出现，否则要写格式良好的HTML。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>浏览器是如何工作的(四)</title>
   <link href="/blog/2011/12/10/how-browsers-work-four/"/>
   <updated>2011-12-10T14:18:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/10/how-browsers-work-four</id>
   <content type="html">&lt;h2 id=&quot;html&quot;&gt;3.2 HTML解析器&lt;/h2&gt;

&lt;p&gt;HTML解析器的工作是把HTML标记语言解析成为解析树。&lt;/p&gt;

&lt;h3 id=&quot;html-1&quot;&gt;3.2.1 HTML语法定义&lt;/h3&gt;

&lt;p&gt;HTML的词汇和语法是由W3C组织制定的。当前的版本是HTML4，HTML5还在制定当中。&lt;/p&gt;

&lt;h3 id=&quot;html-2&quot;&gt;3.2.2 不是内容无关语法的HTML&lt;/h3&gt;

&lt;p&gt;我们在介绍解析的时候知道了，语法可以被定义为正式使用的格式，比如BNF。&lt;/p&gt;

&lt;p&gt;不过不幸的是，所有约定的解析器都不适用于HTML。HTML不能简单的定义一个解析器需要的内容无关语法。&lt;/p&gt;

&lt;p&gt;有一个定义HTML的正式格式 - DTD，但它也不是内容无关语法。&lt;/p&gt;

&lt;p&gt;所以第一眼看上去就很奇怪，HTML更接近于XML。而XML的解析器却有很多，而且有一个HTML的XML版本 - XHTML，那么有什么不同呢？&lt;/p&gt;

&lt;p&gt;不同之处在于，HTML的方式更加宽松，它允许你省略特定的标签，然后会隐式的为你加上去。总的来看，相对于XML来说，HTML是“软”语法。&lt;/p&gt;

&lt;p&gt;显然，这个细小的差别让两者大不一样。一方面这是HTML流行的主要原因 - 允许你犯错，而且对于开发人员来说非常容易。另一方面，它有使的写一个正式语法变得非常困难。所以总结来看 - HTML不能被简单的解析，不能被约定的解析器解析，因为它不是内容无关语法，也不能被XML解析器解析。&lt;/p&gt;

&lt;h3 id=&quot;html-dtd&quot;&gt;3.2.3 HTML DTD&lt;/h3&gt;

&lt;p&gt;HTML的定义是一个DTD的格式。这个格式被用来定义&lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language&quot; title=&quot;SGML&quot;&gt;SGML&lt;/a&gt;家族语言。它包含了对所以允许元素的定义，他们的属性和继承关系。我们已经知道，HTML DTD不能形成一个内容无关语法。&lt;/p&gt;

&lt;p&gt;还有一些类型的DTD。像严格的类型会紧密遵守规范，但其他类型包含对以前浏览器使用的标签的支持，这个目的就是向后兼容旧内容。当前的严格版DTD在&lt;a href=&quot;http://www.w3.org/TR/html4/strict.dtd&quot; title=&quot;strict dtd&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;dom&quot;&gt;3.2.4 DOM&lt;/h3&gt;

&lt;p&gt;输出树(也就是解析树)，它包含了DOM元素和属性节点。像JavaScript一样，它是HTML文档和元素借口对外界的对象表示。&lt;/p&gt;

&lt;p&gt;这棵树的根节点是&lt;a href=&quot;http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document&quot; title=&quot;Document&quot;&gt;Document&lt;/a&gt;对象。&lt;/p&gt;

&lt;p&gt;DOM是大多数情况下是一对一关系的标记。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;
      Hello World
    &amp;lt;/p&amp;gt;
    &amp;lt;div&amp;gt; &amp;lt;img src=&amp;quot;example.png&amp;quot;/&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会被解析成下面这棵树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7155/6485284597_9b1d73e56d.jpg&amp;quot; width=&amp;quot;400&amp;quot; height=&amp;quot;219&amp;quot;&quot; alt=&quot;dom tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;像HTML一样，DOM是由W3C组织定义的，参考&lt;a href=&quot;http://www.w3.org/DOM/DOMTR&quot; title=&quot;DOM&quot;&gt;这里&lt;/a&gt;。这是一个处理文档的通用的规范。特殊的模块解释特殊的HTML元素。HTML的定义可以参考&lt;a href=&quot;http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html&quot; title=&quot;html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我所说的解析树包含DOM节点的意思是，这棵树是由实现某个DOM接口的元素组成的，而浏览器在内部有包含其他属性的具体实现。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;3.2.5 解析算法&lt;/h3&gt;

&lt;p&gt;在上一节里我们看到，HTML不能被自上而下或者自下而上的解析器解析。其中的原因是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTML的容错特性&lt;/li&gt;
  &lt;li&gt;浏览器有传统的错误来支持为人熟知的非法HTML&lt;/li&gt;
  &lt;li&gt;解析过程是重复进出的，一般情况下源代码不会改变，但是在HTML中，包含document.write 的标签会另外加入标记，所以解析过程实际上会改变输入。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为不能使用一般的解析技术，所以浏览器就为HTML开发了专用的解析器。&lt;/p&gt;

&lt;p&gt;解析算法详细的定义在&lt;a href=&quot;http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html&quot;&gt;HTML5规范&lt;/a&gt;里，算法是由二阶段标记和构建树组成。标记是在词法分析阶段处理，把输入解析成标记。HTML标记有开始标签，结束标签，属性名和属性值。&lt;/p&gt;

&lt;p&gt;标记器可以识别标记，并且把他们传给树构造器，然后再处理下一个标记直到输入结束。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7150/6485330329_01565f62ab.jpg&amp;quot; width=&amp;quot;308&amp;quot; height=&amp;quot;400&amp;quot;&quot; alt=&quot;parsing flow&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>浏览器是如何工作的(三)</title>
   <link href="/blog/2011/12/09/how-browsers-work-three/"/>
   <updated>2011-12-09T23:54:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/09/how-browsers-work-three</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;3.1 解析&lt;/h2&gt;

&lt;p&gt;从渲染引擎解析开始是非常重要的阶段，我们会对它作更深入的研究。首先还是简略的介绍一下什么是解析。&lt;/p&gt;

&lt;p&gt;解析一个文档(document)的含义是：把这个文档转换成一些有意义的结构或可以被理解和使用的代码。解析的结果通常是一棵，它的节点代表文档的结构。这棵树被称为解析树或语法树。&lt;/p&gt;

&lt;p&gt;实例 - 2 + 3 - 1 这个表达式的解析结果会返回下面的树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7158/6481798259_420d333218.jpg&amp;quot; width=&amp;quot;400&amp;quot; height=&amp;quot;155&amp;quot;&quot; alt=&quot;paring tree&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;3.1.1 语法&lt;/h3&gt;

&lt;p&gt;解析是建立在文档遵守的语法规(语言和格式)则上的。每个可以被解析的格式必须有词汇和语法规则。这被称为与内容无关的语法。人类语言不是这种语言，因此不能被约定的解析技术而解析。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3.1.2 解析器&lt;/h3&gt;

&lt;p&gt;整个解析过程可以被分成两个子过程 - 词法分析和语法分析&lt;/p&gt;

&lt;p&gt;词法分析是把输入分解成标记(token)的过程。标记是语言的词汇，在人类语言中，它是由字典里的所有单词组成的。&lt;/p&gt;

&lt;p&gt;语法分析就是应用语言的语法规则。&lt;/p&gt;

&lt;p&gt;分析器一般由它的两个组件承担不同的工作。一个是lexer(有时也会被称为tokenizer)，它主要是把输入分解成合法的标记。另一个是parser，它主要是根据语言的语法规则，分析文档构建解析树。lexer知道怎么消除不相关的字符，像空格符和还行符。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7011/6481889667_2fe7dd07cb.jpg&amp;quot; width=&amp;quot;101&amp;quot; height=&amp;quot;300&amp;quot;&quot; alt=&quot;paring tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解析的过程是迭代式的。parser一般会向lexer请求一个新的标记，然后尝试用语法规则来匹配这个标记。如果匹配一个规则，跟这个标记对应的节点会被加入到解析树，然后请求另一个标记。&lt;/p&gt;

&lt;p&gt;如果没有规则匹配，parser会把标记保存在内部，直到所有与保存在内部的标记相匹配的规则被找到之前，它会一直请求新的标记。如果没有找到相应的规则，parser会抛出一个异常。这意味着这个文档是不合法的，并且有语法错误。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.1.3 翻译&lt;/h3&gt;

&lt;p&gt;大多数情况下，解析树不是最终的成品。解析在翻译中经常被用到，把输入文档转换成另一种格式。一个例子就是编译。编译器是把源代码编译成为机器代码，首先解析为解析树，然后把解析树翻译成为机器代码稳定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7026/6481955767_7abc1f157b.jpg&amp;quot; width=&amp;quot;104&amp;quot; height=&amp;quot;400&amp;quot;&quot; alt=&quot;compilation flow&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;3.1.4 解析实例&lt;/h3&gt;

&lt;p&gt;让我们试着定义一个简单的数学语言，然后分析表达式&lt;code&gt;2 + 3 - 1&lt;/code&gt;解析结果。&lt;/p&gt;

&lt;p&gt;词汇：可以有整数，加号和减号。&lt;/p&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;代码块是表达式，数据项和操作符。&lt;/li&gt;
  &lt;li&gt;可以包括任何数字的表达式。&lt;/li&gt;
  &lt;li&gt;一个表达式是被定义为两个数据项之间有一个操作符。&lt;/li&gt;
  &lt;li&gt;操作符是加号或减号的其中之一。&lt;/li&gt;
  &lt;li&gt;数据项是一个整数或表达式。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在来分析输入：2 + 3 - 1&lt;/p&gt;

&lt;p&gt;第一次匹配规则的是&lt;strong&gt;2&lt;/strong&gt;，然后根据规则#5，它是一个数据项。第二次匹配的是2 + 3，根据规则#3。下一次匹配就是整个表达式。2 + 3 - 1 之所以是一个表达式是因为我们已经知道，2 + 3 是一个数据项，而且它后面跟着操作符，操作符后面跟着数据项。2 + + 不会匹配任何规则，因此这是个非法的输入。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;3.1.5 词汇和语法的正式定义&lt;/h3&gt;

&lt;p&gt;词汇一般用正则表达式来表示。比如，我们上面的例子可以被定义成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INTEGER :0|[1-9][0-9]*
PLUS : +
MINUS: -&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;语法一般会被定义成一种叫做&lt;strong&gt;BNF&lt;/strong&gt;的格式，我们的语言会被定义成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expression :=  term  operation  term
operation :=  PLUS | MINUS
term := INTEGER | expression&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道一个语言如果是内容无关的语言，那么这个语言是可以被一般解析器解析的。内容无关语法的粗略定义是它可以用BNF表示。正式的定义可以参考&lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot; title=&quot;Wikipedia's article on Context-free grammar&quot;&gt;Wikipedia’s article on Context-free grammar&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;3.1.6 解释器的种类&lt;/h3&gt;

&lt;p&gt;解释器有两种：&lt;strong&gt;自上而下&lt;/strong&gt;和&lt;strong&gt;自下而上&lt;/strong&gt;的解析器。一个简单的解释是：自上而下的解析器在更高层次上关注语法，然后尝试匹配他们。自下而上的解析器是从输入开始，渐进的把他们转换进入语法规则，从低级规则到高级规则变化。&lt;/p&gt;

&lt;p&gt;让我们来看一下两种类型的解析器是如何解析我们的例子的：&lt;/p&gt;

&lt;p&gt;自上而下的解析器从更高层次的规则开始：它会先确定&lt;code&gt;2 + 3&lt;/code&gt;是一个表达式，然后再确定&lt;code&gt;2 + 3 + 1&lt;/code&gt;是一个表达式(确定表达式的过程涉及其他的规则匹配，但是起点是最高层次的规则)。&lt;/p&gt;

&lt;p&gt;而自下而上的表达式会扫描输入，直到有一个规则匹配。然后把匹配的输入换成规则，这个过程会持续到输入的结尾。部分匹配的表达式会被放在解析栈中。&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
  &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Stack&lt;/th&gt;                &lt;th&gt;Input&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&lt;samp&gt;2 + 3 - 1&lt;/samp&gt;&lt;/td&gt;&lt;/tr&gt;  
  &lt;tr&gt;&lt;td&gt;term&lt;/td&gt;&lt;td&gt;&lt;samp&gt;+ 3 - 1&lt;/samp&gt;&lt;/td&gt;&lt;/tr&gt; 
  &lt;tr&gt;&lt;td&gt;term operation&lt;/td&gt;&lt;td&gt;&lt;samp&gt;3 - 1&lt;/samp&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;expression&lt;/td&gt;&lt;td&gt;&lt;samp&gt;- 1&lt;/samp&gt;&lt;/td&gt;&lt;/tr&gt; 
  &lt;tr&gt;&lt;td&gt;expression operation&lt;/td&gt;&lt;td&gt;&lt;samp&gt;1         &lt;/samp&gt;&lt;/td&gt;&lt;/tr&gt; 
  &lt;tr&gt;&lt;td&gt;expression&lt;/td&gt;           &lt;td&gt;&lt;samp&gt;&amp;nbsp;&lt;/samp&gt;&lt;/td&gt;&lt;/tr&gt;                                             
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;这种类型的自下而上的解析器被称为移位消除解析器(shift-reduce parser)，因为输入被移到了右边(想象有个指针指向输入头，然后往右边移动)，并且根据规则递减。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;3.1.7 自动生成解析器&lt;/h3&gt;

&lt;p&gt;有很多工具可以为你生成解析器。他们被称为解析器生成器。你把语言的语法输入其中，他们就会自动生成解析器。创建一个解析器需要对解析有很深的理解，并且手工创建一个优化过的解析器是比较困难的。&lt;/p&gt;

&lt;p&gt;Webkit使用的是两个有名的解析器生成器：&lt;a href=&quot;http://en.wikipedia.org/wiki/Flex_lexical_analyser&quot; title=&quot;Flex&quot;&gt;Flex&lt;/a&gt;用来生成词法分析器，&lt;a href=&quot;http://www.gnu.org/software/bison/&quot; title=&quot;Bison&quot;&gt;Bison&lt;/a&gt;用来生成语法分析器。Flex的输入是一个包含正则表达式定义的标记的文件；Bison的输入是BNF格式的语法规则。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>浏览器是如何工作的(二)</title>
   <link href="/blog/2011/12/07/how-browsers-work-two/"/>
   <updated>2011-12-07T22:18:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/07/how-browsers-work-two</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;2 渲染引擎&lt;/h2&gt;

&lt;p&gt;渲染引擎要做的就是渲染，也就是在浏览器的窗体里显示请求的内容。&lt;/p&gt;

&lt;p&gt;一般情况下，渲染引擎可以显示HTML,XML和图片。它也可以通过插件的方式显示其他类型类型的文件，比如PDF。但是，在这章中我们将把焦点放在主要的用例上：显示由CSS格式化过的HTML和图片。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.1 多种渲染引擎&lt;/h3&gt;

&lt;p&gt;我们作为参考的浏览器：Firefox, Chrome和Safari是构建在不同的两个渲染引擎之上的。Firefox使用的是Gecko，而Chrome和Safari使用的都是Webkit。&lt;/p&gt;

&lt;p&gt;Webkit是开源的渲染引擎，它开始时只是针对Linux平台，后来由苹果公司修改后以兼容Mac和Windows平台。&lt;a href=&quot;http://webkit.org&quot; title=&quot;webkit.org&quot;&gt;webkit.org&lt;/a&gt;上有更详细的介绍。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.2 渲染的主要流程&lt;/h3&gt;

&lt;p&gt;渲染引擎是从网络层中获取请求的内容。然后是渲染的基本流程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7012/6465898245_abf04a9566.jpg&amp;quot; width=&amp;quot;500&amp;quot; height=&amp;quot;55&amp;quot;&quot; alt=&quot;flow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;渲染引擎会开始解析HTML文档，并且把HTML标签转换成为被称作“内容树(content tree)”的DOM节点。还会解析不管是外部引用的还是内联的CSS。样式和可视指令(visual instructions)一起会被创建成为另一棵树-渲染树(render tree)。&lt;/p&gt;

&lt;p&gt;在渲染树构造完毕后，浏览器就会开始处理布局。也就是说会分配给每个节点一个屏幕上准确位置的坐标。下一步就是绘制了，即使用UI后端(UI backend)来绘制渲染树每个节点。&lt;/p&gt;

&lt;p&gt;理解这是个渐进的过程是非常重要的。为了更好的用户体验，渲染引擎会尽可能快的把内容显示在屏幕上。直到所有的HTML已经解析完毕，并且开始构造和布局渲染树之前，渲染引擎是不会停下等待的。部分的内容会被解析和显示，而在这个时候渲染引擎会继续处理从网络上返回的内容。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2.3 主要流程实例&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7151/6465898595_b573cc3861.jpg&amp;quot; width=&amp;quot;500&amp;quot; height=&amp;quot;232&amp;quot;&quot; alt=&quot;webkitflow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7018/6465898835_b5e5658f50.jpg&amp;quot; width=&amp;quot;500&amp;quot; height=&amp;quot;232&amp;quot;&quot; alt=&quot;geckoflow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上两张图山可以看到，尽管Webkit和Gecko使用不同的术语，但是整个流程是基本一样的。&lt;/p&gt;

&lt;p&gt;在Gecko里，把已经经过视觉格式化过的元素树称为框架树(frame tree)。每个元素是一个框架。Webkit则用了另外一个术语：由渲染对象(render object)组成的渲染树(render tree)。&lt;/p&gt;

&lt;p&gt;Webkit把元素的放置称为布局(layout)，而Gecko则称之为回流(reflow)。附件(attachment)是Webkit用来表示连接DOM节点和视觉信息来创建渲染树的过程。一个细小的，非语意上的区别是，Gecko在HTML和DOM之间又另外多出来一层。它被称为内容下沉层(content sink)，并且它是制造DOM元素的工厂。下面将会说明整个流程的各个部分。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>浏览器是如何工作的(一)</title>
   <link href="/blog/2011/12/05/how-browsers-work-one/"/>
   <updated>2011-12-05T23:03:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/05/how-browsers-work-one</id>
   <content type="html">&lt;p&gt;浏览器可能是目前使用的人最多的软件，对于软件开发人员来说更是如此。我对浏览器的认识差不多是这样的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发送请求到服务器(get/post)&lt;/li&gt;
  &lt;li&gt;解析从服务器返回的response(HTML,CSS)&lt;/li&gt;
  &lt;li&gt;执行JavaScript代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本上就是上面这些，但是至于细节就不了解了。直到我看到了这篇长长的文章：&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/&quot; title=&quot;How Browsers Work:Behind the Scenes of Modern Web Browsers&quot;&gt;How Browsers Work:Behind the Scenes of Modern Web Browsers&lt;/a&gt;,才第一次窥探到了浏览器的处理细节。这个主题一共分成了10章来讲，对于学习和参考浏览器的工作原理都非常有用。所以，我就决定把它翻译成中文，供以后参考用。值得一提的是，这篇文章的作者是一个有着10年以上经验的女程序员，让我们像她致敬！&lt;/p&gt;

&lt;p&gt;由于原文较长，所以我也会分成几篇博客来翻，而这篇博客是这个系列的第一篇翻译。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1 引子&lt;/h2&gt;

&lt;p&gt;浏览器可能是目前使用最广的软件。在这个系列的文章中，我将解释浏览器是如何工作的。我们将会看到在浏览器的地址栏中敲入google.com到你看到google的页面这段时间内到底发生了什么。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.1 我们将会讨论的浏览器&lt;/h3&gt;

&lt;p&gt;现在有5个主流的浏览器，他们是：IE,Firefox,Safari, Chrome和Opera。我会从开源浏览器Firefox,Chrome以及部分开源的Safari中举例。根据&lt;a href=&quot;http://gs.statcounter.com/&quot; title=&quot;StatCounter browser statistics&quot;&gt;StatCounter browser statistics&lt;/a&gt;上的统计，到2011年8月为止，Firefox,Chrome和Safari三者加起来的占有率已经到达将近60%。所以开源浏览器是浏览器领域的重要组成部分。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.2 浏览器的主要功能&lt;/h3&gt;

&lt;p&gt;浏览器的主要功能是展现用户选择的网络资源，这是通过发送请求给服务器并且在浏览器中显示返回结果。而这个网络资源一般是一个HTML文档，但也有可能是PDF，图片或者其他类型的资源。资源的地址是通过URI来描述的。&lt;/p&gt;

&lt;p&gt;浏览器解释和显示HTML文件的方式是在HTML和CSS规范里面规定的。这些规范是由&lt;a href=&quot;http://www.w3.org/&quot; title=&quot;W3C&quot;&gt;W3C&lt;/a&gt;维护的。&lt;/p&gt;

&lt;p&gt;多年以来，那些浏览器只遵守了一部分的规范，并且开发他们自己的扩展。但是这就给开发人员带来了严重的兼容性问题。目前大多数浏览器或多或少遵守着规范。&lt;/p&gt;

&lt;p&gt;浏览器的用户接口基本上差不多，他们有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;地址栏&lt;/li&gt;
  &lt;li&gt;后退和前进按钮&lt;/li&gt;
  &lt;li&gt;书签选项&lt;/li&gt;
  &lt;li&gt;刷新和停止按钮&lt;/li&gt;
  &lt;li&gt;主页按钮&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;奇怪的是，浏览器的用户接口并有在任何正式的规范里规定过，而是来自于多年经验形成的最佳实践，还有浏览器之间的相互模仿。HTML5规范并没有规定浏览器必须具有的UI元素，但是它列出了一些共有的元素。在他们之中有地址栏，状态栏和工具栏。当然，浏览器也可以有自己独特的特性，比如Firefox的Download Manager。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.3 浏览器的结构概览&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;用户接口 - 前面已经提到过&lt;/li&gt;
  &lt;li&gt;浏览器引擎 - 处理UI和渲染引擎之间的行为&lt;/li&gt;
  &lt;li&gt;渲染引擎 - 负责显示请求的内容。比如解析HTML和CSS后显示出来。&lt;/li&gt;
  &lt;li&gt;网络 - 用来网络调用，比如HTTP请求。它是不依赖于平台并且实现隐藏于平台之下。&lt;/li&gt;
  &lt;li&gt;UI后端 - 用来画基本的组合框和窗口。它暴露一个不依赖平台的通用接口，在它之下使用的是操作系统的用户接口方法。&lt;/li&gt;
  &lt;li&gt;JavaScript解释器 - 解析和执行JavaScript代码&lt;/li&gt;
  &lt;li&gt;数据存储 - 这是一个持久层，浏览器需要保存所有类型的数据到硬盘上，比如cookie。而HTML5规定了浏览器的数据库web database。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://farm8.staticflickr.com/7172/6459942245_401c8ce2ac.jpg&amp;quot;&quot; alt=&quot;layers&quot; title=&quot;layers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，Chrome跟大多数浏览器不一样的是，它会有多个渲染引擎的实例，每个标签页都有一个渲染引擎，每个标签页是个独立的进程。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>JIT到底做了些什么事</title>
   <link href="/blog/2011/12/03/what-does-jit-do-in-hotspot/"/>
   <updated>2011-12-03T15:15:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/12/03/what-does-jit-do-in-hotspot</id>
   <content type="html">&lt;p&gt;最近在网上看到一篇关JIT(Just in Time)的文章&lt;a href=&quot;http://java.dzone.com/articles/just-time-compiler-jit-hotspot?utm_source=feedburner&amp;amp;utm_medium=feed&amp;amp;utm_campaign=Feed%3A+javalobby%2Ffrontpage+%28Javalobby+%2F+Java+Zone%29&amp;amp;utm_content=Google+Reader&quot; title=&quot;Just in Time Compiler (JIT) in Hotspot&quot;&gt;Just in Time Compiler (JIT) in Hotspot&lt;/a&gt;,这篇文章很短，但是对JIT的作用基本上说的比较清楚的，可以作为JIT的学习参考，所以我就决定把这篇文章翻译成中文，供以后复习参考用。&lt;/p&gt;

&lt;p&gt;================正文开始==================&lt;/p&gt;

&lt;h2 id=&quot;jit&quot;&gt;什么是JIT编译器&lt;/h2&gt;

&lt;p&gt;JIT和更普便的自适应优化概念是在包括Java在内的许多编程语言，例如.Net, Lua, JRuby中所为人熟知的概念。&lt;/p&gt;

&lt;p&gt;为了解释什么是JIT编译器，我想从编译器的定义开始。根据维基百科上对于编译器的定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个计算机程序是把源程序语言转换成目标语言。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们对静态Java编译器(javac)都很熟悉，它的作用是将人类能够阅读的.java文件编译成为能够被JVM解释的.class文件。现在问题来了，那么JIT用来编译什么东西呢？答案将在解释完什么是Just in Time后给出。&lt;/p&gt;

&lt;p&gt;根据许多研究得出的结果，20%的代码的执行时间要占到全部时间的80%。如果这时候有一种方法决定那些20%的代码并且优化他们，那将是令人兴奋的事。这就是JIT做的事： 在运行时收集统计数据，找出那些经常执行的代码，把他们从字节码转换成操作系统能够直接执行的本地代码，并且重度优化他们。最小的编译单元是单个方法。编译和统计数据收集是靠特殊线程并行处理的。在统计数据收集期间，编译器会推测代码功能，并且通过时间的推移来验证这个推测。如果这个推测是错误的话，优化过的代码会被还原并且重新编译。&lt;/p&gt;

&lt;p&gt;Hotspot JVM这个名字的由来就是因为这个JVM的作用就是找到代码中的“hot spot(热点)”。&lt;/p&gt;

&lt;h2 id=&quot;jit-1&quot;&gt;JIT会做哪些优化？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;内敛方法 - 方法不是直接在对象的实例上调用，而是拷贝到调用代码里去。为了防止产生任何开销，热门方法应该尽可能靠近调用着&lt;/li&gt;
  &lt;li&gt;如果监视器从别的线程是不可到达的，那就消除锁&lt;/li&gt;
  &lt;li&gt;用直接的方法调用代替接口以消除调用虚函数的开销&lt;/li&gt;
  &lt;li&gt;合并临近的在同一对象上的锁&lt;/li&gt;
  &lt;li&gt;消除不会被执行的代码(dead code)&lt;/li&gt;
  &lt;li&gt;对非volatile变量，忽略内存写&lt;/li&gt;
  &lt;li&gt;删除预先检查的NullPointerException和IndexOutOfBoundsException&lt;/li&gt;
  &lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当JVM调用一个Java方法，它会使用在已经加载类的方法块中的定义的调用方法。虚拟机有好几个调用方法，比如，如果方法是同步的，或者是本地方法的话，不同的调用者会被使用。JIT编译器使用的是它自己的调用者。虚拟机会检查ACC_MACHINE_COMPILED这个值，来通知解释器这个值对应的方法已经编译并且保持在已加载的类中。JIT编译器把方法块编译成本地代码，并且把它保存在那个方法的代码块中。一旦ACC_MACHINE_COMPILED位被设置，那么这个代码就被编译完成了。那我们怎么知道JIT在我们的程序中正在做什么，怎么样才能控制它？&lt;/p&gt;

&lt;p&gt;首先就是取消JIT的功能：Djava.compiler=NONE&lt;/p&gt;

&lt;p&gt;Hotspot中有2种JIT编译器，一种是为客户端程序使用，另一种是服务器端程序。运行在服务器上的程序通常来说需要更多的资源，并且程序的吞吐量是非常重要的。因此，服务器版的JIT会消耗更多的资源，并且为了统计数据的准确，要花更多的时间来收集统计数据。而客户端版的JIT为一个方法收集统计数据会持续1500次方法调用，服务器版JIT则是15000次。这些默认值可以通过JVM参数:-XX:CompileThreshold=XXX来修改。&lt;/p&gt;

&lt;h2 id=&quot;jit-2&quot;&gt;JIT的不足&lt;/h2&gt;

&lt;p&gt;JIT增加了Java程序的不可预测性和复杂性。它增加了一层程序员不是正真理解的另外一层。&lt;/p&gt;

&lt;p&gt;一个可能bug的例子： 并发中的”happens before relations”。JIT会简单的记录在单线程中代码的改变是否安全。解决这个问题的方法是加上&lt;strong&gt;synchronized&lt;/strong&gt;或着显式的加锁。&lt;/p&gt;

&lt;h2 id=&quot;jit-3&quot;&gt;JIT的优势&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;对于GC来说，程序必须到达安全点。为了这个目的，JIT通过在本地代码的相同间隔内注入&lt;strong&gt;yieldpoints&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;除了扫描堆栈来找出根引用，寄存器也必须被扫描，因为他们可能会持有JIT创建的对象。&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>我的Macbook Pro之旅正式开始了</title>
   <link href="/blog/2011/11/17/my-macbook-life-starts/"/>
   <updated>2011-11-17T23:36:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/11/17/my-macbook-life-starts</id>
   <content type="html">&lt;p&gt;最近一直感觉现在用的笔记本有点慢，特别是打开eclipse的话要等上最起码半分钟时间，这对于我来说是不能忍受的。所以我决定鸟枪换炮，把从大学时期开始就陪伴着我到现在的IBM R60给我爸用，我自己就再去买台笔记本电脑。&lt;/p&gt;

&lt;p&gt;目标其实早就决定了，在今年年初定的&lt;a href=&quot;http://liuxuan.info/blog/2011/01/01/plans-for-2011&quot; title=&quot;2011年的计划&quot;&gt;2011年的计划&lt;/a&gt;里我就希望今年能够买个苹果笔记本，终于快到了年末的时候实现了。这次我买的是13寸版的MBP MD313，这个是刚刚上市不久的型号，较年初的版本有了一点的升级，比如CPU主频提高了，硬盘加多了等，总之是一款非常适合入手的笔记本电脑。&lt;/p&gt;

&lt;p&gt;由于之前一直在用Linux，所以过度到Mac OS完全没有问题。然后就是要安装各种软件了，这是比较蛋疼的事，Mac上有很多非常优秀的软件都是要收费的，而且有的还是每次升级版本都要付钱。。。好吧，所以我决定相同类型的软件尽量找免费的，免费的也有宝啊！&lt;/p&gt;

&lt;p&gt;下面是我目前安装的软件列表：&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;非编程类&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Chrome - 唯一使用的浏览器&lt;/li&gt;
  &lt;li&gt;Sunpinyin - 中文输入法&lt;/li&gt;
  &lt;li&gt;Parallels Desktop - 虚拟机&lt;/li&gt;
  &lt;li&gt;AppCleaner - 软件清理&lt;/li&gt;
  &lt;li&gt;Thunder - 迅雷&lt;/li&gt;
  &lt;li&gt;iChm - chm文件阅读&lt;/li&gt;
  &lt;li&gt;Secret Socks - SSH工具&lt;/li&gt;
  &lt;li&gt;iTerm2 - 控制台工具&lt;/li&gt;
  &lt;li&gt;AppFresh - 软件更新&lt;/li&gt;
  &lt;li&gt;Cyberduck - FTP工具&lt;/li&gt;
  &lt;li&gt;AliWangwang - 旺旺&lt;/li&gt;
  &lt;li&gt;Caffeine - 屏保停止&lt;/li&gt;
  &lt;li&gt;ClipMenu - 剪贴板增强&lt;/li&gt;
  &lt;li&gt;Growl - 系统提示&lt;/li&gt;
  &lt;li&gt;invisibliX - 隐藏文件浏览&lt;/li&gt;
  &lt;li&gt;Mou - markdown文件编辑&lt;/li&gt;
  &lt;li&gt;MPlayerX - 视频播放&lt;/li&gt;
  &lt;li&gt;
    &lt;s&gt;OnyX - 系统清理&lt;/s&gt;
  &lt;/li&gt;
  &lt;li&gt;QQ - 不解释&lt;/li&gt;
  &lt;li&gt;Paragon NTFS for Mac OS X - 读写NTFS文件&lt;/li&gt;
  &lt;li&gt;TestWrangler - 文件编辑&lt;/li&gt;
  &lt;li&gt;The Unarchiver - 解压缩工具&lt;/li&gt;
  &lt;li&gt;
    &lt;s&gt;Twitter - 不解释&lt;/s&gt;
  &lt;/li&gt;
  &lt;li&gt;Micosoft Office - 不解释&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;编程类&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Homebrew - 类似于Linux下的apt和yum&lt;/li&gt;
  &lt;li&gt;eclipse - 不解释&lt;/li&gt;
  &lt;li&gt;MacVim - 神器&lt;/li&gt;
  &lt;li&gt;MySQL - 数据库&lt;/li&gt;
  &lt;li&gt;
    &lt;s&gt;Sequel Pro - MySQL的GUI客户端&lt;/s&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;s&gt;GitHub - 不解释&lt;/s&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;s&gt;GitX - git的GUI客户端&lt;/s&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2012.6.19 更新&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Alfred - 快速启动软件&lt;/li&gt;
  &lt;li&gt;CCleaner - 系统清理&lt;/li&gt;
  &lt;li&gt;Echofon - Twitter客户端&lt;/li&gt;
  &lt;li&gt;Google Drive&lt;/li&gt;
  &lt;li&gt;Reeder - RSS阅读器&lt;/li&gt;
  &lt;li&gt;Skim - PDF阅读器&lt;/li&gt;
  &lt;li&gt;SourceTree - git的GUI客户端&lt;/li&gt;
  &lt;li&gt;Temperature Monitor - 显示温度&lt;/li&gt;
  &lt;li&gt;TotalFinder - Finder增强&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2012.12.22 更新&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;cloud - 云分享&lt;/li&gt;
  &lt;li&gt;colloquy - IRC客户端&lt;/li&gt;
  &lt;li&gt;CoRD - 远程控制&lt;/li&gt;
  &lt;li&gt;Dash - 编程语言文档&lt;/li&gt;
  &lt;li&gt;Dropbox - 云备份&lt;/li&gt;
  &lt;li&gt;Entropy - 解压缩&lt;/li&gt;
  &lt;li&gt;Evernote - 云笔记&lt;/li&gt;
  &lt;li&gt;iStats Menus - 系统监控&lt;/li&gt;
  &lt;li&gt;Sublime Text 2 - 编程工具&lt;/li&gt;
  &lt;li&gt;Tweetbot - twitter客户端&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>读《浪潮之巅》有感</title>
   <link href="/blog/2011/11/10/lang-chao-zhi-dian-note/"/>
   <updated>2011-11-10T22:43:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/11/10/lang-chao-zhi-dian-note</id>
   <content type="html">&lt;p&gt;最近终于把《浪潮之巅》看完了，当最后一页合上之后我感慨万千，就像穿过了时空隧道一样经历了那些在IT界非常有名的大公司从创立到达到顶峰，潮起和潮落，成长和落败。这是一本IT界的历史书，它几乎囊括了整个IT界的发展史，但是要把它写的简单易读是非常不容易的，但是这位作者做到了，即使不是计算机专业的人也能很容易的读懂。&lt;/p&gt;

&lt;p&gt;读完整本书后，最令我感到唏嘘的就是Sun公司。当初Sun公司的James Gosling发明了Java，以其跨平台特性风靡全球，至今还在编程语言榜上排名第一，而我现在还在靠Java吃饭，但是不幸的是Sun公司已经被Oracle收购，不再作为一个独立的公司存在了。太多的实例告诉我们，一个公司光有技术还不行，要在这个竞争激烈的世界生存下去必须要有一个卓越的领导者带领着这个公司不断前进。而Sun公司就缺这么一个领导者，这不得不说是种遗憾。&lt;/p&gt;

&lt;p&gt;Google是我一直非常喜欢的公司，而作者用了很长的篇幅介绍了Google这家公司，正好让我更全面地了解了这家公司。但是现在的Google给人有点微软的感觉，而Facebook给人的感觉就是以前的Google。作者也说了，明年Facebook就会上市，这件事也许也会是2012年IT界最令人激动振奋的一件事，那就让我一起等待2012年4月28日这天的到来吧。&lt;/p&gt;

&lt;p&gt;唯一感到有点遗憾的是作者只用了很少的篇幅来讲述twitter这家公司，而twitter又是我非常喜欢的应用，虽然在中国因为众所周知的原因无法使用twitter，但这并不会阻止我对它的向往。twitter已经是我获取信息的重要来源，甚至已经超过了电视和门户网站，我现在还把上twitter衡量为一种价值观取向。&lt;/p&gt;

&lt;p&gt;世界在不断的发展，还会有更多的公司脱颖而出，谁会是下一个Google和Facebook呢，让我们拭目以待吧。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>告别Wordpress，拥抱Octopress</title>
   <link href="/blog/2011/11/08/switching-from-wordpress-to-octopress/"/>
   <updated>2011-11-08T22:49:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/11/08/switching-from-wordpress-to-octopress</id>
   <content type="html">&lt;p&gt;至今为止我开博有差不多1年多时间了，期间一直是用Wordpress搭建的博客系统。Wordpress虽然是目前最流行的博客系统，但是如果要在自己的VPS上搭建Wordpress环境还是有一定难度的(我当初搭建的时候就花了蛮长的时间，搭建完了还要优化)。当然最主要的还是用下来有许多的不方便的地方：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为不懂PHP，所以修改功能起来比较麻烦&lt;/li&gt;
  &lt;li&gt;对“&amp;lt;”等特殊符号需要手动转义&lt;/li&gt;
  &lt;li&gt;需要安装很多插件才能满足需要&lt;/li&gt;
  &lt;li&gt;Nginx+PHP+mySql的组合在小内存的VPS上内存占用率过高(在我256MB内存的VPS上达到了30%)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直到上个星期在Google Reader上看到有人提到[Octopress]{http://octopress.org/ “Octopress”}这个用Ruby写的博客系统后，就一下子被它的简单轻量所吸引(只要一个Web服务器就行了，不需要mySql)，最终要的是我会Ruby，所以我毫不犹豫的决定从Wordpress转向Octopress。而且在Octopress的主页上还写着这样一句话：A blogging framework for hackers.那就更没有不玩的理由了。&lt;/p&gt;

&lt;p&gt;整个安装过程还是比较简单的，不过在安装之前要先把之前的博客导出来(不管是从后台还是数据库导)，然后就可以按照&lt;a href=&quot;http://octopress.org/docs/setup/&quot; title=&quot;Octopress Setup&quot;&gt;Octopress Setup&lt;/a&gt;来安装了。注意，如果没有装过Ruby的话，那么在安装完&lt;a href=&quot;http://beginrescueend.com/&quot; title=&quot;RVM&quot;&gt;RVM&lt;/a&gt;后需要安装Ruby的依赖库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install -y gcc-c++ patch readline readline-devel zlib zlib-devel libyaml-devel libffi-devel openssl-devel make bzip2 autoconf automake libtool bison iconv-devel&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;git的话只需要运行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install git-core&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的VPS的操作系统是CentOS 6，并且我把预装的Apache给卸载了，改用Nginx。顺便提一下，在编译Nginx的时候如果碰到编译错误，那就试试下面这句命令行吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install pcre-devel&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改Nginx的配置文件nginx.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user  root;
worker_processes  1;

error_log  logs/error.log crit;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

pid        logs/nginx.pid;

worker_rlimit_nofile 65535;

events {
    use epoll;
    worker_connections  65535;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    server_names_hash_bucket_size 128;
    large_client_header_buffers 4 32k;
    client_header_buffer_size 32k; 
    client_max_body_size 8m;
      
    sendfile on;
    keepalive_timeout 10 10;
    tcp_nopush on;
    tcp_nodelay on;
    
    fastcgi_connect_timeout 300;
    fastcgi_send_timeout 300;
    fastcgi_read_timeout 300;
    fastcgi_buffer_size 32k;
    fastcgi_buffers 4 32k;
    fastcgi_busy_buffers_size 32k;
    fastcgi_temp_file_write_size 32k;
    fastcgi_intercept_errors on;

    gzip  on;
    gzip_min_length  1k;
    gzip_buffers     4 16k;
    gzip_http_version 1.0;
    gzip_comp_level 1;
    gzip_types       text/plain application/x-javascript text/css application/xml;
    gzip_vary on;

    server {
        listen       80;
        server_name  liuxuan.info www.liuxuan.info;
        
        log_format  access  '$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; '
                            '$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; '
                            '&amp;quot;$http_user_agent&amp;quot; $http_x_forwarded_for';
        
        access_log  logs/host.access.log  access;

        location / {
            root   /path/to/octopress/public;
            index  index.html;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
  
    }

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建Nginx自动启动脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/init.d/nginx&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后加入下面的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
#
# nginx - this script starts and stops the nginx daemin
#
# chkconfig:   - 85 15 
# description:  Nginx is an HTTP(S) server, HTTP(S) reverse \
#               proxy and IMAP/POP3 proxy server
# processname: nginx
# config:      /usr/local/nginx/conf/nginx.conf
# pidfile:     /usr/local/nginx/logs/nginx.pid

# Source function library.
. /etc/rc.d/init.d/functions

# Source networking configuration.
. /etc/sysconfig/network

# Check that networking is up.
[ &amp;quot;$NETWORKING&amp;quot; = &amp;quot;no&amp;quot; ] &amp;amp;&amp;amp; exit 0

nginx=&amp;quot;/usr/local/nginx/sbin/nginx&amp;quot;
prog=$(basename $nginx)

NGINX_CONF_FILE=&amp;quot;/usr/local/nginx/conf/nginx.conf&amp;quot;

lockfile=/var/lock/subsys/nginx

start() {
    [ -x $nginx ] || exit 5
    [ -f $NGINX_CONF_FILE ] || exit 6
    echo -n $&amp;quot;Starting $prog: &amp;quot;
    daemon $nginx -c $NGINX_CONF_FILE
    retval=$?
    echo
    [ $retval -eq 0 ] &amp;amp;&amp;amp; touch $lockfile
    return $retval
}

stop() {
    echo -n $&amp;quot;Stopping $prog: &amp;quot;
    killproc $prog -QUIT
    retval=$?
    echo
    [ $retval -eq 0 ] &amp;amp;&amp;amp; rm -f $lockfile
    return $retval
}

restart() {
    configtest || return $?
    stop
    start
}

reload() {
    configtest || return $?
    echo -n $&amp;quot;Reloading $prog: &amp;quot;
    killproc $nginx -HUP
    RETVAL=$?
    echo
}

force_reload() {
    restart
}

configtest() {
  $nginx -t -c $NGINX_CONF_FILE
}

rh_status() {
    status $prog
}

rh_status_q() {
    rh_status &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
}

case &amp;quot;$1&amp;quot; in
    start)
        rh_status_q &amp;amp;&amp;amp; exit 0
        $1
        ;;
    stop)
        rh_status_q || exit 0
        $1
        ;;
    restart|configtest)
        $1
        ;;
    reload)
        rh_status_q || exit 7
        $1
        ;;
    force-reload)
        force_reload
        ;;
    status)
        rh_status
        ;;
    condrestart|try-restart)
        rh_status_q || exit 0
            ;;
    *)
        echo $&amp;quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}&amp;quot;
        exit 2
esac&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加可执行权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod +x /etc/init.d/nginx&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置开机自启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chkconfig nginx on&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后顺便对CentOS做一下优化，用&lt;a href=&quot;http://www.balabit.com/network-security/syslog-ng/opensource-logging-system&quot; title=&quot;syslog-ng&quot;&gt;syslog-ng&lt;/a&gt;替换rsyslog，删除不需要的进程。然后调整Linux的最大文件打开数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/security/limits.conf
在最后一行添加
* soft nofile 65535
* hard nofile 65535&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个搭建过程在30分钟之内就可以搞定，大大低于搭建Wordpress环境所需要的时间。而且通过top命令可以看到由于只有一个Nginx进程，所以整个内存占用率在4%左右，大大低于Wordpress的30%，这点对于小内存的VPS是非常有优势的。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>myBatis源码分析之映射</title>
   <link href="/blog/2011/10/24/mybatis-source-code-analysis-mapping/"/>
   <updated>2011-10-24T20:35:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/10/24/mybatis-source-code-analysis-mapping</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;包结构分析&lt;/h2&gt;

&lt;table border=&quot;1&quot; width=&quot;100%&quot; cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; summary=&quot;&quot;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;th align=&quot;left&quot; colspan=&quot;2&quot; style=&quot;background-color:#CCCCFF&quot;&gt;
&lt;b&gt;Packages&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.builder&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.builder.annotation&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.builder.xml&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.mapping&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.parsing&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;myBatis在XML解析方面的包结构相对于iBatis精简了不少，而且还加入了对注解的支持。在myatis中除了在XML文件内映射SQ外，我们还可以用注解来映射SQL。当然，这样做的好处和坏处都有，网上讨论也很多，在选择的时候要做好充分考虑。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;源码分析&lt;/h2&gt;

&lt;p&gt;myBatis相对于iBatis变化还是很大的，iBatis的客户端接口SqlMapClient在myBatis中已经不复存在，取而代之的是SqlSession接口，接下来我们就来看看SqlSession接口是怎么创建的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public SqlSessionFactory build(Reader reader, String environment, Properties properties) {
    try {
      XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);
      return build(parser.parse());
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&amp;quot;Error building SqlSession.&amp;quot;, e);
    } finally {
      ErrorContext.instance().reset();
      try {
        reader.close();
      } catch (IOException e) {
        // Intentionally ignore. Prefer previous error.
      }
    }
}

public SqlSessionFactory build(Configuration config) {
    return new DefaultSqlSessionFactory(config);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在SqlSessionFactoryBuilder中定义了许多重载的build方法，其他build方法再调用上面的有三个参数的build方法，在其中创建XMLConfigBuilder对象解析XML文件，然后再调用以Configuration为参数的build方法返回DefaultSqlSessionFactory对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void parseConfiguration(XNode root) {
    try {
      typeAliasesElement(root.evalNode(&amp;quot;typeAliases&amp;quot;));
      pluginElement(root.evalNode(&amp;quot;plugins&amp;quot;));
      objectFactoryElement(root.evalNode(&amp;quot;objectFactory&amp;quot;));
      objectWrapperFactoryElement(root.evalNode(&amp;quot;objectWrapperFactory&amp;quot;));
      propertiesElement(root.evalNode(&amp;quot;properties&amp;quot;));
      settingsElement(root.evalNode(&amp;quot;settings&amp;quot;));
      environmentsElement(root.evalNode(&amp;quot;environments&amp;quot;));
      typeHandlerElement(root.evalNode(&amp;quot;typeHandlers&amp;quot;));
      mapperElement(root.evalNode(&amp;quot;mappers&amp;quot;));
    } catch (Exception e) {
      throw new BuilderException(&amp;quot;Error parsing SQL Mapper Configuration. Cause: &amp;quot; + e, e);
    }
  }
  
  ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;XMLConfigBuilder类也重载了许多的构造方法，但是最终调用的还是有三个参数的构造方法。在parse方法中调用parseConfiguration方法解析在configuration.xml中所有的配置项。myBatis定义了一个XNode类用来辅助解析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Properties parseAttributes(Node n) {
    Properties attributes = new Properties();
    NamedNodeMap attributeNodes = n.getAttributes();
    if (attributeNodes != null) {
      for (int i = 0; i &amp;lt; attributeNodes.getLength(); i++) {
        Node attribute = attributeNodes.item(i);
        String value = PropertyParser.parse(attribute.getNodeValue(), variables);
        attributes.put(attribute.getNodeName(), value);
      }
    }
    return attributes;
  }

  private Object evaluate(String expression, Object root, QName returnType) {
    try {
      return xpath.evaluate(expression, root, returnType);
    } catch (Exception e) {
      throw new BuilderException(&amp;quot;Error evaluating XPath.  Cause: &amp;quot; + e, e);
    }
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在XPathParser类中读取XML文件流创建Document类，而且其中定义了许多evalXXX方法，而后最终调用的是XPath类的evaluate方法。而且在XNode中一个SQL的映射片段XML会被解析后存放到一个Properties类中。那么现在就能明白为什么与解析相关的包精简了很多：就是因为iBatis是用SAX方式解析，而myBatis直接调用JDK自带的XPath的API解析，所以省去了许多工作，不用去自定义元素类型，这样做的结果就是整个包结构得到了精简，而且解析性能更好。&lt;/p&gt;

&lt;p&gt;下面来看一下SQL的映射过程：首先在XMLConfigBuilder中的mapperElement方法中会创建XMLMapperBuilder对象，然后再调用它的parse方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void parsePendingStatements() {
	  Collection&amp;lt;xmlstatementbuilder&amp;gt; incompleteStatements = configuration.getIncompleteStatements();
	  synchronized (incompleteStatements) {
		  Iterator&amp;lt;xmlstatementbuilder&amp;gt; iter = incompleteStatements.iterator();
		  while (iter.hasNext()) {
			  try {
				  iter.next().parseStatementNode();
				  iter.remove();
			  } catch (IncompleteStatementException e) {
				  // Statement is still missing a resource...
			  }
		  }
	  }
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到在parsePendingStatements方法中调用的是XMLStatementBuilder的parseStatementNode方法，所以我们继续跟踪。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void parseStatementNode() {
    ...

    SqlSource sqlSource = new DynamicSqlSource(configuration, rootSqlNode);
    
    ...
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL的配置被读取进来后保存到了SqlSource接口的实例DynamicSqlSource类中，其他是对参数，返回值和主键的解析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public BoundSql getBoundSql(Object parameterObject) {
    DynamicContext context = new DynamicContext(configuration, parameterObject);
    rootSqlNode.apply(context);
    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);
    Class&amp;lt;?&amp;gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();
    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType);
    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);
    for (Map.Entry&amp;lt;string , Object&amp;gt; entry : context.getBindings().entrySet()) {
      boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());
    }
    return boundSql;
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没什么好说的，创建SqlSourceBuilder类再调用它的parse方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public SqlSource parse(String originalSql, Class&amp;lt;?&amp;gt; parameterType) {
    ParameterMappingTokenHandler handler = new ParameterMappingTokenHandler(configuration, parameterType);
    GenericTokenParser parser = new GenericTokenParser(&amp;quot;#{&amp;quot;, &amp;quot;}&amp;quot;, handler);
    String sql = parser.parse(originalSql);
    return new StaticSqlSource(configuration, sql, handler.getParameterMappings());
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在parse方法里又创建了GenericTokenParser类，然后调用它的parse方法去解析SQL。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String parse(String text) {
    StringBuilder builder = new StringBuilder();
    if (text != null) {
      String after = text;
      int start = after.indexOf(openToken);
      int end = after.indexOf(closeToken);
      while (start &amp;gt; -1) {
        if (end &amp;gt; start) {
          String before = after.substring(0, start);
          String content = after.substring(start + openToken.length(), end);
          String substitution = handler.handleToken(content);
          builder.append(before);
          builder.append(substitution);
          after = after.substring(end + closeToken.length());
        } else if (end &amp;gt; -1) {
          String before = after.substring(0, end);
          builder.append(before);
          builder.append(closeToken);
          after = after.substring(end + closeToken.length());
        } else {
          break;
        }
        start = after.indexOf(openToken);
        end = after.indexOf(closeToken);
      }
      builder.append(after);
    }
    return builder.toString();
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;parse方法的目的和iBatis是一样的，是要把形如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TABLE WHERE ID = #{ID}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TABLE WHERE ID = ？&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里为止，整个解析过程就结束了，所有解析得到的配置都会保存到MappedStatement类中。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;这篇博文是iBatis和myBatis源码分析系列的最后一篇，也是最长的一篇。我觉得这只能算是粗略的源码分析，因为只分析了主要的几个部分，其他非常细节的地方并没有去做研究。四篇博文写下来给我的感觉是myBatis在代码结构和质量上相较iBatis都有比较大的提高，但是有些地方还是感觉有点复杂和罗嗦，代码读起来不是那么的清晰。有些类中的重载方法非常多，如果可以适当减少一些的话可以提高代码的可读性；还有可以对参数绑定做一个归纳，减少BaseTypeHandler类的实现类等。&lt;/p&gt;

&lt;p&gt;虽然iBatis或者myBatis很轻量也很好用，但是就像我在第一篇概览中说的那样，现在Java平台上ORM框架大多数都是基于POJO和XML之上的，这样做的后果就是对象贫血，开放速度变慢。POJO什么时候会被抛弃我不知道，但是我相信会有那一天的。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>iBatis源码分析之映射</title>
   <link href="/blog/2011/10/23/ibatis-source-code-analysis-mapping/"/>
   <updated>2011-10-23T19:14:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/10/23/ibatis-source-code-analysis-mapping</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;包结构分析&lt;/h2&gt;

&lt;table border=&quot;1&quot; width=&quot;100%&quot; cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; summary=&quot;&quot;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;th align=&quot;left&quot; colspan=&quot;2&quot; style=&quot;background-color:#CCCCFF&quot;&gt;
&lt;b&gt;Packages&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.builder.xml&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.xml&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.parameter&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.result&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.result.loader&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql.dynamic&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql.dynamic.elements&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql.raw&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql.simple&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql.stat&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.statement&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;iBatis处理映射的包结构应该说还是比较清晰的，基本上看到包名就可以知道包下面的类是做什么用的。但是我们看到关于映射的包一共有10个，但是像dynamic，raw，simple，stat这些包下都只有一个类，显然这种分法是有问题的，我们应当尽可能地减少包，包越少结构就越清晰，但并不是说把类都放一个包下，要在这两者之间寻求平衡。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;源码分析&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public static SqlMapClient buildSqlMapClient(Reader reader) {
    return new SqlMapConfigParser().parse(reader);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们要对数据库操作，首先要创建SqlMapClient接口，而SqlMapClientBuilder类就是用来创建SqlMapClient接口的。在buildSqlMapClient方法里创建了SqlMapConfigParser类，然后再调用该类的parse方法来解析XML配置文件。其实代码读到这里就可以看出SqlMapClient接口是线程安全的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public SqlMapConfigParser() {
    parser.setValidation(true);
    parser.setEntityResolver(new SqlMapClasspathEntityResolver());

    addSqlMapConfigNodelets();
    addGlobalPropNodelets();
    addSettingsNodelets();
    addTypeAliasNodelets();
    addTypeHandlerNodelets();
    addTransactionManagerNodelets();
    addSqlMapNodelets();
    addResultObjectFactoryNodelets();

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先在创建SqlMapConfigParser类的时候就会为NodeletParser类预先定义好XML文件里各种DOM类型的解析方法，这个是通过实现Nodelet接口的process方法来实现的(Nodelet实际上就是回调接口)。我们可以看到iBatis对各种DOM类型自定义了一套表示方法，他们的定义在NodeletParser类里。在SqlMapConfigParser类的parse方法里再调用NodeletParser的parse方法解析XML文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
   * Registers a nodelet for the specified XPath.  Current XPaths supported
   * are:
   * &amp;lt;ul&amp;gt;
   * &amp;lt;li&amp;gt; Text Path - /rootElement/childElement/text()
   * &amp;lt;li&amp;gt; Attribute Path  - /rootElement/childElement/@theAttribute
   * &amp;lt;li&amp;gt; Element Path - /rootElement/childElement/theElement
   * &amp;lt;li&amp;gt; All Elements Named - //theElement
   * &amp;lt;/ul&amp;gt;
   */
  public void addNodelet(String xpath, Nodelet nodelet) {
    letMap.put(xpath, nodelet);
  }

  /**
   * A recursive method that walkes the DOM tree, registers XPaths and
   * calls Nodelets registered under those XPaths.
   */
  private void process(Node node, Path path) {
    if (node instanceof Element) {
      // Element
      String elementName = node.getNodeName();
      path.add(elementName);
      processNodelet(node, path.toString());
      processNodelet(node, new StringBuffer(&amp;quot;//&amp;quot;).append(elementName).toString());

      // Attribute
      NamedNodeMap attributes = node.getAttributes();
      int n = attributes.getLength();
      for (int i = 0; i &amp;lt; n; i++) {
        Node att = attributes.item(i);
        String attrName = att.getNodeName();
        path.add(&amp;quot;@&amp;quot; + attrName);
        processNodelet(att, path.toString());
        processNodelet(node, new StringBuffer(&amp;quot;//@&amp;quot;).append(attrName).toString());
        path.remove();
      }

      // Children
      NodeList children = node.getChildNodes();
      for (int i = 0; i &amp;lt; children.getLength(); i++) {
        process(children.item(i), path);
      }
      path.add(&amp;quot;end()&amp;quot;);
      processNodelet(node, path.toString());
      path.remove();
      path.remove();
    } else if (node instanceof Text) {
      // Text
      path.add(&amp;quot;text()&amp;quot;);
      processNodelet(node, path.toString());
      processNodelet(node, &amp;quot;//text()&amp;quot;);
      path.remove();
    }
  }

  ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析XML采用的是SAX方式，为了区分XML中的元素类型自定义了一套XPath，然后根据XPath进行相应的处理。processNodelet方法里调用Nodelet接口的process方法，而这个process方法已经在创建SqlMapConfigParser类的时候实现了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SqlStatementParser {

  public void parseGeneralStatement(Node node, MappedStatement statement) {

    // get attributes
    Properties attributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());
    String id = attributes.getProperty(&amp;quot;id&amp;quot;);
    String parameterMapName = state.applyNamespace(attributes.getProperty(&amp;quot;parameterMap&amp;quot;));
    String parameterClassName = attributes.getProperty(&amp;quot;parameterClass&amp;quot;);
    String resultMapName = attributes.getProperty(&amp;quot;resultMap&amp;quot;);
    String resultClassName = attributes.getProperty(&amp;quot;resultClass&amp;quot;);
    String cacheModelName = state.applyNamespace(attributes.getProperty(&amp;quot;cacheModel&amp;quot;));
    String xmlResultName = attributes.getProperty(&amp;quot;xmlResultName&amp;quot;);
    String resultSetType = attributes.getProperty(&amp;quot;resultSetType&amp;quot;);
    String fetchSize = attributes.getProperty(&amp;quot;fetchSize&amp;quot;);
    String allowRemapping = attributes.getProperty(&amp;quot;remapResults&amp;quot;);
    String timeout = attributes.getProperty(&amp;quot;timeout&amp;quot;);

    if (state.isUseStatementNamespaces()) {
      id = state.applyNamespace(id);
    }
    String[] additionalResultMapNames = null;
    if (resultMapName != null) {
      additionalResultMapNames = state.getAllButFirstToken(resultMapName);
      resultMapName = state.getFirstToken(resultMapName);
      resultMapName = state.applyNamespace(resultMapName);
      for (int i = 0; i &amp;lt; additionalResultMapNames.length; i++) {
        additionalResultMapNames[i] = state.applyNamespace(additionalResultMapNames[i]);
      }
    }

    String[] additionalResultClassNames = null;
    if (resultClassName != null) {
      additionalResultClassNames = state.getAllButFirstToken(resultClassName);
      resultClassName = state.getFirstToken(resultClassName);
    }
    Class[] additionalResultClasses = null;
    if (additionalResultClassNames != null) {
      additionalResultClasses = new Class[additionalResultClassNames.length];
      for (int i = 0; i &amp;lt; additionalResultClassNames.length; i++) {
        additionalResultClasses[i] = resolveClass(additionalResultClassNames[i]);
      }
    }

    state.getConfig().getErrorContext().setMoreInfo(&amp;quot;Check the parameter class.&amp;quot;);
    Class parameterClass = resolveClass(parameterClassName);

    state.getConfig().getErrorContext().setMoreInfo(&amp;quot;Check the result class.&amp;quot;);
    Class resultClass = resolveClass(resultClassName);

    Integer timeoutInt = timeout == null ? null : new Integer(timeout);
    Integer fetchSizeInt = fetchSize == null ? null : new Integer(fetchSize);
    boolean allowRemappingBool = &amp;quot;true&amp;quot;.equals(allowRemapping);

    MappedStatementConfig statementConf = state.getConfig().newMappedStatementConfig(id, statement,
        new XMLSqlSource(state, node), parameterMapName, parameterClass, resultMapName, additionalResultMapNames,
        resultClass, additionalResultClasses, resultSetType, fetchSizeInt, allowRemappingBool, timeoutInt, cacheModelName,
        xmlResultName);

    findAndParseSelectKey(node, statementConf);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在SqlStatementParser类的parseGeneralStatement方法中创建MappedStatementConfig对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MappedStatementConfig(SqlMapConfiguration config, String id, MappedStatement statement, SqlSource processor,
                        String parameterMapName, Class parameterClass, String resultMapName,
                        String[] additionalResultMapNames, Class resultClass, Class[] additionalResultClasses,
                        String cacheModelName, String resultSetType, Integer fetchSize, boolean allowRemapping,
                        Integer timeout, Integer defaultStatementTimeout, String xmlResultName) {
    this.errorContext = config.getErrorContext();
    this.client = config.getClient();
    SqlMapExecutorDelegate delegate = client.getDelegate();
    this.typeHandlerFactory = config.getTypeHandlerFactory();
    errorContext.setActivity(&amp;quot;parsing a mapped statement&amp;quot;);
    errorContext.setObjectId(id + &amp;quot; statement&amp;quot;);
    errorContext.setMoreInfo(&amp;quot;Check the result map name.&amp;quot;);
    if (resultMapName != null) {
      statement.setResultMap(client.getDelegate().getResultMap(resultMapName));
      if (additionalResultMapNames != null) {
        for (int i = 0; i &amp;lt; additionalResultMapNames.length; i++) {
          statement.addResultMap(client.getDelegate().getResultMap(additionalResultMapNames[i]));
        }
      }
    }
    errorContext.setMoreInfo(&amp;quot;Check the parameter map name.&amp;quot;);
    if (parameterMapName != null) {
      statement.setParameterMap(client.getDelegate().getParameterMap(parameterMapName));
    }
    statement.setId(id);
    statement.setResource(errorContext.getResource());
    if (resultSetType != null) {
      if (&amp;quot;FORWARD_ONLY&amp;quot;.equals(resultSetType)) {
        statement.setResultSetType(new Integer(ResultSet.TYPE_FORWARD_ONLY));
      } else if (&amp;quot;SCROLL_INSENSITIVE&amp;quot;.equals(resultSetType)) {
        statement.setResultSetType(new Integer(ResultSet.TYPE_SCROLL_INSENSITIVE));
      } else if (&amp;quot;SCROLL_SENSITIVE&amp;quot;.equals(resultSetType)) {
        statement.setResultSetType(new Integer(ResultSet.TYPE_SCROLL_SENSITIVE));
      }
    }
    if (fetchSize != null) {
      statement.setFetchSize(fetchSize);
    }

    // set parameter class either from attribute or from map (make sure to match)
    ParameterMap parameterMap = statement.getParameterMap();
    if (parameterMap == null) {
      statement.setParameterClass(parameterClass);
    } else {
      statement.setParameterClass(parameterMap.getParameterClass());
    }

    // process SQL statement, including inline parameter maps
    errorContext.setMoreInfo(&amp;quot;Check the SQL statement.&amp;quot;);
    Sql sql = processor.getSql();
    setSqlForStatement(statement, sql);

    // set up either null result map or automatic result mapping
    ResultMap resultMap = (ResultMap) statement.getResultMap();
    if (resultMap == null &amp;amp;&amp;amp; resultClass == null) {
      statement.setResultMap(null);
    } else if (resultMap == null) {
      resultMap = buildAutoResultMap(allowRemapping, statement, resultClass, xmlResultName);
      statement.setResultMap(resultMap);
      if (additionalResultClasses != null) {
        for (int i = 0; i &amp;lt; additionalResultClasses.length; i++) {
          statement.addResultMap(buildAutoResultMap(allowRemapping, statement, additionalResultClasses[i], xmlResultName));
        }
      }

    }
    
    ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在MappedStatementConfig类的构造方法里又调用了SqlSource接口的getSql方法，而SqlSource接口只有一个实现类XMLSqlSource，继续看XMLSqlSource类里的getSql方法是怎么实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Sql getSql() {
    state.getConfig().getErrorContext().setActivity(&amp;quot;processing an SQL statement&amp;quot;);

    boolean isDynamic = false;
    StringBuffer sqlBuffer = new StringBuffer();
    DynamicSql dynamic = new DynamicSql(state.getConfig().getClient().getDelegate());
    isDynamic = parseDynamicTags(parentNode, dynamic, sqlBuffer, isDynamic, false);
    String sqlStatement = sqlBuffer.toString();
    if (isDynamic) {
      return dynamic;
    } else {
      return new RawSql(sqlStatement);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们就来看一下iBatis是怎么处理SQL映射的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void processBodyChildren(StatementScope statementScope, SqlTagContext ctx, Object     parameterObject, Iterator localChildren, PrintWriter out) {
    while (localChildren.hasNext()) {
      SqlChild child = (SqlChild) localChildren.next();
      if (child instanceof SqlText) {
        SqlText sqlText = (SqlText) child;
        String sqlStatement = sqlText.getText();
        if (sqlText.isWhiteSpace()) {
          out.print(sqlStatement);
        } else if (!sqlText.isPostParseRequired()) {

          // BODY OUT
          out.print(sqlStatement);

          ParameterMapping[] mappings = sqlText.getParameterMappings();
          if (mappings != null) {
            for (int i = 0, n = mappings.length; i &amp;lt; n; i++) {
              ctx.addParameterMapping(mappings[i]);
            }
          }
        } else {

          IterateContext itCtx = ctx.peekIterateContext();

          if(null != itCtx &amp;amp;&amp;amp; itCtx.isAllowNext()){
            itCtx.next();
            itCtx.setAllowNext(false);
            if(!itCtx.hasNext()) {
              itCtx.setFinal(true);
            }
          }

          if(itCtx!=null) {
            StringBuffer sqlStatementBuffer = new StringBuffer(sqlStatement);
            iteratePropertyReplace(sqlStatementBuffer, itCtx);
            sqlStatement = sqlStatementBuffer.toString();
          }

          sqlText = PARAM_PARSER.parseInlineParameterMap(delegate.getTypeHandlerFactory(), sqlStatement);

          ParameterMapping[] mappings = sqlText.getParameterMappings();
          out.print(sqlText.getText());
          if (mappings != null) {
             for (int i = 0, n = mappings.length; i &amp;lt; n; i++) {
               ctx.addParameterMapping(mappings[i]);
             }
          }
        }
      } else if (child instanceof SqlTag) {
        ...
      }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到在processBodyChildren方法里调用了InlineParameterMapParser类的parseInlineParameterMap方法，继续跟踪下去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public SqlText parseInlineParameterMap(TypeHandlerFactory typeHandlerFactory, String sqlStatement, Class parameterClass) {

    String newSql = sqlStatement;

    List mappingList = new ArrayList();

    StringTokenizer parser = new StringTokenizer(sqlStatement, PARAMETER_TOKEN, true);
    StringBuffer newSqlBuffer = new StringBuffer();

    String token = null;
    String lastToken = null;
    while (parser.hasMoreTokens()) {
      token = parser.nextToken();
      if (PARAMETER_TOKEN.equals(lastToken)) {
        if (PARAMETER_TOKEN.equals(token)) {
          newSqlBuffer.append(PARAMETER_TOKEN);
          token = null;
        } else {
          ParameterMapping mapping = null;
          if (token.indexOf(PARAM_DELIM) &amp;gt; -1) {
            mapping = oldParseMapping(token, parameterClass, typeHandlerFactory);
          } else {
            mapping = newParseMapping(token, parameterClass, typeHandlerFactory);
          }

          mappingList.add(mapping);
          newSqlBuffer.append(&amp;quot;?&amp;quot;);
          token = parser.nextToken();
          if (!PARAMETER_TOKEN.equals(token)) {
            throw new SqlMapException(&amp;quot;Unterminated inline parameter in mapped statement (&amp;quot; + &amp;quot;statement.getId()&amp;quot; + &amp;quot;).&amp;quot;);
          }
          token = null;
        }
      } else {
        if (!PARAMETER_TOKEN.equals(token)) {
          newSqlBuffer.append(token);
        }
      }

      lastToken = token;
    }

    newSql = newSqlBuffer.toString();

    ParameterMapping[] mappingArray = (ParameterMapping[]) mappingList.toArray(new ParameterMapping[mappingList.size()]);

    SqlText sqlText = new SqlText();
    sqlText.setText(newSql);
    sqlText.setParameterMappings(mappingArray);
    return sqlText;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于找到解析SQL的类了，在parseInlineParameterMap方法中会将下面的SQL&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TABLE WHERE ID = #ID#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析成能被JDBC执行的SQL&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TABLE WHERE ID = ?&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等到解析完成后会把SQL保存到SqlText类中，再把SqlText保存到MappedStatement类里，有了MappedStatement对象就可以执行相应的CRUD操作了。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>ASCII，Unicode和UTF-8的编码方式</title>
   <link href="/blog/2011/10/16/ascii-unicode-utf-8/"/>
   <updated>2011-10-16T18:57:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/10/16/ascii-unicode-utf-8</id>
   <content type="html">&lt;h2 id=&quot;ascii&quot;&gt;ASCII码&lt;/h2&gt;

&lt;p&gt;我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。&lt;/p&gt;

&lt;h2 id=&quot;ascii-1&quot;&gt;非ASCII编码&lt;/h2&gt;

&lt;p&gt;英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0—127表示的符号是一样的，不一样的只是128—255的这一段。至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。&lt;/p&gt;

&lt;h2 id=&quot;unicode&quot;&gt;Unicode&lt;/h2&gt;

&lt;p&gt;正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。&lt;/p&gt;

&lt;h2 id=&quot;unicode-1&quot;&gt;Unicode的问题&lt;/h2&gt;

&lt;p&gt;需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。比如，汉字“严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。&lt;/p&gt;

&lt;p&gt;这里就有两个严重的问题，第一个问题是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。它们造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode在很长一段时间内无法推广，直到互联网的出现。&lt;/p&gt;

&lt;h2 id=&quot;utf-8&quot;&gt;UTF-8&lt;/h2&gt;

&lt;p&gt;互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8的编码规则很简单，只有二条： &lt;br /&gt;
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。  &lt;br /&gt;
2）对于n字节的符号（n&amp;gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。  &lt;/p&gt;

&lt;p&gt;下表总结了编码规则，字母x表示可用编码的位。&lt;br /&gt;
Unicode符号范围 | UTF-8编码方式&lt;br /&gt;
(十六进制) | （二进制）&lt;br /&gt;
——————–+————————————&lt;br /&gt;
0000 0000-0000 007F | 0xxxxxxx&lt;br /&gt;
0000 0080-0000 07FF | 110xxxxx 10xxxxxx&lt;br /&gt;
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx&lt;br /&gt;
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  &lt;/p&gt;

&lt;p&gt;下面，还是以汉字“严”为例，演示如何实现UTF-8编码。&lt;br /&gt;
已知“严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是E4B8A5。&lt;/p&gt;

&lt;h2 id=&quot;unicodeutf-8&quot;&gt;Unicode与UTF-8之间的转换&lt;/h2&gt;

&lt;p&gt;通过上一节的例子，可以看到“严”的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。
在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击“文件”菜单中的“另存为”命令，会跳出一个对话框，在最底部有一个“编码”的下拉条。&lt;br /&gt;
里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。  &lt;/li&gt;
  &lt;li&gt;Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的little endian格式。  &lt;/li&gt;
  &lt;li&gt;Unicode big endian编码与上一个选项相对应。我在下一节会解释little endian和big endian的涵义。  &lt;/li&gt;
  &lt;li&gt;UTF-8编码，也就是上一节谈到的编码方法。&lt;br /&gt;
选择完”编码方式“后，点击”保存“按钮，文件的编码方式就立刻转换好了。  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;little-endianbig-endian&quot;&gt;Little endian和Big endian&lt;/h2&gt;

&lt;p&gt;上一节已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字”严“为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。因此，第一个字节在前，就是”大头方式“（Big endian），第二个字节在前就是”小头方式“（Little endian）。
那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？&lt;/p&gt;

&lt;p&gt;Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格“（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;实例&lt;/h2&gt;

&lt;p&gt;下面，举一个实例。&lt;br /&gt;
打开”记事本“程序Notepad.exe，新建一个文本文件，内容就是一个”严“字，依次采用ANSI，Unicode，Unicode big endian 和 UTF-8编码方式保存。然后，用文本编辑软件UltraEdit中的”十六进制功能“，观察该文件的内部编码方式。 &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ANSI：文件的编码就是两个字节“D1 CF”，这正是“严”的GB2312编码，这也暗示GB2312是采用大头方式存储的。  &lt;/li&gt;
  &lt;li&gt;Unicode：编码是四个字节“FF FE 25 4E”，其中“FF FE”表明是小头方式存储，真正的编码是4E25。  &lt;/li&gt;
  &lt;li&gt;Unicode big endian：编码是四个字节“FE FF 4E 25”，其中“FE FF”表明是大头方式存储。  &lt;/li&gt;
  &lt;li&gt;UTF-8：编码是六个字节“EF BB BF E4 B8 A5”，前三个字节“EF BB BF”表示这是UTF-8编码，后三个“E4B8A5”就是“严”的具体编码，它的存储顺序与编码顺序是一致的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot; title=&quot;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot;&gt;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>RIP，史蒂夫·乔布斯</title>
   <link href="/blog/2011/10/06/rip-steve-jobs/"/>
   <updated>2011-10-06T18:46:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/10/06/rip-steve-jobs</id>
   <content type="html">&lt;p&gt;多年以前，当我听说乔布斯患上癌症时，我简直不敢相信我的耳朵。在大学的时候，我就买了第一代的iPod。当时它那超薄的机身以及旋转式触摸按键让我惊为神器，爱不释手。几年过去，iPhone横空出世，虽然我没有买过iPhone,但还是被乔布斯的创造力所折服。如今，iPad又带来了一股平板电脑的旋风，人们争相购买。可以这么说，乔布斯在不断地改变人们的生活方式，在不断地改变着这个世界。&lt;/p&gt;

&lt;p&gt;但是今天是一个灰暗的日子，乔布斯离开了我们，我们无比悲伤。但是逝者已矣，乔布斯留给我们的是他那对创新的孜孜不倦，热爱自己喜欢的工作，“stay hungry, stay foolish”是他一生最好的注解。下面是乔布斯于2005年在斯坦福毕业典礼上的演讲全文，谨以此文与喜欢乔布斯的朋友共勉：&lt;strong&gt;stay hungry， stay foolish&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;I am honored to be with you today at your commencement from one of the finest universities in the world. I never graduated from college. Truth be told, this is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories.&lt;/p&gt;

&lt;p&gt;The first story is about connecting the dots.&lt;/p&gt;

&lt;p&gt;I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?&lt;/p&gt;

&lt;p&gt;It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: “We have an unexpected baby boy; do you want him?” They said: “Of course.” My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.&lt;/p&gt;

&lt;p&gt;And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition. After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked interesting.&lt;/p&gt;

&lt;p&gt;It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned coke bottles for the 5¢ deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:&lt;/p&gt;

&lt;p&gt;Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this. I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating.&lt;/p&gt;

&lt;p&gt;None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, it’s likely that no personal computer would have them. If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.&lt;/p&gt;

&lt;p&gt;Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something — your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.&lt;/p&gt;

&lt;p&gt;My second story is about love and loss.&lt;/p&gt;

&lt;p&gt;I was lucky — I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees. We had just released our finest creation — the Macintosh — a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well. But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.&lt;/p&gt;

&lt;p&gt;I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley. But something slowly began to dawn on me — I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.&lt;/p&gt;

&lt;p&gt;I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.&lt;/p&gt;

&lt;p&gt;During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world. In a remarkable turn of events, Apple bought NeXT, I returned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together.&lt;/p&gt;

&lt;p&gt;I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don’t lose faith. I’m convinced that the only thing that kept me going was that I loved what I did. You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle.&lt;/p&gt;

&lt;p&gt;My third story is about death.&lt;/p&gt;

&lt;p&gt;When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.” It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “If today were the last day of my life, would I want to do what I am about to do today?” And whenever the answer has been “No” for too many days in a row, I know I need to change something.&lt;/p&gt;

&lt;p&gt;Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything — all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.&lt;/p&gt;

&lt;p&gt;About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die. It means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.&lt;/p&gt;

&lt;p&gt;I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I’m fine now.&lt;/p&gt;

&lt;p&gt;This was the closest I’ve been to facing death, and I hope it’s the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:&lt;/p&gt;

&lt;p&gt;No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.&lt;/p&gt;

&lt;p&gt;Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma — which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.&lt;/p&gt;

&lt;p&gt;When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions.&lt;/p&gt;

&lt;p&gt;Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you.&lt;/p&gt;

&lt;p&gt;Stay Hungry. Stay Foolish.&lt;/p&gt;

&lt;p&gt;Thank you all very much.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>iBatis和myBatis源码分析之缓存</title>
   <link href="/blog/2011/09/16/ibatis-and-mybatis-source-code-analysis-cache/"/>
   <updated>2011-09-16T18:41:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/09/16/ibatis-and-mybatis-source-code-analysis-cache</id>
   <content type="html">&lt;h2 id=&quot;ibatis&quot;&gt;iBatis&lt;/h2&gt;

&lt;h3 id=&quot;ibatiscache&quot;&gt;iBatis的cache包结构&lt;/h3&gt;

&lt;table border=&quot;1&quot; cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; summary=&quot;&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot; colspan=&quot;2&quot; style=&quot;background-color:#CCCCFF&quot;&gt;
&lt;b&gt;Packages&lt;/b&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.cache&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.cache.fifo&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.cache.lru&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.cache.memory&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.cache.oscache&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;iBatis已实现的四个CacheController类分别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FifoCacheController&lt;/li&gt;
  &lt;li&gt;LruCacheController&lt;/li&gt;
  &lt;li&gt;MemoryCacheController&lt;/li&gt;
  &lt;li&gt;OSCacheController&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，前三种是最常用的缓存策略，第四种是对&lt;a href=&quot;http://java.net/projects/oscache&quot; title=&quot;OSCache&quot;&gt;OSCache&lt;/a&gt;的支持。当然，你也可以根据需要实现自己的缓存策略，只需要实现CacheController接口就可以了。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;源码分析&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * FIFO (first in, first out) cache controller implementation
 */
public class FifoCacheController implements CacheController {

  private int cacheSize;
  private Map cache;
  private List keyList;

  /**
   * Default constructor
   */
  public FifoCacheController() {
    this.cacheSize = 100;
    this.cache = Collections.synchronizedMap(new HashMap());
    this.keyList = Collections.synchronizedList(new LinkedList());
  }

  public int getCacheSize() {
    return cacheSize;
  }

  public void setCacheSize(int cacheSize) {
    this.cacheSize = cacheSize;
  }

  /**
   * Configures the cache
   *
   * @param props Optionally can contain properties [reference-type=WEAK|SOFT|STRONG]
   */
  public void setProperties(Properties props) {
    String size = props.getProperty(&amp;quot;cache-size&amp;quot;);
    if (size == null) {
      size = props.getProperty(&amp;quot;size&amp;quot;);
    }
    if (size != null) {
      cacheSize = Integer.parseInt(size);
    }
  }

  /**
   * Add an object to the cache
   *
   * @param cacheModel The cacheModel
   * @param key        The key of the object to be cached
   * @param value      The object to be cached
   */
  public void putObject(CacheModel cacheModel, Object key, Object value) {
    cache.put(key, value);
    keyList.add(key);
    if (keyList.size() &amp;gt; cacheSize) {
      try {
        Object oldestKey = keyList.remove(0);
        cache.remove(oldestKey);
      } catch (IndexOutOfBoundsException e) {
        //ignore
      }
    }
  }

  /**
   * Get an object out of the cache.
   *
   * @param cacheModel The cache model
   * @param key        The key of the object to be returned
   * @return The cached object (or null)
   */
  public Object getObject(CacheModel cacheModel, Object key) {
    return cache.get(key);
  }

  public Object removeObject(CacheModel cacheModel, Object key) {
    keyList.remove(key);
    return cache.remove(key);
  }

  /**
   * Flushes the cache.
   *
   * @param cacheModel The cache model
   */
  public void flush(CacheModel cacheModel) {
    cache.clear();
    keyList.clear();
  }

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到FifoCacheController是用一个同步的HashMap和一个同步的LinkedList来实现的。其中，HashMap用来保存缓存内容；LinkedList是用来保存缓存中的对象的key。本来缓存只需要一个key-value容器就可以实现了，为什么要多引入一个LinkedList呢？主要原因还是Map的API不够强大，不支持索引操作，为了方便地找到HashMap中的第一个元素就必须加入一个支持索引的操作的集合，比如FifoCacheController类里的LinkedList,这样就可以快速地找到HashMap中的第一个对象的key值，而不是迭代HashMap。&lt;/p&gt;

&lt;p&gt;但是，这样的实现存在一个bug。假设有下列代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;putObject(cacheModel1, &amp;quot;key1&amp;quot;, &amp;quot;value1&amp;quot;);
putObject(cacheModel2, &amp;quot;key2&amp;quot;, &amp;quot;value2&amp;quot;);
putObject(cacheModel3, &amp;quot;key1&amp;quot;, &amp;quot;value3&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然，这个时候HashMap中应该有两个值，”key1”-&amp;gt;”value3”和”key2”-&amp;gt;”value2”；但是HashMap中却有三个key值，这样HashMap和LinkedList无法对应起来，也就是bug产生的原因。这个bug只存在与iBatis中，myBatis已经重写了缓存的实现，所以myBatis没有这个bug。&lt;/p&gt;

&lt;p&gt;在putObject方法里，又出现了在catch体里不做任何处理的“坏味道”。而且我们知道在这里捕获的IndexOutOfBoundsException不是已检查异常，完全可以不加try-catch；如果要加上try-catch的话，那么在catch体里可以加上日志，这样对缓存调优是非常有帮助的；又或者可以把异常抛出，在CacheModel类里处理异常。总之，异常处理是一定要做的，绝对不能什么都不做。&lt;/p&gt;

&lt;p&gt;从实际情况来看，FIFO策略的缓存实现很少使用，用到最多的还是LRU策略的缓存实现。我们来看一下iBatis的LRU缓存实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * LRU (least recently used) cache controller implementation
 */
public class LruCacheController implements CacheController {

  private int cacheSize;
  private Map cache;
  private List keyList;

  /**
   * Default constructor
   */
  public LruCacheController() {
    this.cacheSize = 100;
    this.cache = Collections.synchronizedMap(new HashMap());
    this.keyList = Collections.synchronizedList(new LinkedList());
  }

  public int getCacheSize() {
    return cacheSize;
  }

  public void setCacheSize(int cacheSize) {
    this.cacheSize = cacheSize;
  }

  /**
   * Configures the cache
   *
   * @param props Optionally can contain properties [reference-type=WEAK|SOFT|STRONG]
   */
  public void setProperties(Properties props) {
    String size = props.getProperty(&amp;quot;cache-size&amp;quot;);
    if (size == null) {
      size = props.getProperty(&amp;quot;size&amp;quot;);
    }
    if (size != null) {
      cacheSize = Integer.parseInt(size);
    }
  }

  /**
   * Add an object to the cache
   *
   * @param cacheModel The cacheModel
   * @param key        The key of the object to be cached
   * @param value      The object to be cached
   */
  public void putObject(CacheModel cacheModel, Object key, Object value) {
    cache.put(key, value);
    keyList.add(key);
    if (keyList.size() &amp;gt; cacheSize) {
      try {
        Object oldestKey = keyList.remove(0);
        cache.remove(oldestKey);
      } catch (IndexOutOfBoundsException e) {
        //ignore
      }
    }
  }

  /**
   * Get an object out of the cache.
   *
   * @param cacheModel The cache model
   * @param key        The key of the object to be returned
   * @return The cached object (or null)
   */
  public Object getObject(CacheModel cacheModel, Object key) {
    Object result = cache.get(key);
    keyList.remove(key);
    if (result != null) {
      keyList.add(key);
    }
    return result;
  }

  public Object removeObject(CacheModel cacheModel, Object key) {
    keyList.remove(key);
    return cache.remove(key);
  }

  /**
   * Flushes the cache.
   *
   * @param cacheModel The cache model
   */
  public void flush(CacheModel cacheModel) {
    cache.clear();
    keyList.clear();
  }

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LruCacheController怎么跟FIFOCacheController长得差不多啊，FIFO跟LRU的区别在哪里体现呢？LRU就是当缓存空间不足时，把最近最少使用的对象移除，那怎么说明一个对象是最近最少使用呢？再仔细一看，答案就在getObject方法里。当要在缓存中取对象时，先删除keyList中对应的key值，然后再加入到keyList的末尾，这样keyList中按顺序越是靠前的对象越是最近最少使用的对象。LruCacheController要依靠keyList实现LRU，所以FIFO里的两个集合不同步的bug在LRU里依然存在。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Memory-based implementation of CacheController
 */
public class MemoryCacheController implements CacheController {

  private MemoryCacheLevel referenceType = MemoryCacheLevel.WEAK;
  private Map cache = Collections.synchronizedMap(new HashMap());

  /**
   * Configures the cache
   *
   * @param props Optionally can contain properties [reference-type=WEAK|SOFT|STRONG]
   */
  public void setProperties(Properties props) {
    String refType = props.getProperty(&amp;quot;reference-type&amp;quot;);
    if (refType == null) {
      refType = props.getProperty(&amp;quot;referenceType&amp;quot;);
    }
    if (refType != null) {
      referenceType = MemoryCacheLevel.getByReferenceType(refType);
    }
  }

  public MemoryCacheLevel getReferenceType() {
    return referenceType;
  }

  public void setReferenceType(MemoryCacheLevel referenceType) {
    this.referenceType = referenceType;
  }

  /**
   * Add an object to the cache
   *
   * @param cacheModel The cacheModel
   * @param key        The key of the object to be cached
   * @param value      The object to be cached
   */
  public void putObject(CacheModel cacheModel, Object key, Object value) {
    Object reference = null;
    if (referenceType.equals(MemoryCacheLevel.WEAK)) {
      reference = new WeakReference(value);
    } else if (referenceType.equals(MemoryCacheLevel.SOFT)) {
      reference = new SoftReference(value);
    } else if (referenceType.equals(MemoryCacheLevel.STRONG)) {
      reference = new StrongReference(value);
    }
    cache.put(key, reference);
  }

  /**
   * Get an object out of the cache.
   *
   * @param cacheModel The cache model
   * @param key        The key of the object to be returned
   * @return The cached object (or null)
   */
  public Object getObject(CacheModel cacheModel, Object key) {
    Object value = null;
    Object ref = cache.get(key);
    if (ref != null) {
      if (ref instanceof StrongReference) {
        value = ((StrongReference) ref).get();
      } else if (ref instanceof SoftReference) {
        value = ((SoftReference) ref).get();
      } else if (ref instanceof WeakReference) {
        value = ((WeakReference) ref).get();
      }
    }
    return value;
  }

  public Object removeObject(CacheModel cacheModel, Object key) {
    Object value = null;
    Object ref = cache.remove(key);
    if (ref != null) {
      if (ref instanceof StrongReference) {
        value = ((StrongReference) ref).get();
      } else if (ref instanceof SoftReference) {
        value = ((SoftReference) ref).get();
      } else if (ref instanceof WeakReference) {
        value = ((WeakReference) ref).get();
      }
    }
    return value;
  }

  /**
   * Flushes the cache.
   *
   * @param cacheModel The cache model
   */
  public void flush(CacheModel cacheModel) {
    cache.clear();
  }

  /**
   * Class to implement a strong (permanent) reference.
   */
  private static class StrongReference {
    private Object object;

    /**
     * StrongReference constructor for an object
     * @param object - the Object to store
     */
    public StrongReference(Object object) {
      this.object = object;
    }

    /**
     * Getter to get the object stored in the StrongReference
     * @return - the stored Object
     */
    public Object get() {
      return object;
    }
  }

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于内存的MemoryCacheController用到了MemoryCacheLevel这个类。在MemoryCacheLevel中定义了三种对象的引用类型：strong，soft和weak。关于Java的引用类型，可以参考我在我以前写的一篇博文&lt;a href=&quot;http://liuxuan.info/2011/03/java-four-types-of-reference/&quot; title=&quot;Java的四种引用类型&quot;&gt;Java的四种引用类型&lt;/a&gt;。总的来说，MemoryCacheController的实现还是比较简单的，但要注意到MemoryCacheController里没有keyList，所以不存在FIFO和LRU中都有的那个两个集合不同步的bug。&lt;/p&gt;

&lt;p&gt;了解了缓存的实现之后，我们还要要搞清楚iBatis是什么时候把对象放到缓存中去的。其实根据常识，对象肯定是在第一次被从数据库中读取出来的时候存放到缓存中去的，接下去就来验证我们的猜想。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public CacheKey getCacheKey(StatementScope statementScope, Object parameterObject) {
    CacheKey key = statement.getCacheKey(statementScope, parameterObject);
    if (!cacheModel.isReadOnly() &amp;amp;&amp;amp; !cacheModel.isSerialize()) {
      key.update(statementScope.getSession());
    }
    return key;
  }
  
  public Object executeQueryForObject(StatementScope statementScope, Transaction trans, 
  	Object parameterObject, Object resultObject)throws SQLException {
  	
    CacheKey cacheKey = getCacheKey(statementScope, parameterObject);
    cacheKey.update(&amp;quot;executeQueryForObject&amp;quot;);
    Object object = cacheModel.getObject(cacheKey);
    if (object == CacheModel.NULL_OBJECT){
    	//	This was cached, but null
    	object = null;
    }else if (object == null) {
       object = statement.executeQueryForObject(statementScope, trans, parameterObject, resultObject);
       cacheModel.putObject(cacheKey, object);
    }
    return object;
  }

  public List executeQueryForList(StatementScope statementScope, Transaction trans, Object parameterObject, 
  	int skipResults, int maxResults)throws SQLException {
  	
    CacheKey cacheKey = getCacheKey(statementScope, parameterObject);
    cacheKey.update(&amp;quot;executeQueryForList&amp;quot;);
    cacheKey.update(skipResults);
    cacheKey.update(maxResults);
    Object listAsObject = cacheModel.getObject(cacheKey);
    List list;
    if(listAsObject == CacheModel.NULL_OBJECT){
      // The cached object was null
      list = null;
    }else if (listAsObject == null) {
      list = statement.executeQueryForList(statementScope, trans, parameterObject, skipResults, maxResults);
      cacheModel.putObject(cacheKey, list);
    }else{
      list = (List) listAsObject;
    }
    return list;
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到，在executeQueryForObject和executeQueryForList方法中，首先根据对象的key值到缓存中获取对象，如果没有找到对应的对象就通过调用下面的方法来把对象存放到缓存中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cacheModel.putObject(cacheKey, object);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们之前的猜想就得到了验证。我们再来看看缓存中对象对应的key是什么东西，定位到CacheModel类的putObject方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private CacheController controller;

 /**
   * Add an object to the cache
   *
   * @param key   The key of the object to be cached
   * @param value The object to be cached
   */
  public void putObject(CacheKey key, Object value) {
  	if (null == value) value = NULL_OBJECT;
  	synchronized ( this )  {
      if (serialize &amp;amp;&amp;amp; !readOnly &amp;amp;&amp;amp; value != NULL_OBJECT) {
        try {
          ByteArrayOutputStream bos = new ByteArrayOutputStream();
          ObjectOutputStream oos = new ObjectOutputStream(bos);
          oos.writeObject(value);
          oos.flush();
          oos.close();
          value = bos.toByteArray();
        } catch (IOException e) {
          throw new RuntimeException(&amp;quot;Error caching serializable object.  Cause: &amp;quot; + e, e);
        }
      }
      controller.putObject(this, key, value);
      if ( log.isDebugEnabled() )  {
        log(&amp;quot;stored object&amp;quot;, true, value);
      }
    }
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CacheModel类里的putObject方法又调用了CacheController的putObject方法，注意传入的key值是CacheKey对象，也就是说最后作为缓存中对象的key是它的CacheKey对象。不得不说这是一个失败的设计，key值的类型是String类型就已经足够了，完全没有必要用对象类型来做key值的类型。因为内存空间是有限的，要在有限的空间中尽可能地存放更多的内容，就需要key值在保证唯一性的情况下空间占的越小越好。&lt;/p&gt;

&lt;h2 id=&quot;mybatis&quot;&gt;myBatis&lt;/h2&gt;

&lt;h3 id=&quot;mybatiscache&quot;&gt;myBatis的cache包结构&lt;/h3&gt;

&lt;table border=&quot;1&quot; cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; summary=&quot;&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot; colspan=&quot;2&quot; style=&quot;background-color:#CCCCFF&quot;&gt;
&lt;b&gt;Packages&lt;/b&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.cache&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.cache.decorators&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.cache.impl&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;相比iBatis来说，myBatis的包结构变得更简洁，从五个包简化成了三个包。而且从实现方式上也有了改变，从decorators这样的包名可以猜到在这个包下的类都是装饰类，而实际上也是如此的。myBatis的缓存实现采用了装饰模式，impl包下实现的是缓存的基本功能，不同的缓存策略由decorators包下的类实现。&lt;/p&gt;

&lt;p&gt;相比iBatis，myBatis增加了多个缓存实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LoggingCache&lt;/li&gt;
  &lt;li&gt;ScheduledCache&lt;/li&gt;
  &lt;li&gt;SerializedCache&lt;/li&gt;
  &lt;li&gt;SynchronizedCache&lt;/li&gt;
  &lt;li&gt;TransactionalCache&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;源码分析&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public interface Cache {

  String getId();

  int getSize();

  void putObject(Object key, Object value);

  Object getObject(Object key);

  Object removeObject(Object key);

  void clear();

  ReadWriteLock getReadWriteLock();

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和iBatis不同，Cache接口中定义了concurrent包中的ReadWriteLock接口，而它只有一个实现类ReentrantReadWriteLock。对比iBatis使用同步的Map集合来解决解决并发读写时缓存数据的同步问题，myBatis则使用ReentrantReadWriteLock类的锁机制来防止在并发写过程中的线程安全问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Lru (first in, first out) cache decorator
 */
public class LruCache implements Cache {

  private final Cache delegate;
  private Map&amp;amp;lt;object , Object&amp;amp;gt; keyMap;
  private Object eldestKey;

  public LruCache(Cache delegate) {

    this.delegate = delegate;
    setSize(1024);

  }

  public String getId() {
    return delegate.getId();
  }

  public int getSize() {
    return delegate.getSize();
  }

  public void setSize(final int size) {
    keyMap = new LinkedHashMap&amp;amp;lt;object , Object&amp;amp;gt;(size, .75F, true) {
      private static final long serialVersionUID = 4267176411845948333L;
      protected boolean removeEldestEntry(Map.Entry&amp;amp;lt;object , Object&amp;amp;gt; eldest) {
        boolean tooBig = size() &amp;gt; size;
        if (tooBig) {
          eldestKey = eldest.getKey();
        }
        return tooBig;
      }
    };
  }

  public void putObject(Object key, Object value) {
    delegate.putObject(key, value);
    cycleKeyList(key);
  }

  public Object getObject(Object key) {
    keyMap.get(key); //touch
    return delegate.getObject(key);
  }

  public Object removeObject(Object key) {
    return delegate.removeObject(key);
  }

  public void clear() {
    delegate.clear();
    keyMap.clear();
  }

  public ReadWriteLock getReadWriteLock() {
    return delegate.getReadWriteLock();
  }

  private void cycleKeyList(Object key) {
    keyMap.put(key, key);
    if (eldestKey != null) {
      delegate.removeObject(eldestKey);
      eldestKey = null;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LRU是最常使用的缓存算法，所以就以LruCache为例，其他缓存实现也是差不多的。在iBatis里，key值是用一个同步的LinkedList来维护的，而myBatis则是改用LinkedHashMap来维护。这样做的好处就是解决了在iBatis中的HashMap和LinkedList的不同步问题，而且也不需要自己实现LRU，LinkedHashMap原生就支持LRU。&lt;/p&gt;

&lt;p&gt;缓存中的对象是存放在impl包下的PerpetualCache类的HashMap里的，所以各个缓存算法实现类里都需要持有一个PerpetualCache实例。当要从缓存中读取数据时，就委托给PerpetualCache类去执行读取方法，而这对于调用者来说是透明的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Configuration configuration;
  private Executor executor;

  private boolean autoCommit;
  private boolean dirty;

  public DefaultSqlSession(Configuration configuration, Executor executor, boolean autoCommit) {
    this.configuration = configuration;
    this.executor = executor;
    this.autoCommit = autoCommit;
    this.dirty = false;
  }

  public List selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      MappedStatement ms = configuration.getMappedStatement(statement);
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&amp;quot;Error querying database.  Cause: &amp;quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DefaultSqlSession在创建完成后就有了对应的Executor实例，查询就调用Executor实例的query方法。那DefaultSqlSession是在哪里被创建的呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final Configuration configuration;

  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level,   boolean autoCommit) {
    Connection connection = null;
    try {
      final Environment environment = configuration.getEnvironment();
      final DataSource dataSource = getDataSourceFromEnvironment(environment);
      TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
      connection = dataSource.getConnection();
      if (level != null) {
        connection.setTransactionIsolation(level.getLevel());
      }
      connection = wrapConnection(connection);
      Transaction tx = transactionFactory.newTransaction(connection, autoCommit);
      Executor executor = configuration.newExecutor(tx, execType);
      return new DefaultSqlSession(configuration, executor, autoCommit);
    } catch (Exception e) {
      closeConnection(connection);
      throw ExceptionFactory.wrapException(&amp;quot;Error opening session.  Cause: &amp;quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到DefaultSqlSession是在打开session时创建的，而且在创建DefaultSqlSession之前，通过调用了Configuration类的newExecutor方法创建相应的Executor实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
    executorType = executorType == null ? defaultExecutorType : executorType;
    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
    Executor executor;
    if (ExecutorType.BATCH == executorType) {
      executor = new BatchExecutor(this, transaction);
    } else if (ExecutorType.REUSE == executorType) {
      executor = new ReuseExecutor(this, transaction);
    } else {
      executor = new SimpleExecutor(this, transaction);
    }
    if (cacheEnabled) {
      executor = new CachingExecutor(executor);
    }
    executor = (Executor) interceptorChain.pluginAll(executor);
    return executor;
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码还是比较清晰地，通过读取配置文件里的内容来创建Executor实例。到这里为止，在DefaultSqlSession创建完成后就会持有相应的Executor实例，如果是配置了缓存，那么将会创建CachingExecutor。而且CachingExecutor类里将会持有下列Executor的其中一种：BatchExecutor，ReuseExecutor和SimpleExecutor。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CachingExecutor implements Executor {

  private Executor delegate;
  private TransactionalCacheManager tcm = new TransactionalCacheManager();

  public CachingExecutor(Executor delegate) {
    this.delegate = delegate;
  }

  public List query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    if (ms != null) {
      Cache cache = ms.getCache();
      if (cache != null) {
        flushCacheIfRequired(ms);
        cache.getReadWriteLock().readLock().lock();
        try {
          if (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == null) {
            CacheKey key = createCacheKey(ms, parameterObject, rowBounds);
            final List cachedList = (List) cache.getObject(key);
            if (cachedList != null) {
              return cachedList;
            } else {
              List list = delegate.query(ms, parameterObject, rowBounds, resultHandler);
              tcm.putObject(cache, key, list);
              return list;
            }
          } else {
            return delegate.query(ms, parameterObject, rowBounds, resultHandler);
          }
        } finally {
          cache.getReadWriteLock().readLock().unlock();
        }
      }
    }
    return delegate.query(ms, parameterObject, rowBounds, resultHandler);
  }

  public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds) {
    return delegate.createCacheKey(ms, parameterObject, rowBounds);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与iBatis最大的不同是，在从缓存中读取数据之前，要先获取读锁。读锁可以由多个读线程同时持有，而写线程同时只能有一个线程持有。但是读写锁会有一个饥渴写的问题，具体可以参考&lt;a href=&quot;http://en.wikipedia.org/wiki/Readers-writers_problem&quot; title=&quot;Readers-writers_problem&quot;&gt;读写锁的问题&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Executor类也是采用了装饰模式来实现，查询对象委托给持有的Executor类的实例来执行。如果缓存中没有，就交TransactionalCacheManager类来把对象存放到缓存中去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class TransactionalCacheManager {

  private Map&amp;amp;lt;cache , TransactionalCache&amp;amp;gt; transactionalCaches = new HashMap&amp;amp;lt;cache , TransactionalCache&amp;amp;gt;();

  public void clear(Cache cache) {
    getTransactionalCache(cache).clear();
  }

  public void putObject(Cache cache, CacheKey key, Object value) {
    getTransactionalCache(cache).putObject(key, value);
  }

  public void commit() {
    for (TransactionalCache txCache : transactionalCaches.values()) {
      txCache.commit();
    }
  }

  public void rollback() {
    for (TransactionalCache txCache : transactionalCaches.values()) {
      txCache.rollback();
    }
  }

  private TransactionalCache getTransactionalCache(Cache cache) {
    TransactionalCache txCache = transactionalCaches.get(cache);
    if (txCache == null) {
      txCache = new TransactionalCache(cache);
      transactionalCaches.put(cache, txCache);
    }
    return txCache;
  }

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次看到这个类的名字感觉有点奇怪，缓存相关的类怎么取了个事务的名字，后来读到TransactionalCache类后才明白原因。继续往下看，在TransactionalCacheManager中，最终还是用TransactionalCache类的put方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class TransactionalCache implements Cache {

  private Cache delegate;
  private boolean clearOnCommit;
  private Map&amp;amp;lt;object , AddEntry&amp;amp;gt; entriesToAddOnCommit;
  private Map&amp;amp;lt;object , RemoveEntry&amp;amp;gt; entriesToRemoveOnCommit;
  
  public void putObject(Object key, Object object) {
    entriesToRemoveOnCommit.remove(key);
    entriesToAddOnCommit.put(key, new AddEntry(delegate, key, object));
  }

  public Object removeObject(Object key) {
    entriesToAddOnCommit.remove(key);
    entriesToRemoveOnCommit.put(key, new RemoveEntry(delegate, key));
    return delegate.getObject(key);
  }

  public void commit() {
    delegate.getReadWriteLock().writeLock().lock();
    try {
      if (clearOnCommit) {
        delegate.clear();
      } else {
        for (RemoveEntry entry : entriesToRemoveOnCommit.values()) {
          entry.commit();
        }
      }
      for (AddEntry entry : entriesToAddOnCommit.values()) {
        entry.commit();
      }
      reset();
    } finally {
      delegate.getReadWriteLock().writeLock().unlock();
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到在TransactionalCache类里也维护着两个HashMap：entriesToAddOnCommit和entriesToRemoveOnCommit。当在TransactionalCacheManager中调用putObject和removeObject方法的时候并不是马上就把对象存放到缓存或者从缓存中删除，而是先把这个对象放到这两个HashMap之中的一个里，然后当执行commit方法时再真正地把对象存放到缓存或者从缓存中删除。现在我们应该可以明白为TransactionalCacheManager和TransactionalCache这两个类要加上事务的前缀了，因为commit方法是一个原子操作，一次会操作多个对象，要么一起成功，要么就一起失败。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;通过这次对iBatis以及myBatis的源码进行分析，发现他们的缓存在设计和实现上都存在一些问题。比如iBatis有两个集合不同步的问题，myBatis的读写锁有写饥渴问题等。这些问题都会给性能造成影响，所以还是不建议在生产环境中使用iBatis或者myBatis自带的二级缓存，只使用他们的ORM功能，而二级缓存还是交给Memcached来实现吧。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>iBatis和myBatis源码分析之日志</title>
   <link href="/blog/2011/08/26/ibatis-and-mybatis-source-code-analysis-logging/"/>
   <updated>2011-08-26T18:20:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/08/26/ibatis-and-mybatis-source-code-analysis-logging</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;包结构分析&lt;/h2&gt;

&lt;h3 id=&quot;ibatislogging&quot;&gt;iBatis的logging包结构&lt;/h3&gt;

&lt;table border=&quot;1&quot; width=&quot;100%&quot; cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; summary=&quot;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;
&lt;th align=&quot;left&quot; colspan=&quot;2&quot; style=&quot;background-color:#CCCCFF&quot;&gt;
&lt;b&gt;Packages&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.logging&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.logging.jakarta&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.logging.jdk14&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.logging.log4j&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.logging.nologging&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;iBatis把对logging支持的类全部放在了common包的子包下，并且又根据不同的logging实现又分成了commons-logging，jdk1.4自带的logging，log4j和nologging四个子包。个人感觉整个包的划分还是非常清晰的，但是nologging包的存在感觉有点鸡肋，因为日志是一个系统必备的功能之一，很难想象一个系统缺少了日志怎么做数据分析，性能调优等。难道作者认为有些时候或有一天就不需要日志了？&lt;/p&gt;

&lt;h3 id=&quot;mybatislogging&quot;&gt;myBatis的logging包结构&lt;/h3&gt;

&lt;table border=&quot;1&quot; width=&quot;100%&quot; cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; summary=&quot;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;
&lt;th align=&quot;left&quot; colspan=&quot;2&quot; style=&quot;background-color:#CCCCFF&quot;&gt;
&lt;b&gt;Packages&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.commons&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.jdbc&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.jdk14&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.log4j&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.nologging&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.slf4j&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.stdout&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;可以看到myBatis的logging包结构较之iBatis基本没变，但是增加了jdbc，slf4j以及stdout的支持。对jdbc执行sql语句的日志支持看上去很美好，但是给性能带来的影响比较大，这个等下面的源码分析再详细说明；增加对slf4j的支持应该是大势所趋没有问题；而增加对stdout的支持是一个很好的功能，在测试阶段应该会是一个很好的日志功能实现。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;源码分析&lt;/h2&gt;

&lt;h3 id=&quot;ibatis&quot;&gt;iBatis&lt;/h3&gt;

&lt;h4 id=&quot;log&quot;&gt;Log接口&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public interface Log {

  boolean isDebugEnabled();

  void error(String s, Throwable e);

  void error(String s);
  
  public void debug(String s);

  public void warn(String s);

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Log接口定义了三个log级别，所有的log实现都会去实现这个接口，所以它是所有log的代表。&lt;/p&gt;

&lt;h4 id=&quot;logfactory&quot;&gt;LogFactory工厂类&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public class LogFactory {

  private static Constructor logConstructor;

  static {
    tryImplementation(&amp;quot;org.apache.commons.logging.LogFactory&amp;quot;, &amp;quot;com.ibatis.common.logging.jakarta.JakartaCommonsLoggingImpl&amp;quot;);
    tryImplementation(&amp;quot;org.apache.log4j.Logger&amp;quot;, &amp;quot;com.ibatis.common.logging.log4j.Log4jImpl&amp;quot;);
    tryImplementation(&amp;quot;java.util.logging.Logger&amp;quot;, &amp;quot;com.ibatis.common.logging.jdk14.Jdk14LoggingImpl&amp;quot;);
    tryImplementation(&amp;quot;java.lang.Object&amp;quot;, &amp;quot;com.ibatis.common.logging.nologging.NoLoggingImpl&amp;quot;);
  }

  private static void tryImplementation(String testClassName, String implClassName) {
    if (logConstructor == null) {
      try {
        Resources.classForName(testClassName);
        Class implClass = Resources.classForName(implClassName);
        logConstructor = implClass.getConstructor(new Class[]{Class.class});
      } catch (Throwable t) {
      }
    }
  }

  public static Log getLog(Class aClass) {
    try {
      return (Log)logConstructor.newInstance(new Object[]{aClass});
    } catch (Throwable t) {
      throw new RuntimeException(&amp;quot;Error creating logger for class &amp;quot; + aClass + &amp;quot;.  Cause: &amp;quot; + t, t);
    }
  }

  public static synchronized void selectLog4JLogging() {
    try {
      Resources.classForName(&amp;quot;org.apache.log4j.Logger&amp;quot;);
      Class implClass = Resources.classForName(&amp;quot;com.ibatis.common.logging.log4j.Log4jImpl&amp;quot;);
      logConstructor = implClass.getConstructor(new Class[]{Class.class});
    } catch (Throwable t) {
    }
  }
  
  public static synchronized void selectJavaLogging() {
    try {
      Resources.classForName(&amp;quot;java.util.logging.Logger&amp;quot;);
      Class implClass = Resources.classForName(&amp;quot;com.ibatis.common.logging.jdk14.Jdk14LoggingImpl&amp;quot;);
      logConstructor = implClass.getConstructor(new Class[]{Class.class});
    } catch (Throwable t) {
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个工厂类里我们可以非常容易地感觉到“坏味道”，那就是在catch块中什么都不做，这是应该尽量避免出现的情况。在static块中会尝试依次加载所有的log实现类，这点也是值得商榷的。因为在一个系统中一般只使用一种日志实现，一次性加载所有的实现只会带来性能问题；还有一个问题就是是否需要动态切换日志实现的功能，至少我觉得这个功能也是个鸡肋。&lt;/p&gt;

&lt;h3 id=&quot;mybatis&quot;&gt;myBatis&lt;/h3&gt;

&lt;h4 id=&quot;logfactory-1&quot;&gt;LogFactory工厂类：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public class LogFactory {

  private static Constructor&amp;lt; ? extends Log&amp;gt; logConstructor;

  static {
    tryImplementation(new Runnable() {
      public void run() {
        useSlf4jLogging();
      }
    });
    tryImplementation(new Runnable() {
      public void run() {
        useCommonsLogging();
      }
    });
    tryImplementation(new Runnable() {
      public void run() {
        useLog4JLogging();
      }
    });
    tryImplementation(new Runnable() {
      public void run() {
        useJdkLogging();
      }
    });
    tryImplementation(new Runnable() {
      public void run() {
        useNoLogging();
      }
    });
  }

  public static Log getLog(Class&amp;lt; ?&amp;gt; aClass) {
    try {
      return logConstructor.newInstance(new Object[]{aClass});
    } catch (Throwable t) {
      throw new LogException(&amp;quot;Error creating logger for class &amp;quot; + aClass + &amp;quot;.  Cause: &amp;quot; + t, t);
    }
  }

  public static synchronized void useSlf4jLogging() {
    setImplementation(&amp;quot;org.apache.ibatis.logging.slf4j.Slf4jImpl&amp;quot;);
  }

  public static synchronized void useCommonsLogging() {
    setImplementation(&amp;quot;org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl&amp;quot;);
  }

  public static synchronized void useLog4JLogging() {
    setImplementation(&amp;quot;org.apache.ibatis.logging.log4j.Log4jImpl&amp;quot;);
  }

  public static synchronized void useJdkLogging() {
    setImplementation(&amp;quot;org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl&amp;quot;);
  }

  public static synchronized void useStdOutLogging() {
    setImplementation(&amp;quot;org.apache.ibatis.logging.stdout.StdOutImpl&amp;quot;);
  }

  public static synchronized void useNoLogging() {
    setImplementation(&amp;quot;org.apache.ibatis.logging.nologging.NoLoggingImpl&amp;quot;);
  }

  private static void tryImplementation(Runnable runnable) {
    if (logConstructor == null) {
      try {
        runnable.run();
      } catch (Throwable t) {
        //ignore
      }
    }
  }

  private static void setImplementation(String implClassName) {
    try {
      @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
      Class&amp;lt; ? extends Log&amp;gt; implClass = (Class&amp;lt; ? extends Log&amp;gt;) Resources.classForName(implClassName);
      Constructor&amp;lt; ? extends Log&amp;gt; candidate = implClass.getConstructor(new Class[]{Class.class});
      Log log = candidate.newInstance(new Object[]{LogFactory.class});
      log.debug(&amp;quot;Logging initialized using '&amp;quot; + implClassName + &amp;quot;' adapter.&amp;quot;);
      logConstructor = candidate;
    } catch (Throwable t) {
      throw new LogException(&amp;quot;Error setting Log implementation.  Cause: &amp;quot; + t, t);
    }
  }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在myBatis的实现里，除了加入了范型，多线程外没有什么太大的变化。还是要加载所有的log实现类，但是更大的问题是加载方法用synchronized来修饰了，且不论是否有必要全部加载，但就全部的同步方法就会给性能造成负面影响；而且在iBatis中的“坏味道”依旧存在。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;在这篇博文里比较了iBatis和myBatis的log实现，发现了存在“坏味道”，即在catch块中什么事都没做，这种情况应该避免发生；还有一次性加载所有的log实现类以及动态切换log实现都是不太常用的功能，如果要用iBatis或myBatis的log实现的话需要修改源代码来提高性能。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>iBatis和myBatis源码分析之概览</title>
   <link href="/blog/2011/08/24/ibatis-and-mybatis-source-code-analysis-overview/"/>
   <updated>2011-08-24T18:08:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/08/24/ibatis-and-mybatis-source-code-analysis-overview</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;写在最前&lt;/h2&gt;

&lt;p&gt;记得第一次知道&lt;a href=&quot;http://ibatis.apache.org/&quot; title=&quot;iBatis&quot;&gt;iBatis&lt;/a&gt;这个框架还是在2、3年前，那段时间Hibernate风头正劲，Java EE开发已经被概括为SSH，各个软件公司把Hibernate作为Java程序员一种标配的技能而来考核。正是在这样一种情况下，iBatis作为与Hibernate不同的ORM思想的实现，仍然被一部分开发者喜爱和支持，当然我也是其中之一。而且在一个偶然的机会让我知道原来淘宝的ORM工具也是用的iBatis后，就更加坚定了我对iBatis的信心(可能是因为Rails的关系，现在我觉得&lt;a href=&quot;http://www.springsource.org/roo&quot; title=&quot;Spring Roo&quot;&gt;Spring Roo&lt;/a&gt;会更有前途)。&lt;/p&gt;

&lt;p&gt;其实当初我开始学习Hibernate的时候就感觉非常的复杂，基本上大部分时间都是花在学习怎么编写hbm.xml映射文件上的。Hibernate文档中的配置说明又非常得多，对于数据库表的各种关系的映射配置都在文档中有着比较详细的描述，整个文档有好几百页长。所以，当时我就觉得这也有点太复杂了，如果一个表有很多字段，并且这个表与其他多个表之间有着复杂的关系，那么编写hbm.xml文件将会是一件苦不堪言的工作。更有甚者，编写完了映射关系还不算完，还要配置字段的属性，而字段属性数量繁多，足以让你在其中摸不着头脑，非常蛋疼。&lt;/p&gt;

&lt;p&gt;我并不是说Hibernate不好，因为好与不好是相对的。个人觉得Hibernate在Java企业级开发中还是非常有市场的，毕竟Hibernate已经非常成熟，会使用Hibernate的开发人员也多。但是，在商业网站开发领域，随着对性能的要求不断增加或者说苛刻的地步，数据库端的查询已经基本上放弃了多表之间的join操作以求达到比较理想的性能要求。在这样一个趋势下，Hibernate的作用就不大了。而且hql不利于优化的缺点对于数据库优化来说将成为性能瓶颈所在。对于商业网站而言，Java不能满足快速迭代开发的要求，越来越多的Web2.0网站采用PHP、Ruby或者Python作为开发语言，这也是我为什么觉得Spring Roo更有前途的原因。&lt;/p&gt;

&lt;p&gt;不管怎样，Hibernate和iBatis是Java EE平台上非常优秀的ORM框架。但是对我而言，iBatis更轻量，对SQL的映射更符合我的理念，所以就趁现在有时间就来分析一下iBatis的源码。而就在去年，iBatis已经改名为&lt;a href=&quot;http://www.mybatis.org&quot; title=&quot;myBatis&quot;&gt;myBatis&lt;/a&gt;，我决定在分析源码的同时对这两个版本做一个比较。但是并不只是分析源码，其中还会加入对JDK源码的分析以及依赖的第三方框架的分析，我希望这次的分析是一个非常细致的分析系列。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;概览&lt;/h2&gt;

&lt;p&gt;这篇博文是iBatis/myBatis源码分析系列的第一篇，我想首先来对iBatis和myBatis的整个结构做一个概览。首先来看一下iBatis的包结构(版本为2.3.4.726)：&lt;/p&gt;

&lt;table border=&quot;1&quot; width=&quot;100%&quot; cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; summary=&quot;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;
&lt;th align=&quot;left&quot; colspan=&quot;2&quot; style=&quot;background-color:#CCCCFF&quot;&gt;
&lt;b&gt;Packages&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.beans&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.io&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.jdbc&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.jdbc.exception&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.jdbc.logging&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.logging&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.logging.jakarta&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.logging.jdk14&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.logging.log4j&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.logging.nologging&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.resources&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.util&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.common.xml&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.client&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;This package contains the core library client interface.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.client.event&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;This package contains event handler interfaces.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.client.extensions&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.accessplan&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.builder.xml&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.cache&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.cache.fifo&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.cache.lru&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.cache.memory&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.cache.oscache&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.config&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.datasource&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.exchange&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.execution&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.impl&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.parameter&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.result&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.result.loader&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql.dynamic&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql.dynamic.elements&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql.raw&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql.simple&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.sql.stat&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.mapping.statement&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.scope&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.transaction&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.transaction.external&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.transaction.jdbc&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.transaction.jta&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.transaction.user&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;com.ibatis.sqlmap.engine.type&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;我们可以看到，iBatis整个包结构非常的简单，一目了然。仔细观察后可以说就分为两大部分：&lt;strong&gt;common&lt;/strong&gt;和&lt;strong&gt;sqlmap&lt;/strong&gt;。common包中包括了除了iBatis核心包之外的所有工具类包；而sqlmap包则是整个iBatis的核心包的所在，它又是由两部分组成：&lt;strong&gt;client&lt;/strong&gt;和&lt;strong&gt;engine&lt;/strong&gt;。client包是操作CRUD的对象所在的包，engine包则是iBatis用来处理映射关系的核心包。&lt;/p&gt;

&lt;p&gt;再来看myBatis的包结构(版本为3.05)：&lt;/p&gt;

&lt;table border=&quot;1&quot; width=&quot;100%&quot; cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; summary=&quot;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;
&lt;th align=&quot;left&quot; colspan=&quot;2&quot; style=&quot;background-color:#CCCCFF&quot;&gt;
&lt;b&gt;Packages&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.annotations&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.binding&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.builder&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.builder.annotation&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.builder.xml&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.builder.xml.dynamic&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.cache&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.cache.decorators&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.cache.impl&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.datasource&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.datasource.jndi&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.datasource.pooled&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.datasource.unpooled&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.exceptions&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.executor&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.executor.keygen&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.executor.loader&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.executor.parameter&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.executor.result&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.executor.resultset&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.executor.statement&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.io&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.jdbc&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.commons&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.jdbc&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.jdk14&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.log4j&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.nologging&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.slf4j&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.logging.stdout&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.mapping&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.metadata&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.migration&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.migration.commands&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.parsing&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.plugin&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.reflection&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.reflection.factory&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.reflection.invoker&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.reflection.property&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.reflection.wrapper&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.session&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.session.defaults&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.transaction&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.transaction.jdbc&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.transaction.managed&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;white&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;&lt;b&gt;org.apache.ibatis.type&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;我们可以看到在myBatis的包结构中，各个独立的功能被抽取出来单独成为一了个包，可以说是细化了整个框架的功能分类，较之iBatis整个包结构也更加清晰。除了包结构的变化，我们还可以看到在myBatis中加入了一些新的特性,比如增加了对annotation的支持，日志增加了对slf4j的支持等。&lt;/p&gt;

&lt;p&gt;整个概览就到这里，在接下来的一系列博文里将详细地分析各个包已经类和方法的作用。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>在VPS上安装网络流量监控工具vnStat</title>
   <link href="/blog/2011/08/22/install-vnstat-on-vps/"/>
   <updated>2011-08-22T18:04:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/08/22/install-vnstat-on-vps</id>
   <content type="html">&lt;p&gt;用上VPS以后博客的访问速度是比以前快了很多，但是也有烦心的事，就是担心每个月的流量有没有超标。你可以通过VPS提供给你的Control Panel的地址登录，然后查看流量数据。但是这种方法始终有点复杂，最好有种直接输入一个URL就能查看流量数据的方法。在Google上搜索了一会儿之后，终于找到了一个好工具：&lt;a href=&quot;http://humdi.net/vnstat/&quot; title=&quot;vnStat&quot;&gt;vnStat&lt;/a&gt;。 &lt;/p&gt;

&lt;p&gt;vnStat是Linux和BSD平台上基于控制台的网络流量监控工具。它使用的是Linux内核提供的网络接口统计作为信息源。vnStat不会嗅探网络并且保证占系统资源少，需要注意的是内核版本要在2.2之上。&lt;/p&gt;

&lt;p&gt;vnStat只是一个基于控制台的工具，我们还需要安装一个它的PHP扩展&lt;a href=&quot;href=&amp;quot;http://www.sqweek.com/sqweek/index.php?p=1&quot; title=&quot;vnStat PHP frontend&quot;&gt;vnStat PHP frontend&lt;/a&gt;，那么我们就能直接通过流量器来查看流量数据了。&lt;/p&gt;

&lt;h2 id=&quot;vnstat&quot;&gt;安装vnStat&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;wget http://humdi.net/vnstat/vnstat-1.11.tar.gz
tar zxvf vnstat-1.11.tar.gz
cd vnstat-1.11
make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vnstat-php-frontend&quot;&gt;安装vnStat PHP frontend&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;wget http://www.sqweek.com/sqweek/files/vnstat_php_frontend-1.5.1.tar.gz
cp -r vnstat_php_frontend-1.5.1 /path/to/nginx/vnstat&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以通过访问http://www.yourdomain.com/vnstat，应该就可以看到流量数据页面了，但是现在还没有数据，接下来我们来给系统生成数据。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;建立流量数据库&lt;/h2&gt;

&lt;p&gt;首先查看你是哪种外网网卡：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifconfig    #Xen一般是eth0；OpenVZ一般是venet0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后生成数据库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/vnstat -u -i venet0  #因为我的VPS是基于OpenVZ的，所以就是venet0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置通过cron的方式定时更新数据库,编辑/etc/cron.d/vnstat文件，加入下面的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0-55/5 * * * *   root   vnstat -u -i venet0
0-55/5 * * * *   root   vnstat --dumpdb -i venet0 &amp;gt;/var/lib/vnstat/vnstat_dump_venet0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：第二行是为了更新venet0的数据后，dump出来一个文件提供给PHP访问.这里dump出来的vnstat_dump_venet0文件名是有规定的。&lt;/p&gt;

&lt;p&gt;修改配置文件，编辑/path/to/nginx/vnstat/config.php&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$language = 'en';
$iface_list = array('venet0');
$iface_title['venet0'] = 'VPS';
$data_dir = '/var/lib/vnstat/';
$graph_format='png';&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里安装就都完成了，就这么简单。现在访问www.yourdomain.com/vnstat就会发现有流量统计了,统计数据更新是５分钟刷新一次。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>在VPS上安装dropbear,vsftp和pptpd</title>
   <link href="/blog/2011/08/21/install-dropbear-vsftp-pptpd-on-vps/"/>
   <updated>2011-08-21T17:31:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/08/21/install-dropbear-vsftp-pptpd-on-vps</id>
   <content type="html">&lt;h2 id=&quot;dropbear&quot;&gt;安装Dropbear&lt;/h2&gt;

&lt;p&gt;首先修改OpenSSH的端口,编辑 /etc/ssh/sshd_config 文件，找到 Port 22 这一行，并修改为 Port 2222。&lt;/p&gt;

&lt;p&gt;然后重启OpenSSH：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service sshd restart&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译安装Dropbear:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /data/software
wget http://matt.ucc.asn.au/dropbear/dropbear-0.53.1.tar.gz
tar -zxvf dropbear-0.53.1.tar.gz
cd dropbear-0.53.1
./configure
make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成公钥：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /etc/dropbear
/usr/local/bin/dropbearkey -t dss -f /etc/dropbear/dropbear_dss_host_key
/usr/local/bin/dropbearkey -t rsa -s 4096 -f /etc/dropbear/dropbear_rsa_host_key&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动Dropbear：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/sbin/dropbear start&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置开机自动启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chkconfig --add dropbear
chkconfig dropbear on&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dropbear正确安装完成后，如果能够用ssh登录，那么就可以删除OpenSSH了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum remove openssh&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vsftp&quot;&gt;安装vsftp&lt;/h2&gt;

&lt;p&gt;如果编译安装的话会报错，要自己手动复制文件，所以我就从软件库自动安装了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install vsftpd&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建FTP用户：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/sbin/groupadd ftp
/usr/sbin/useradd -g ftp ftp&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立FTP默认目录:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /var/ftp&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设定FTP的home目录为/var/ftp：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;useradd -d /var/ftp -s /sbin/nologin ftp&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设定home目录所有者和权限:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chown ftp:ftp /var/ftp
chmod 755 /var/ftp&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑vsftp配置文件 /etc/vsftpd/vsftpd.conf，修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;anonymous_enable=no
listen=yes

#并在文件末尾添加：
local_root=/var/ftp/pub
use_localtime=yes
connect_timeout=60
accept_timeout=60
max_clients=10
max_per_ip=10&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置开机自动启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chkconfig --add vsftpd
chkconfig vsftpd on&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;pptpd&quot;&gt;安装pptpd&lt;/h2&gt;

&lt;p&gt;首先用ssh登录VPS，检查VPS是否有必要的支持，否则将导致无法安装(如果是buyvm的VPS可以跳过这步)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;modprobe ppp-compress-18 &amp;amp;&amp;amp; echo ok&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用模块方式支持MPPE加密模式浏览，如果内核支持则检测不到。如果显示“ok”表明通过，不过还需要做另一个检查：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /dev/net/tun&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果显示结果为下面的文本就表明通过：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat: /dev/net/tun: File descriptor in bad state&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述两条检测只需一条通过，即可安装pptpd。如果还有其他问题，就提Ticket给服务商替你解决。&lt;/p&gt;

&lt;p&gt;安装ppp：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -ivh http://poptop.sourceforge.net/yum/stable/rhel6/i386/ppp-2.4.5-17.0.rhel6.i686.rpm&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装pptpd:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -ivh http://poptop.sourceforge.net/yum/stable/rhel6/i386/pptpd-1.3.4-2.el6.i686.rpm&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置pptpd:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/pptpd.conf&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把下面字段前面的#去掉即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;localip 192.168.0.1
remoteip 192.168.0.234-238,192.168.0.245&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来再编辑 /etc/ppp/options.pptpd 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/ppp/options.pptpd&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去掉 ms-dns 前面的#，并修改成如下字段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ms-dns 8.8.8.8
ms-dns 8.8.4.4&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置pptpd账号和密码：&lt;/p&gt;

&lt;p&gt;编辑 /etc/ppp/chap-secrets 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/ppp/chap-secrets&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接输入如下字段,username和password就是你要登录VPN的用户名和密码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;username pptpd password *&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改内核设置，使其支持转发:&lt;/p&gt;

&lt;p&gt;编辑 /etc/sysctl.conf 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/sysctl.conf&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;做下面的修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net.ipv4.ip_forward=1
net.ipv4.tcp_syncookies = 1  #注释这行&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存退出，并执行下面的命令来使它生效：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sysctl -p&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加iptables转发规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT --to-source xxx.xxx.xxx.xxx  #xxx.xxx.xxx.xxx为你的VPS的公网IP地址&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存iptables转发规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/init.d/iptables save&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启iptables：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/init.d/iptables restart&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启pptpd服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/init.d/pptpd restart&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置开机自动启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chkconfig --add pptpd
chkconfig pptpd on&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>在VPS上搭建LNMP(Linux/Nginx/MySQL/PHP)</title>
   <link href="/blog/2011/08/20/setup-lnmp-on-vps/"/>
   <updated>2011-08-20T17:12:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/08/20/setup-lnmp-on-vps</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;写在最前&lt;/h2&gt;

&lt;p&gt;从我开博到现在也有半年有余了，之前一直是放在一个共享空间里。当初选择共享空间主要是因为价格便宜，而且我只在空间里放一个WordPress，不需要很大的空间和流量。但是在这半年多时间里，这个空间经常出现响应速度变得很慢，FTP和CPANEL无法登录等问题，真让我的忍耐到达了极点；再加上我们不知道什么原因访问一些网站经常返回错误页面，所以我决定抛弃这个空间(一年的时间还没到，浪费劳资的钱啊。。。)，转投VPS的怀抱。&lt;/p&gt;

&lt;p&gt;其实在几年之前就知道VPS这样东西了，但是真正当我要去搞一个的时候，却发现有太多的选择。经过一番思想斗争，我最终选择了&lt;a href=&quot;http://buyvm.net/&quot; title=&quot;buyvm&quot;&gt;BuyVM&lt;/a&gt;这个VPS。如果你要问我为什么选择这个VPS，我想有三个原因：1.便宜 2.便宜 3.还是便宜。谁不想要被称为最好的VPS之称的&lt;a href=&quot;http://www.linode.com/&quot; title=&quot;Linode&quot;&gt;Linode&lt;/a&gt;啊，但是穷逼只能捡便宜的用。当然，并不是便宜的就不好，buyvm的VPS虽然便宜，质量和服务也是非常好的，并且它还在&lt;a href=&quot;http://www.lowendbox.com&quot; title=&quot;lowendbox&quot;&gt;lowendbox&lt;/a&gt;的评选中获得过第三名的好成绩。&lt;/p&gt;

&lt;p&gt;重要的来了，你需要搞清楚在VPS上放些什么东西，因为这关系着你选OpenVZ还是Xen。提前告知一下：&lt;strong&gt;如果你想在VPS上装L2TP/IPSec VPN的话，就不要选OpenVZ&lt;/strong&gt;。以我的经验来看，OpenVZ还是有很多限制的，如果手头宽裕的话还是首选Xen吧。好了，扯蛋完毕，开工搭建。&lt;/p&gt;

&lt;h2 id=&quot;lnmpdropbearvsftp&quot;&gt;安装LNMP+Dropbear+vsFTP&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;本次搭建必要的是：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1台VPS&lt;/li&gt;
  &lt;li&gt;CentOS操作系统(我的是CentOS 5.6，其他Linux发行版应该差不多)&lt;/li&gt;
  &lt;li&gt;能够以root权限从SSH登录&lt;/li&gt;
  &lt;li&gt;有足够的耐心和时间，因为接下来的工作还是蛮多的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;安装必要的软件包&lt;/h3&gt;

&lt;p&gt;首先以root权限从SSH登录，然后运行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;homesoftware&quot;&gt;在home目录新建一个software目录用来存放这次搭建所需的软件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd ~
mkdir software
cd software&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后下载我们需要的软件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://nginx.org/download/nginx-1.0.5.tar.gz
wget http://www.php.net/get/php-5.3.7.tar.gz/from/a/mirror
wget http://dev.mysql.com/downloads/mirror.php?id=403104#mirrors
wget http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gz
wget http://sourceforge.net/projects/mcrypt/files/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.bz2/download
wget http://sourceforge.net/projects/mcrypt/files/MCrypt/2.6.8/mcrypt-2.6.8.tar.gz/download
wget http://pecl.php.net/get/memcache-3.0.6.tgz
wget http://sourceforge.net/projects/mhash/files/mhash/0.9.9.9/mhash-0.9.9.9.tar.gz/download
wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/
wget http://pecl.php.net/get/APC-3.1.9.tgz
wget http://pecl.php.net/get/PDO_MYSQL-1.0.2.tgz
wget ftp://ftp.imagemagick.org/pub/ImageMagick/ImageMagick.tar.gz
wget http://pecl.php.net/get/imagick-3.0.1.tgz&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mysql&quot;&gt;编译安装MySQL&lt;/h3&gt;

&lt;p&gt;首先添加mysql用户组和用户：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/sbin/groupadd mysql
/usr/sbin/useradd -g mysql mysql&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译安装mysql：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf mysql-5.1.58.tar.gz
cd mysql-5.1.58
./configure --prefix=/usr/local/webserver/mysql/ --localstatedir=/usr/webserver/local/mysql/data --with-unix-socket-path=/tmp/mysql.sock --with-charset=utf8 --with-collation=utf8_general_ci --enable-assembler --with-extra-charsets=complex --enable-thread-safe-client --with-big-tables --with-readline --with-ssl --with-embedded-server --enable-local-infile --with-client-ldflags=-all-static --with-mysqld-ldflags=-all-static --with-plugins=partition,innobase,myisammrg
make &amp;amp;&amp;amp; make install
cp support-files/my-medium.cnf /usr/local/webserver/mysql/my.cnf&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;赋予mysql权限：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod +w /usr/local/webserver/mysql
chown -R mysql:mysql /usr/local/webserver/mysql&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以mysql用户建立数据库表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/webserver/mysql/bin/mysql_install_db --basedir=/usr/local/webserver/mysql --datadir=/usr/local/webserver/mysql/data --user=mysql&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改mysql的配置文件为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[client]
character-set-server = utf8
port		= 3306
socket		= /tmp/mysql.sock

[mysqld]
character-set-server = utf8
port		= 3306
socket		= /tmp/mysql.sock
skip-locking
key_buffer_size = 16M
max_allowed_packet = 16M
table_open_cache = 64
sort_buffer_size = 128K
net_buffer_length = 8K
read_buffer_size = 256K
read_rnd_buffer_size = 512K
myisam_sort_buffer_size = 8M

basedir = /usr/local/webserver/mysql
datadir = /usr/local/webserver/mysql/data
open_files_limit = 600
back_log = 20
max_connections = 100
max_connect_errors = 200
table_cache = 60
external-locking = FALSE
join_buffer_size = 128K
thread_cache_size = 10
thread_concurrency = 8
query_cache_size = 0M
query_cache_limit = 2M
query_cache_min_res_unit = 2k
default_table_type = MyISAM
thread_stack = 192K
tmp_table_size = 512K
max_heap_table_size = 32M
long_query_time = 1
log_long_format
binlog_cache_size = 2M
max_binlog_cache_size = 4M
max_binlog_size = 512M
expire_logs_days = 7

[myisamchk]
key_buffer_size = 4M
sort_buffer_size = 1M
read_buffer = 2M
write_buffer = 2M

read_rnd_buffer_size = 2M
bulk_insert_buffer_size = 2M
myisam_sort_buffer_size = 4M
myisam_max_sort_file_size = 10G
myisam_max_extra_sort_file_size = 10G
myisam_repair_threads = 1
myisam_recover&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个脚本，方便管理mysql：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /usr/local/webserver/mysql/mysql&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在其中添加下面的脚本命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\#!/bin/sh

function_start_mysql()
{
   printf &amp;quot;Starting MySQL...\n&amp;quot;
   /bin/sh /usr/local/webserver/mysql/bin/mysqld_safe --defaults-file=/usr/local/webserver/mysql/my.cnf &amp;amp;
}

function_stop_mysql()
{
   printf &amp;quot;Stopping MySQL...\n&amp;quot;
   /usr/local/webserver/mysql/bin/mysqladmin -u mysql -pmysql shutdown
}

function_restart_mysql()
{
   printf &amp;quot;Restarting MySQL...\n&amp;quot;
   function_stop_mysql
   sleep 5
   function_start_mysql
}

function_kill_mysql()
{
   kill -9 $(ps -ef | grep 'bin/mysqld_safe' | grep 3306 | awk '{printf $2}')
   kill -9 $(ps -ef | grep 'libexec/mysqld' | grep 3306 | awk '{printf $2}')
}

if [ &amp;quot;$1&amp;quot; = &amp;quot;start&amp;quot; ]; then
function_start_mysql
elif [ &amp;quot;$1&amp;quot; = &amp;quot;stop&amp;quot; ]; then
function_stop_mysql
elif [ &amp;quot;$1&amp;quot; = &amp;quot;restart&amp;quot; ]; then
function_restart_mysql
elif [ &amp;quot;$1&amp;quot; = &amp;quot;kill&amp;quot; ]; then
function_kill_mysql
else
printf &amp;quot;Usage: /usr/local/webserver/mysql {start|stop|restart|kill}\n&amp;quot;
fi&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后赋予脚本执行权限：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod +x /usr/local/webserver/mysql/mysql&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动mysql：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/webserver/mysql/mysql start&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给mysql用户赋予数据库的所有权限：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GRANT ALL PRIVILEGES ON *.* TO 'mysql'@'localhost' IDENTIFIED BY 'mysql';
GRANT ALL PRIVILEGES ON *.* TO 'mysql'@'127.0.0.1' IDENTIFIED BY 'mysql';&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置开机自启动mysql：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/rc.local
/usr/local/webserver/mysql/bin/mysqld_safe --defaults-file=/usr/local/webserver/mysql/my.cnf &amp;amp;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;php&quot;&gt;编译安装PHP&lt;/h2&gt;

&lt;p&gt;首先创建一个用户和组(用来管理PHP/Nginx/Wordpress)
创建用户和组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;groupadd www
useradd -g www www
mkdir -p /data/htdocs/blog  //blog目录是Wordpress的根目录
chmod +w /data/htdocs/blog
chown -R www:www /data/htdocs/blog&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译安装PHP所需的支持库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf libiconv-1.14.tar.gz
cd libiconv-1.13.1/
./configure --prefix=/usr/local
make &amp;amp;&amp;amp; make install

tar zxvf libmcrypt-2.5.8.tar.gz
cd libmcrypt-2.5.8/
./configure
make &amp;amp;&amp;amp; make install
/sbin/ldconfig
cd libltdl
./configure --enable-ltdl-install
make &amp;amp;&amp;amp; make install

tar zxvf mhash-0.9.9.9.tar.gz
cd mhash-0.9.9.9/
./configure
make &amp;amp;&amp;amp; make install

tar zxvf mcrypt-2.6.8.tar.gz
cd mcrypt-2.6.8/
/sbin/ldconfig
./configure
make &amp;amp;&amp;amp; make install

ln -s /usr/local/lib/libmcrypt.la /usr/lib/libmcrypt.la
ln -s /usr/local/lib/libmcrypt.so /usr/lib/libmcrypt.so
ln -s /usr/local/lib/libmcrypt.so.4 /usr/lib/libmcrypt.so.4
ln -s /usr/local/lib/libmcrypt.so.4.4.8 /usr/lib/libmcrypt.so.4.4.8
ln -s /usr/local/lib/libmhash.a /usr/lib/libmhash.a
ln -s /usr/local/lib/libmhash.la /usr/lib/libmhash.la
ln -s /usr/local/lib/libmhash.so /usr/lib/libmhash.so
ln -s /usr/local/lib/libmhash.so.2 /usr/lib/libmhash.so.2
ln -s /usr/local/lib/libmhash.so.2.0.1 /usr/lib/libmhash.so.2.0.1
ln -s /usr/local/bin/libmcrypt-config /usr/bin/libmcrypt-config&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf php-5.3.7.tar.gz
cd php-5.3.7
./configure --prefix=/usr/local/webserver/php --with-config-file-path=/usr/local/webserver/php/etc --with-mysql=/usr/local/webserver/mysql --with-mysqli=/usr/local/webserver/mysql/bin/mysql_config --with-iconv-dir=/usr/local --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath  --enable-safe-mode --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --with-curlwrappers --enable-mbregex  --enable-fpm  --enable-mbstring --with-mcrypt --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-ldap --with-ldap-sasl --with-xmlrpc --enable-ftp --enable-zip --enable-exif --enable-soap --without-pear --with-fpm-user=www --with-fpm-group=www
make ZEND_EXTRA_LIBS='-liconv'&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果遇到下面的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/root/source/php-5.3.7/sapi/cli/php: error while loading shared libraries: libmysqlclient.so.18: cannot open shared object file: No such file or directory
make: *** [ext/phar/phar.php] Error 127&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s /usr/local/webserver/mysql/lib/libmysqlclient.so.18 /usr/lib/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make install
cp php.ini-production /usr/local/webserver/php/etc/php.ini&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装PHP扩展包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf memcache-3.0.6.tgz
cd memcache-3.0.6
/usr/local/webserver/php/bin/phpize
./configure --with-php-config=/usr/local/webserver/php/bin/php-config
make &amp;amp;&amp;amp; make install

tar jxvf APC-3.1.9.tgz
cd APC-3.1.9
/usr/local/webserver/php/bin/phpize
./configure --with-php-config=/usr/local/webserver/php/bin/php-config --prefix=/usr/local/webserver/ --enable-apc --enable-apc-mmap --enable-apc-spinlocks
make &amp;amp;&amp;amp; make install

tar zxvf PDO_MYSQL-1.0.2.tgz
cd PDO_MYSQL-1.0.2
/usr/local/webserver/php/bin/phpize
./configure --with-php-config=/usr/local/webserver/php/bin/php-config --with-pdo-mysql=/usr/local/webserver/mysql
make &amp;amp;&amp;amp; make install

tar zxvf ImageMagick.tar.gz
cd ImageMagick-6.7.1-7
./configure
make &amp;amp;&amp;amp; make install

tar zxvf imagick-3.0.1.tgz
cd imagick-3.0.1
/usr/local/webserver/php/bin/phpize
./configure --with-php-config=/usr/local/webserver/php/bin/php-config
make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改php.ini文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;output_buffering = On
cgi.fix_pathinfo = 0

extension_dir = &amp;quot;/usr/local/webserver/php/lib/php/extensions/no-debug-non-zts-20090626/&amp;quot;

//并在此行后增加以下几行
extension = &amp;quot;memcache.so&amp;quot;
extension = &amp;quot;pdo_mysql.so&amp;quot;
extension = &amp;quot;imagick.so&amp;quot;

[APC]
apc.enabled = 1
apc.shm_segments = 1
apc.shm_size = 8M
apc.ttl = 7200
apc.user_ttl = 7200
apc.optimization = 1
apc.num_files_hint = 1024
apc.mmap_file_mask =/tmp/apc.XXXXXX 
apc.enable_cli = 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开php-fpm.conf文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /usr/local/webserver/php/etc/php-fpm.conf&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改添加如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pm.max_children = 1
pid = run/php-fpm.pid
error_log = log/php-fpm.log
log_level = notice
emergency_restart_threshold :10
emergency_restart_interval:1m
process_control_timeout:5s
daemonize:yes

backlog:-1
listen.owner = www
listen.group = www
listen.mode = 0666
user = www
group = www
pm = static
request_terminate_timeout = 0
request_slowlog_timeout = 0s
slowlog = log/$pool.log.slow
rlimit_files = 51200
rlimit_core = 0
catch_workers_output = yes
pm.max_requests = 500
listen.allowed_clients = 127.0.0.1
env[HOSTNAME] = $HOSTNAME
env[PATH] = /usr/local/bin:/usr/bin:/bin
env[TMP] = /tmp
env[TMPDIR] = /tmp
env[TEMP] = /tmp
env[OSTYPE] = $OSTYPE
env[MACHTYPE] = $MACHTYPE
env[MALLOC_CHECK_] = 2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动php-fpm：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/webserver/php/sbin/php-fpm&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置开机自动启动php-fpm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/rc.local
/usr/local/webserver/php/sbin/php-fpm&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;nginx&quot;&gt;编译安装Nginx&lt;/h2&gt;

&lt;p&gt;首先编译安装Nginx所需的pcre库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf pcre-8.12.tar.gz
cd pcre-8.12
./configure
make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译安装Nginx:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf nginx-1.0.5.tar.gz
cd nginx-1.0.5
./configure --user=www --group=www --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module
make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建Nginx日志目录:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p /data/log
chmod +w /data/log
chown -R www:www /data/log&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改Nginx配置文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user  www www;

worker_processes 1;

error_log  /data/log/nginx_error.log  crit;

pid        /usr/local/webserver/nginx/nginx.pid;

#Specifies the value for maximum file descriptors that can be opened by this process.
worker_rlimit_nofile 65535;

events
{
  use epoll;
  worker_connections 65535;
}

http
{
  include       mime.types;
  default_type  application/octet-stream;

  #charset  gb2312;
      
  server_names_hash_bucket_size 128;
  large_client_header_buffers 4 32k;
  client_header_buffer_size 32k; 
  client_max_body_size 8m;
      
  sendfile on;
  keepalive_timeout 10 10;
  tcp_nopush on;
  tcp_nodelay on;

  fastcgi_connect_timeout 300;
  fastcgi_send_timeout 300;
  fastcgi_read_timeout 300;
  fastcgi_buffer_size 32k;
  fastcgi_buffers 4 32k;
  fastcgi_busy_buffers_size 32k;
  fastcgi_temp_file_write_size 32k;
  fastcgi_intercept_errors on;

  gzip on;
  gzip_min_length  1k;
  gzip_buffers     4 16k;
  gzip_http_version 1.0;
  gzip_comp_level 1;
  gzip_types       text/plain application/x-javascript text/css application/xml;
  gzip_vary on;

  #limit_zone  crawler  $binary_remote_addr  10m;
  

  server
  {
    listen       80;
    server_name  liuxuan.info www.liuxuan.info;
    index index.html index.htm index.php;
    root  /data/htdocs/blog;
    
    #limit_conn   crawler  20;
    
    location / {          
       try_files $uri $uri/ /index.php?q=$uri&amp;amp;$args;    
    }

    # if file exists return it right away
    if (-f $request_filename) {      
       break;
    }
 
    # otherwise rewrite the request
    if (!-e $request_filename) {
       rewrite ^(.+)$ /index.php$1 last;
       break;
    }    
    
     
    location ~ .*\.(php|php5)?$
    {      
      fastcgi_pass  unix:/tmp/php-cgi.sock;
      #fastcgi_pass  127.0.0.1:9000;
      fastcgi_index index.php;
      include fastcgi.conf;

    }
    
    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
    {
      access_log off;
      expires      30d;
    }

    location ~ .*\.(js|css)?$
    {
      access_log off;
      expires      1d;
    }    
    
    # Only allow search engine to access pics
    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv)$
    {
	valid_referers none blocked *.liuxuan.info *.google.com *.baidu.com;
	if ($invalid_referer)
	{
	   return 403;
	}
    }
  

    log_format  access  '$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; '
              '$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; '
              '&amp;quot;$http_user_agent&amp;quot; $http_x_forwarded_for';
    access_log  /data/log/access.log  access;
  }

 
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查Nginx配置是否正确：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/webserver/nginx/sbin/nginx -t&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动Nginx：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/webserver/nginx/sbin/nginx&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置开机自动启动Nginx：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/rc.local
/usr/local/webserver/nginx/sbin/nginx&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在不停止Nginx服务的情况下平滑变更Nginx配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kill -HUP `cat /usr/local/webserver/nginx/nginx.pid`&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;linux&quot;&gt;Linux设置&lt;/h2&gt;

&lt;p&gt;修改服务器时间为上海时间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭不需要的服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ntsysv  //按空格选择和取消，按F12退出&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下仅列出需要启动的服务，未列出的服务一律关闭：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;crond
iptables
network
syslog
vsftpd&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;回顾这段搭建的过程可谓历经挫折和痛苦，其中碰到了很多问题，为此我还到StackOverflow上发贴求助，但是我还是坚持了下来，直到搭建成功，所以说坚持和永不放弃的精神是非常重要的。搭建完成后，通过top命令发现虽然只有19个进程，但是内存占用还是蛮高的，特别是系统启动后需要占用的内存。好了，希望能给看到这篇博文的朋友带来帮助，缩短他们搭建的时间。&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.s135.com/nginx_php_v6/&quot; title=&quot;http://blog.s135.com/nginx_php_v6/&quot;&gt;http://blog.s135.com/nginx_php_v6/&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.fallday.org/archives/551&quot; title=&quot;http://www.fallday.org/archives/551&quot;&gt;http://www.fallday.org/archives/551&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Java常见疑惑和陷阱(三)</title>
   <link href="/blog/2011/08/11/java-puzzles-and-traps-three/"/>
   <updated>2011-08-11T16:56:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/08/11/java-puzzles-and-traps-three</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;令人混淆的构造器案例&lt;/h2&gt;

&lt;p&gt;下面的程序会打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Confusing {
  private Confusing(Object o) {
    System.out.println(&amp;quot;Object&amp;quot;);
  }

  private Confusing(double[] dArray) {
    System.out.println(&amp;quot;double array&amp;quot;);
  }

  public static void main(String[] args) {
    new Confusing(null);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果运行该程序，你会发现打印的是“double array“。这是因为：Java的重载解析过程是以两阶段运行的。第一阶段选取所有可获得并且可应用的方法或构造器。第二阶段在第一阶段选取的方法或构造器中选取最精确的一个。&lt;strong&gt;如果一个方法或构造器可以接受传递给另一个方法或构造器的任何参数,那么我们就说第一个方法比第二个方法缺乏精确性。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果想要调用Confusing(Object)构造方法,你需要这样改写代码: new Confusing((Object)null)。这可以确保只有Confusing(Object)是可应用的。更一般地讲,要想强制要求编译器选择一个精确的重载版本,需要将实际的参数转型为形式参数所声明的类型。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;我所得到的都是静态的&lt;/h2&gt;

&lt;p&gt;下面的程序将打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Dog {
  public static void bark() {
    System.out.print(&amp;quot;woof&amp;quot;);
  }
}

class Dog1 extends Dog {
  public static void bark() { }
}

public class Bark {
  public static void main(String args[]) {
    Dog woofer = new Dog();
    Dog nipper = new Basenji();
    woofer.bark();
    nipper.bark();
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好像该程序应该只打印一个woof，毕竟Dog1继承自Dog,并且它的bark方法定义了什么也不做。main方法调用了bark方法,第一次是在Dog类型的woofer上调用,第二次是在Dog1类型的nipper上调用。但是如果你运行该程序,就会发现它打印的是 “woof woof“。&lt;/p&gt;

&lt;p&gt;问题在于bark是一个静态方法,而对静态方法的调用不存在任何动态的分派机制。当一个程序调用了一个静态方法时,要被调用的方法都是在编译时刻被选定的,而这种选定是基于修饰符的编译期类型而做出的,修饰符的编译期类型就是我们给出的方法调用表达式中圆点左边部分的名字。在本例中,两个方法调用的修饰符分别是变量woofer 和nipper,它们都被声明为Dog类型。因为它们具有相同的编译期类型,所以编译器使得它们调用的是相同的方法:Dog.bark。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;比年龄小&lt;/h2&gt;

&lt;p&gt;如果运行下面的程序会打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Age {
  public static final Age INSTANCE = new Age();
  private final int age;
  private static final int CURRENT_YEAR=Calendar.getInstance().get(Calendar.YEAR);

  private Age() {
    age = CURRENT_YEAR - 1985;
  }

  public int getAge() {
    return age;
  }

  public static void main(String[] args) {
    System.out.println(&amp;quot;My age is &amp;quot; + INSTANCE.getAge() + &amp;quot; years old.&amp;quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个程序是在计算当前的年份减去1985的值。如果它是正确的,那么在2011年,该程序将打印出”My age is 26 years old”。但是如果你尝试着去运行该程序,该程序将打印出”My age is -1985 years old”。&lt;/p&gt;

&lt;p&gt;该程序所遇到的问题是由类初始化顺序中的循环而引起的。让我们来看看其细节。首先,其静态域被设置为缺省值,其中INSTANCE被设置为null,CURRENT_YEAR被设置为0。接下来,静态域初始器按照其出现的顺序执行。第一个静态域是INSTANCE,它的值是通过调用 Age()构造器而计算出来的。这个构造器会用一个涉及静态域CURRENT_YEAR的表达式来初始化age。通常,读取一个静态域是会引起一个类被初始化的事件之一,但是我们已经在初始化Age类了，所以递归的初始化尝试会直接被忽略掉。因此,CURRENT_YEAR 的值仍旧是其缺省值0。这就是为什么我的年龄变成了-1985的原因。最后,从构造器返回以完成Age类的初始化,假设我们是在2011年运行该程序,那么我们就将静态域 CURRENT_YEAR初始化成了2011。但是已经太晚了，age的值已经是-1985了。这正是后续所有对Age.INSTANCE.getAge()的调用将返回的值。&lt;/p&gt;

&lt;p&gt;该程序表明,在final类型的静态域被初始化之前,存在着读取它的值的可能,而此时该静态域包含的还只是其所属类型的缺省值。这是与直觉相违背的,因为我们通常会将final类型的域看作是常量。final类型的域只有在其初始化表达式是常量表达式时才是常量。&lt;/p&gt;

&lt;p&gt;要想修正这个程序,需要重新对静态域的初始化进行排序,使得每一个初始化都出现在任何依赖于它的其他的初始化之前。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;不是你的类型&lt;/h2&gt;

&lt;p&gt;下面的三个程序每一个都会打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Type1 {
  public static void main(String[] args) {
    String s = null;
    System.out.println(s instanceof String);
  }
}

public class Type2 {
  public static void main(String[] args) {
    System.out.println(new Type2() instanceof String);
  }
}

public class Type3 {
  public static void main(String args[]) {
    Type3 t3 = (Type3) new Object();
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个程序,Type1展示了instanceof操作符应用于一个空对象引用时的行为。尽管null对于每一个引用类型来说都是其子类型,但是instanceof操作符被定义为在其左操作数为null时返回false。因此,Type1将打印false。这被证明是实践中非常有用的行为。如果instanceof告诉你一个对象引用是某个特定类型的实例,那么你就可以将其转型为该类型,并调用该类型的方法,而不用担心会抛出ClassCastException或NullPointerException。&lt;/p&gt;

&lt;p&gt;第二个程序,Type2展示了instanceof操作符在测试一个类的实例,以查看它是否是某个不相关的类的实例时所表现出来的行为。你可能会期望该程序打印出false。毕竟,Type2的实例不是String的实例,因此该测试应该失败。遗憾是,instanceof 测试在编译时刻就失败了,我们只能得到下面这样的出错消息:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Type2.java:3: inconvertible types
found: Type2, required: java.lang.String
       System.out.println(new Type2() instanceof String);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该程序编译失败是因为instanceof操作符有这样的要求:&lt;strong&gt;如果两个操作数的类型都是类,其中一个必须是另一个的子类型&lt;/strong&gt;。Type2和String彼此都不是对方的子类型,所以instanceof测试将导致编译期错误。&lt;/p&gt;

&lt;p&gt;第三个程序,Type3展示了当要被转型的表达式的静态类型是转型类型的超类时转型操作符的行为:如果在一个转型操作中的两种类型都是类,那么其中一个必须是另一个的子类型。尽管对我们来说,这个转型很显然会失败,但是类型系统还没有强大到能够洞悉表达式new Object()的运行期类型不可能是Type3的一个子类型。因此,该程序将在运行期抛出ClassCastException。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;特创论&lt;/h2&gt;

&lt;p&gt;下面的程序会打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Creator {
  public static void main(String[] args) {
    for (int i = 0; i &amp;lt; 100; i++)
      Creature creature = new Creature();
    System.out.println(Creature.numCreated());
  }
}

class Creature {
  private static long numCreated = 0;
    public Creature() {
      numCreated++;
    }

  public static long numCreated() {
    return numCreated;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该程序看起来似乎应该打印100,但是它没有打印任何东西,因为它根本就不能编译。如果你尝试着去编译它,你就会发现编译器的诊断信息基本没什么用处。下面就是javac打印的东西:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Creator.java:4: not a statement
Creature creature = new Creature();
^
Creator.java:4: ';' expected
Creature creature = new Creature();
^&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个本地变量声明看起来像是一条语句,但是从技术上说,它不是;它应该是一个本地变量声明语句(local variable declaration statement)。Java语言规范不允许一个本地变量声明语句作为一条语句在for、while或do循环中重复执行。一个本地变量声明作为一条语句只能直接出现在一个语句块中。(一个语句块是由一对花括号以及包含在这对花括展中的语句和声明构成的)。&lt;/p&gt;

&lt;p&gt;有两种方式可以修正这个问题。最显而易见的方式是将这个声明至于一个语句块中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; 100; i++) {
  Creature creature = new Creature();
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而,请注意,该程序没有使用本地变量creature。因此,将该声明用一个无任何修饰的构造器调用来替代将更具实际意义,这样可以强调对新创建对象的引用正在被丢弃:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; 100; i++)
  new Creature();&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>Java常见疑惑和陷阱(二)</title>
   <link href="/blog/2011/08/07/java-puzzles-and-traps-two/"/>
   <updated>2011-08-07T16:20:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/08/07/java-puzzles-and-traps-two</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;循环者的鬼魂&lt;/h2&gt;

&lt;p&gt;请提供一个对i的声明,将下面的循环转变为一个无限循环:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (i != 0) {
  i &amp;gt;&amp;gt;&amp;gt;= 1;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于无符号右移操作，0被从左移入到由移位操作而空出来的位上,即使被移位的负数也是如此。这个循环比前面三个循环要稍微复杂一点,因为其循环体非空。在其循环题中,i的值由它右移一位之后的值所替代。为了使移位合法,i必须是一个整数类型(byte、char、short、int或long)。无符号右移操作符把0从左边移入,因此看起来这个循环执行迭代的次数与最大的整数类型所占据的位数相同,即64次。如果你在循环的前面放置如下的声明,那么这确实就是将要发生的事情:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long i = -1; // -1L has all 64 bits set&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你怎样才能将它转变为一个无限循环呢?解决本谜题的关键在于无符号右移是一个复合赋值操作符。有关混合操作符的一个不幸的事实是,它们可能会自动地执行窄化原始类型转换,这种转换把一种数字类型转换成了另一种更缺乏表示能力的类型。窄化原始类型转换可能会丢失级数的信息,或者是数值的精度。&lt;/p&gt;

&lt;p&gt;让我们更具体一些,假设你在循环的前面放置了下面的声明:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;short i = -1;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为i的初始值((short)0xffff)是非0的,所以循环体会被执行。在执行移位操作时,第一步是将i提升为int类型。所有算数操作都会对short、byte和char类型的操作数执行这样的提升。这种提升是一个拓宽原始类型转换,因此没有任何信息会丢失。这种提升执行的是符号扩展,因此所产生的int数值是0xffffffff。然后,这个数值右移1位,但不使用符号扩展,因此产生了int数值0x7fffffff。最后,这个数值被存回到i 中。为了将int数值存入short类型的变量,Java执行的是可怕的窄化原始类型转换,它直接将高16位截掉。这样就只剩下(short)oxffff了,我们又回到了开始处。循环的第二次以及后续的迭代行为都是一样的,因此循环将永远不会终止。&lt;/p&gt;

&lt;p&gt;如果你将i声明为一个short或byte变量,并且初始化为任何负数,那么这种行为也会发生。如果你声明i为一个char,那么你将无法得到无限循环,因为char是无符号的,所以发生在移位之前的拓宽原始类型转换不会执行符号扩展。&lt;/p&gt;

&lt;p&gt;总之,不要在short、byte或char类型的变量之上使用复合赋值操作符。因为这样的表达式执行的是混合类型算术运算,它容易造成混乱。更糟的是,它们执行将隐式地执行会丢失信息的窄化转型,其结果是灾难性的。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;循环者的诅咒&lt;/h2&gt;

&lt;p&gt;请提供一个对i的声明,将下面的循环转变为一个无限循环:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (i &amp;lt; = j &amp;amp;&amp;amp; j &amp;lt;= i &amp;amp;&amp;amp; i != j) {
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嘿,不要再给我看起来不可能的循环了！如果满足前2个条件，i不是肯定等于j吗?这一属性对实数肯定有效。事实上,它是如此地重要,以至于它有这样的定义:实数上的小于等于关系是反对称的，且在5.0版之前是反对称的,但是这从5.0版之后就不再是了。&lt;/p&gt;

&lt;p&gt;直到5.0版之前,Java的数字比较操作符要求它们的两个操作数都是原始数字类型的(byte、char、short、int、long、float 和 double)。但是在5.0版中,规范作出了修改,新规范描述道:每一个操作数的类型必须可以转换成原始数字类型。问题难就难在这里了，在5.0版中,自动包装和自动反包装被添加到了Java语言中。小于等于操作符在原始数字类型集上仍然是反对称的,但是现在它还被应用到了被包装的数字类型上。(被包装的数字类型有:Byte、Character、Short、Integer、Long、Float和Double)。&lt;/p&gt;

&lt;p&gt;让我们更具体一些,下面的声明会使表达式的值为true,从而将这个循环变成了一个无限循环：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Integer i = new Integer(0);
Integer j = new Integer(0);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前两个子表达式在i和j上执行解包转换,并且在数字上比较所产生的int数值。i和j都表示0,所以这两个子表达式都被计算为true。第三个子表达式(i!=j)在对象引用i和j上执行标识比较,因为它们都初始化为一个新的Integer实例,因此,第三个子表达式同样也被计算为true,循环也就永远地环绕下去了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;循环者遇到了狼人&lt;/h2&gt;

&lt;p&gt;请提供一个对i的声明,将下面的循环转变为一个无限循环。这个循环不需要使用任何 5.0版的特性:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (i != 0 &amp;amp;&amp;amp; i == -i) {
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这仍然是一个循环。在上面的条件表达式中,一元减号操作符作用于i,这意味着它的类型必须是数字型的:一元减号操作符作用于一个非数字型操作数是非法的。因此,我们要寻找一个非0的数字型数值,它等于它自己的负值。NaN不能满足这个属性,因为它不等于任何数值,因此,i必须表示一个实际的数字。肯定没有任何数字满足这样的属性吗?&lt;/p&gt;

&lt;p&gt;除了0之外,没有任何浮点数等于其符号位反转之后的值,因此i的类型必然是整数。有符号的整数类型使用的是2的补码算术运算:为了对一个数值取其负值,你要反转其每一位,然后加1,从而得到结果。2的补码算术运算的一个很大的优势是,0具有唯一的示形式。如果你要对int数值0取负值,你将得到0xffffffff+1,它仍然是0。&lt;/p&gt;

&lt;p&gt;但是,这也有一个相应的不利之处,总共存在偶数个int数值（准确地说有232个）其中一个用来表示0,这样就剩下奇数个int数值来表示正整数和负整数,这意味着正的和负的int数值的数量必然不相等。这暗示着至少有一个int数值,其负值不能正确地表示成为一个int数值。&lt;/p&gt;

&lt;p&gt;事实上,恰恰就有一个这样的int数值,它就是Integer.MIN_VALUE,即-231。它的十六进制表示是0x80000000，其符号位为1,其余都是0。如果取个值的负数0x7fffffff+1=0x80000000=Integer.MIN_VALUE。换句话说,Integer.MIN_VALUE是它自己的负值,Long.MIN_VALUE也是一样。对这两个值取负值将会产生溢出,但是Java在整数计算中忽略了溢出。&lt;/p&gt;

&lt;p&gt;总之,Java使用2的补码的算术运算,它是非对称的。对于每一种有符号的整数类型 (int、long、byte 和 short),负的数值总是比正的数值多一个,这个对多出来的值总是这种类型所能表示的最小数值。Integer.MIN_VALUE取负值得到的还是它没有改变过的值,Long.MIN_VALUE也是如此。对Short.MIN_VALUE取负值并将所产生的int数值转型回short,返回的同样是最初的值(Short.MIN_VALUE)。对于Byte.MIN_VALUE来说,也会产生相似的结果。更一般地讲,千万要当心溢出:就像狼人一样,它是个杀手。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;被计数击倒了&lt;/h2&gt;

&lt;p&gt;下面的程序有一个单重的循环,它记录迭代的次数,并在循环终止时打印这个数。那么,这个程序会打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Count {
  public static void main(String[] args) {
    final int START = 2000000000;
    int count = 0;
    for (float f = START; f &amp;lt; START + 50; f++){
      count++;
    }
    System.out.println(count);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表面的分析也许会认为这个程序将打印50,然而,这种分析遗漏了关键的一点:循环变量是float类型的,而非int类型的。F的初始值接近于Integer.MAX_VALUE,因此它需要用31位来精确表示,而float类型只能提供24位的精度（整数部分24位，小数部分8位）。对如此巨大的一个float数值进行增量操作将不会改变其值。因此,这个程序看起来应该无限地循环下去,因为f永远也不可能解决其终止值。但是,如果你运行该程序,就会发现它并没有无限循环下去,事实上,它立即就终止了,并打印出0。怎么回事呢?&lt;/p&gt;

&lt;p&gt;问题在于终止条件测试失败了,其方式与增量操作失败的方式非常相似。这个循环只有在循环索引f比(float)(START+50)小的情况下才运行。在将一个int与一个float进行比较时,会自动执行从int到float的转换。遗憾的是,这种转换是会导致精度丢失的三种类型转换的一种(另外两个是从long到float和从long到double)。&lt;/p&gt;

&lt;p&gt;f的初始值太大了,以至于在对其加上50,然后将结果转型为float时,所产生的值等于直接将f转换成float的值，即(float)2000000000==(float)2000000050,因此在循环体第一次执行之前就是false,所以,循环体也就永远的不到机会去运行。注意到2000000000有10个因子都是2:它是一个2乘以9个10,而每个10都是5×2，这意味着2000000000的二进制表示是以10个0结尾的。50的二进制表示只需要6位,所以将50加到2000000000上不会对右边6位之外的其他为产生影响。特别是,从右边数过来的第7位和第8位仍旧是0。提升这个31位的int到具有24位精度的float会在第 7位和第8位之间四舍五入,从而直接丢弃最右边的7位，因此它们的float表示是相同的。&lt;/p&gt;

&lt;p&gt;这个谜题的教训是：不要使用浮点数作为循环索引,因为它会导致无法预测的行为。如果你在循环体内需要一个浮点数,那么请使用int或long循环索引,并将其转换为float或double。在将一个int或long转换成一个float或double时,你可能会丢失精度,但是至少它不会影响到循环本身。当你使用浮点数时,要使用double而不是 float,除非你肯定float提供了足够的精度,并且存在强制性的性能需求迫使你使用 float。适合使用float而不是double的时刻是非常非常少的。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;一分钟又一分钟&lt;/h2&gt;

&lt;p&gt;下面这段程序将打印分钟计数器，那么它会打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Clock {
  public static void main(String[] args) {
    int minutes = 0;
    for (int ms = 0; ms &amp;lt; 60*60*1000; ms++){
      if (ms % 60*1000 == 0)
    }
    minutes++;
    System.out.println(minutes);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能期望程序打印出60,毕竟,这就是一小时所包含的分钟数。但是,它打印的却是 60000。为什么它会如此频繁地对minutes执行了增量操作呢?&lt;/p&gt;

&lt;p&gt;问题就出在(ms % 60&lt;em&gt;1000 == 0)。你可能会认为这个表达式等价于(ms % 60000 == 0),但是其实它们并不等价。取余和乘法操作符具有相同的优先级,因此表达式ms % 60&lt;/em&gt;1000等价于(ms % 60)*1000。&lt;/p&gt;

&lt;p&gt;订正该程序的最简单的方式就是在布尔表达式中插入一对括号,以强制规定计算的正确顺序:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (ms % (60 * 1000) == 0){
  minutes++;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而,有一个更好的方法可以订正该程序。用被恰当命名的常量来替代所有的魔幻数字:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Clock {
  private static final int MS_PER_HOUR = 60 * 60 * 1000;
  private static final int MS_PER_MINUTE = 60 * 1000;
  public static void main(String[] args) {
    int minutes = 0;
    for (int ms = 0; ms &amp;lt; MS_PER_HOUR; ms++){
      if (ms % MS_PER_MINUTE == 0){
        minutes++;
      }
    System.out.println(minutes);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;极端不可思议&lt;/h2&gt;

&lt;p&gt;下面的三个程序每一个都会打印些什么?不要假设它们都可以通过编译:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.io.IOException;
public class Arcane1 {
  public static void main(String[] args) {
    try {
      System.out.println(&amp;quot;Hello world&amp;quot;);
    } catch(IOException e) {
      System.out.println(&amp;quot;I've never seen println fail!&amp;quot;);
    }
  }
}

public class Arcane2 {
  public static void main(String[] args) {
    try {
      // If you have nothing nice to say, say nothing
    } catch(Exception e) {
      System.out.println(&amp;quot;This can't happen&amp;quot;);
    }
  }
}

interface Type1 {
  void f() throws CloneNotSupportedException;
}

interface Type2 {
  void f() throws InterruptedException;
}

interface Type3 extends Type1, Type2 {
}

public class Arcane3 implements Type3 {
  public void f() {
    System.out.println(&amp;quot;Hello world&amp;quot;);
  }

  public static void main(String[] args) {
    Type3 t3 = new Arcane3();
    t3.f();
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个程序Arcane1,展示了已检查异常的一个基本原则。它看起来应该是可以编译的:try子句执行 I/O,并且catch子句捕获IOException异常。但是这个程序不能编译。因为println方法没有声明会抛出任何被检查异常,而IOException却正是一个被检查异常。语言规范中描述道:如果一个catch子句要捕获一个类型为E的被检查异常,而其相对应的try子句不能抛出E的某种子类型的异常,那么这就是一个编译期错误。&lt;/p&gt;

&lt;p&gt;基于同样的理由,第二个程序Arcane2看起来应该是不可以编译的，但是它却可以。它之所以可以编译,是因为它唯一的catch子句检查了Exception。尽管Java语言规范在这一点上十分含混不清,但是捕获Exception或Throwble的catch子句是合法的,不管与其相对应的try子句的内容为何。&lt;/p&gt;

&lt;p&gt;第三个程序Arcane3,看起来它也不能编译，实际上却可以。为什么呢?上述分析的缺陷在于对“Type3.f可以抛出在Type1.f上声明的异常和在Type2.f 上声明的异常”所做的假设。但是这并不正确,因为每一个接口都限制了方法f可以抛出的被检查异常集合。一个方法可以抛出的被检查异常集合是它所适用的所有类型声明要抛出的被检查异常集合的交集,而不是合集。因此,静态类型为Type3的对象上的f方法根本就不能抛出任何被检查异常。因此,Arcane3可以毫无错误地通过编译。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;不受欢迎的宾客&lt;/h2&gt;

&lt;p&gt;将尝试着从其环境中读取一个用户ID,如果这种尝试失败了,则缺省地认为它是一个来宾用户。该程序的作者将面对有一个静态域的初始化表达式可能会抛出异常的情况。那么,下面的程序会打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class UnwelcomeGuest {
  public static final long GUEST_USER_ID = -1;
  private static final long USER_ID;
  static {
    try {
      USER_ID = getUserIdFromEnvironment();
    } catch (IdUnavailableException e) {
      USER_ID = GUEST_USER_ID;
      System.out.println(&amp;quot;Logging in as guest&amp;quot;);
    }
  }

  private static long getUserIdFromEnvironment()
  throws IdUnavailableException {
    throw new IdUnavailableException();
  }

  public static void main(String[] args) {
    System.out.println(&amp;quot;User ID: &amp;quot; + USER_ID);
  }
}

class IdUnavailableException extends Exception {
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该程序看起来很直观：getUserIdFromEnvironment方法将抛出一个异常,然后将GUEST_USER_ID(-1L)赋值给USER_ID,并打印“Loggin in as guest“,然后main方法执行,使程序打印“User ID: -1“。表象再次欺骗了我们,该程序并不能编译。如果你尝试着去编译它,你将看到和下面内容类似的一条错误信息:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UnwelcomeGuest.java:10:
variable USER_ID might already have been assigned
USER_ID = GUEST_USER_ID;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题出在哪里了?USER_ID是一个空final(blank final),它是一个在声明中没有进行初始化操作的final值。很明显,只有在对USER_ID赋值失败时,才会在try语句块中抛出异常,因此,在catch语句块中赋值是相当安全的。不管怎样执行静态初始化操作语句块,只会对USER_ID赋值一次,这正是空final所要求的。为什么编译器不知道这些呢?&lt;/p&gt;

&lt;p&gt;要确定一个程序是否可以不止一次地对一个空final进行赋值是一个很困难的问题。事实上,这是不可能的。这等价于经典的停机问题,它通常被认为是不可能解决的。为了能够编写出一个编译器,语言规范在这一点上采用了保守的方式。在程序中,一个空 final域只有在它是明确未赋过值的地方才可以被赋值。&lt;/p&gt;

&lt;p&gt;解决这类问题的最好方式就是将这个烦人的域从空final类型改变为普通的final类型,用一个静态域的初始化操作替换掉静态的初始化语句块。实现这一点的最佳方式是重构静态语句块中的代码为一个助手方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class UnwelcomeGuest {
  public static final long GUEST_USER_ID = -1;
  private static final long USER_ID = getUserIdOrGuest;
  private static long getUserIdOrGuest {
    try {
      return getUserIdFromEnvironment();
    } catch (IdUnavailableException e) {
      System.out.println(&amp;quot;Logging in as guest&amp;quot;);
      return GUEST_USER_ID;
    }
  }
  ...// The rest of the program is unchanged
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;您好,再见!&lt;/h2&gt;

&lt;p&gt;下面的程序在寻常的Hello world程序中添加了一段不寻常的曲折操作。那么,它将会打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class HelloGoodbye {
  public static void main(String[] args) {
    try {
      System.out.println(&amp;quot;Hello world&amp;quot;);
      System.exit(0);
    } finally {
      System.out.println(&amp;quot;Goodbye world&amp;quot;);
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行程序你会发现它永远不会说再见:它只打印了Hello world。我们已经知道不论 try语句块的执行是正常地还是意外地结束,finally语句块确实都会执行。然而在这个程序中,try语句块根本就没有结束其执行过程。System.exit方法将停止当前线程和所有其他当场死亡的线程。finally子句的出现并不能给予线程继续去执行的特殊权限。&lt;/p&gt;

&lt;p&gt;当System.exit方法被调用时,虚拟机在关闭前要执行两项清理工作。首先,它执行所有的关闭挂钩操作,这些挂钩已经注册到了Runtime.addShutdownHook上。这对于释放JVM以外的资源将很有帮助。务必要为那些必须在JVM退出之前发生的行为关闭挂钩。下面的程序版本示范了这种技术,它可以如我们所期望地打印出Hello world 和Goodbye world:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class HelloGoodbye1 {
  public static void main(String[] args) {
    System.out.println(&amp;quot;Hello world&amp;quot;);
    Runtime.getRuntime().addShutdownHook(new Thread() {
      public void run() {
        System.out.println(&amp;quot;Goodbye world&amp;quot;);
      }
    });
    System.exit(0);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JVM在System.exit方法被调用时执行的第二个清理任务与终结器有关。如果System.runFinalizerOnExit或Runtime.runFinalizersOnExit被调用了,那么JVM将在所有还未终结的对象上面调用终结器。这些方法很久以前就已经过时了,无论什么原因,永远不要调用System.runFinalizersOnExit和 Runtime.runFinalizersOnExit:它们属于Java类库中最危险的方法之一。调用这些方法导致的结果是,终结器会在那些其他线程正在并发操作的对象上面运行,从而导致不确定的行为或导致死锁。&lt;/p&gt;

&lt;p&gt;总之,System.exit将立即停止所有的程序线程,它并不会使finally语句块得到调用,但是它在停止JVM之前会执行关闭挂钩操作。当JVM被关闭时,请使用关闭挂钩来终止外部资源。通过调用System.halt可以在不执行关闭挂钩的情况下停止JVM,但是这个方法很少使用。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;不情愿的构造器&lt;/h2&gt;
&lt;p&gt;尽管在一个方法声明中看到一个throws子句是很常见的,但是在构造器的声明中看到一个throws子句就很少见了。下面的程序就有这样的一个声明。那么,它将打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Reluctant {
  private Reluctant internalInstance = new Reluctant();
  public Reluctant() throws Exception {
    throw new Exception(&amp;quot;I'm not coming out&amp;quot;);
  }

  public static void main(String[] args) {
    try {
      Reluctant b = new Reluctant();
      System.out.println(&amp;quot;Surprise!&amp;quot;);
    } catch (Exception ex) {
      System.out.println(&amp;quot;I told you so&amp;quot;);
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能期望catch子句能够捕获这个异常,并且打印“I told you so“。但是当你尝试着去运行它时,它却抛出StackOverflowError异常,为什么呢?&lt;/p&gt;

&lt;p&gt;与大多数抛出StackOverflowError异常的程序一样,本程序也包含了一个无限递归。当你调用一个构造器时,实例变量的初始化操作将先于构造器的程序体而运行。在本谜题中,internalInstance变量的初始化操作递归调用了构造器,而该构造器通过再次调用Reluctant构造器而初始化该变量自己的internalInstance,如此无限递归下去就会抛出StackOverflowError异常。因为StackOverflowError是 Error的子类型而不是Exception的子类型,所以catch子句无法捕获它。&lt;/p&gt;

&lt;p&gt;总之,实例初始化操作是先于构造器的程序体而运行的。实例初始化操作抛出的任何异常都会传播给构造器。如果初始化操作抛出的是被检查异常,那么构造器必须声明也会抛出这些异常,但是应该避免这样做,因为它会造成混乱。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;域和流&lt;/h2&gt;

&lt;p&gt;下面的方法将一个文件拷贝到另一个文件,并且被设计为要关闭它所创建的每一个流,即使它碰到I/O错误也要如此。遗憾的是,它并非总是能够做到这一点。为什么不能呢,你如何才能订正它呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void copy(String src, String dest) throws IOException {
  InputStream in = null;
  OutputStream out = null;
  try {
    in = new FileInputStream(src);
    out = new FileOutputStream(dest);
    byte[] buf = new byte[1024];
    int n;
    while ((n = in.read(buf)) &amp;gt; 0)
    out.write(buf, 0, n);
  } finally {
    if (in != null) in.close();
    if (out != null) out.close();
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题出在finally语句块自身中，close方法也可能会抛出IOException。如果这正好发生在in.close被调用之时,那么这个异常就会阻止out.close被调用,从而使输出流仍保持在开放状态。&lt;/p&gt;

&lt;p&gt;解决方式是将每一个close都包装在一个嵌套的try语句块中。下面的finally语句块的版本可以保证在两个流上都会调用close:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;finally {
  if (in != null) {
  try {
    in.close();
  } catch (IOException ex) {
    // There is nothing we can do if close fails
  }
  if (out != null)
  try {
    out.close();
  } catch (IOException ex) {
    // There is nothing we can do if close fails
  }
}

//从5.0版本开始,你可以利用Closeable接口对代码进行重构:
finally {
  closeIgnoringException(in);
  closeIgnoringEcception(out);
}

private static void closeIgnoringException(Closeable c) {
  if (c != null) {
    try {
    c.close();
  } catch (IOException ex) {
    // There is nothing we can do if close fails
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总之,当你在finally语句块中调用close方法时,要用一个嵌套的try-catch语句来保护它,以防止IOException的传播。更一般地讲,对于任何在finally语句块中可能会抛出的被检查异常都要进行处理,而不是任其传播。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;异常地危险&lt;/h2&gt;

&lt;p&gt;在JDK1.2中,Thread.stop、Thread.suspend以及其他许多线程相关的方法都因为它们不安全而不推荐使用了。下面的方法展示了你用Thread.stop可以实现的可怕事情之一:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Don’t do this - circumvents exception checking!
public static void sneakyThrow(Throwable t) {
  Thread.currentThread().stop(t); // Deprecated
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个讨厌的小方法所做的事情正是throw语句要做的事情,但是它绕过了编译器的所有异常检查操作。你可以(卑鄙地)在你的代码的任意一点上抛出任何受检查的或不受检查的异常,而编译器对此连眉头都不会皱一下。&lt;/p&gt;

&lt;p&gt;不使用任何不推荐的方法,你也可以编写出在功能上等价于sneakyThrow的方法。事实上,至少有两种方式可以这么实现这一点,其中一种只能在5.0或更新的版本中运行。你能够编写出这样的方法吗?它必须是用Java 而不是用JVM字节码编写的,你不能在其客户对它编译完之后再去修改它。你的方法不必是完美无瑕的:如果它不能抛出一两个Exception的子类,也是可以接受的。&lt;/p&gt;

&lt;p&gt;本谜题的一种解决之道是利用Class.newInstance方法中的设计缺陷,该方法通过反射来对一个类进行实例化。引用有关该方法的文档中的话:“请注意,该方法将传播从空的(就是无参数的)构造器所抛出的任何异常,包括受检查的异常。使用这个方法可以有效地绕开在其他情况下都会执行的编译期异常检查。”一旦你了解了这一点,编写一个sneakyThrow的等价方法就不是太难了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Thrower {
  private static Throwable t;
  private Thrower() throws Throwable {
    throw t;
  }
  public static synchronized void sneakyThrow(Throwable t) {
    Thrower.t = t;
    try {
      Thrower.class.newInstance();
    } catch (InstantiationException e) {
      throw new IllegalArgumentException();
    } catch (IllegalAccessException e) {
      throw new IllegalArgumentException();
    } finally {
      Thrower.t = null; // Avoid memory leak
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个解决方案中将会发生许多微妙的事情。我们想要在构造器执行期间所抛出的异常不能作为一个参数传递给该构造器,因为Class.newInstance调用的是一个类的无参数构造器。因此,sneakyThrow方法将这个异常藏匿于一个静态变量中。为了使该方法是线程安全的,它必须被同步,这使得对其的并发调用将顺序地使用静态域t。要注意的是,t这个域在从finally语句块中出来时是被赋为空的:这只是因为该方法虽然是卑鄙的,但这并不意味着它还应该是内存泄漏的。如果t不被赋为空,那么它阻止该异常被垃圾回收。注意,如果你让该方法抛出一个InstantiationException或IllegalAccessException异常,它将以抛出IllegalArgumentException,这是这项技术的一个内在限制。&lt;/p&gt;

&lt;p&gt;Class.newInstance的文档继续描述道：“Constructor.newInstance方法通过将构造器抛出的任何异常都包装在(已检查的)InvocationTargetException异常中而避免了这个问题”很明显,Class.newInstance应该是做了相同的处理。但是纠正这个缺陷已经为时过晚,因为这么做将引入源代码级别的不兼容性，这将使许多依赖于Class.newInstance的程序崩溃。而弃用这个方法也不切实际,因为它太常用了。当你在使用它时,一定要意识到Class.newInstance可以抛出它没有声明过的受检查异常。&lt;/p&gt;

&lt;p&gt;被添加到5.0版本中的“范型”可以为本谜题提供一个完全不同的解决方案。为了实现最大的兼容性,通用类型是通过类型擦除来实现的:通用类型信息是在编译期而非运行期检查的。下面的解决方案就利用了这项技术:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Don't do this either - circumvents exception checking!
class TigerThrower&amp;lt;t extends Throwable&amp;gt; {
  public static void sneakyThrow(Throwable t) {
    new TigerThrower&amp;lt;error&amp;gt;().sneakyThrow2(t);
  }

  private void sneakyThrow2(Throwable t) throws T {
    throw (T) t;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个程序在编译时将产生一条警告信息:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TigerThrower.java:7:warning: [unchecked] unchecked cast found
: java.lang.Throwable, required: T
throw (T) t;
^&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;警告信息是编译器所采用的一种手段,用来告诉你:你可能正在搬起石头砸自己的脚,而且事实也正是如此。“不受检查的转型”警告告诉你这个有问题的转型将不会在运行时刻受到检查。当你获得了一个不受检查的转型警告时,你应该修改你的程序以消除它,或者你可以确信这个转型不会失败。如果你不这么做,那么某个其他的转型可能会在未来不确定的某个时刻失败,而你也就很难跟踪此错误到其源头了。对于本谜题所示的情况,其情况更糟糕:在运行期抛出的异常可能与方法的签名不一致。sneakyThrow2方法正是利用了这一点。&lt;/p&gt;

&lt;p&gt;总之,Java 的异常检查机制并不是虚拟机强制执行的。它只是一个编译期工具,被设计用来帮助我们更加容易地编写正确的程序,但是在运行期可以绕过它。要想减少你因为这类问题而被曝光的次数,就不要忽视编译器给出的警告信息。&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;切掉类&lt;/h2&gt;

&lt;p&gt;请考虑下面的两个类:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Strange1 {
  public static void main(String[] args) {
    try {
      Missing m = new Missing();
    } catch (java.lang.NoClassDefFoundError ex) {
      System.out.println(&amp;quot;Got it!&amp;quot;);
    }
  }
}

public class Strange2 {
  public static void main(String[] args) {
    Missing m;
    try {
      m = new Missing();
    } catch (java.lang.NoClassDefFoundError ex) {
      System.out.println(&amp;quot;Got it!&amp;quot;);
    }
  }
}

class Missing {
  Missing() { }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你编译后并且在运行Strange1和Strange2之前删Missing.class文件,你就会发现这两个程序的行为有所不同。其中一个抛出了NoClassDefFoundError,而另一个却打印出了“Got it!“到底哪一个程序具有哪一种行为,你又如何去解释这种行为上的差异呢?&lt;/p&gt;

&lt;p&gt;Strange1只在其try语句块中提及Missing类型,因此你可能会认为NoClassDefFoundError被捕获并打印“Got it!“。Strange2在try语句块之外声明了一个Missing类型的变量,因此你可能会认为NoClassDefFoundError不会被捕获。如果你试着运行这些程序,就会看到它们的行为正好相反，怎样才能解释这些奇怪的行为呢?&lt;/p&gt;

&lt;p&gt;如果你去查看Java规范以找出应该抛出NoClassDefFoundError的地方,那么你不会得到很多的信息。该规范描述道：这个错误可以“在(直接或间接)使用某个类的程序中的任何地方”抛出。当JVM调用Strange1和Strange2的main方法时,这些程序都间接使用了Missing类,因此,它们都在其权利范围内于这一点上抛出了该错误。于是,本谜题的答案就是这两个程序可以依据其实现而展示出各自不同的行为。但是这并不能解释为什么这些程序在所有我们所知的Java实现上的实际行为,与你所认为的必然行为都正好相反。要查明为什么会是这样,我们需要研究一下由编译器生成的这些程序的字节码。&lt;/p&gt;

&lt;p&gt;如果你去比较Strange1和Strange2的字节码,就会发现几乎是一样的。除了类名之外,唯一的差异就是catch语句块所捕获的参数ex与JVM本地变量之间的映射关系不同。尽管哪一个程序变量被指派给了哪一个JVM变量的具体细节会因编译器的不同而有所差异,但是对于和上述程序一样简单的程序来说,这些细节不太可能会差异很大。下面是通过执行 javap -c Strange1 命令而显示的Strange1.main的字节码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0   new info.liuxuan.test.Missing [16]
3   dup
4   invokespecial info.liuxuan.test.Missing() [18]
7   astore_1 [m]
8   goto 20
11  astore_1 [ex]
12  getstatic java.lang.System.out : java.io.PrintStream [19]
15  ldc &amp;lt;string &amp;quot;Got it!&amp;quot;&amp;gt; [25]
17  invokevirtual java.io.PrintStream.println(java.lang.String) : void [27]
20  return
      Exception Table:
        [pc: 0, pc: 8] -&amp;gt; 11 when : java.lang.NoClassDefFoundError
      Line numbers:
        [pc: 0, line: 14]
        [pc: 11, line: 15]
        [pc: 12, line: 16]
        [pc: 20, line: 18]
      Local variable table:
        [pc: 0, pc: 21] local: args index: 0 type: java.lang.String[]
        [pc: 8, pc: 11] local: m index: 1 type: info.liuxuan.test.Missing
        [pc: 12, pc: 20] local: ex index: 1 type: java.lang.NoClassDefFoundError
&amp;lt;/string&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Strange2.main相对应的字节码与其只有一条指令不同:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;11: astore_2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一条将catch语句块中的捕获异常存储到捕获参数ex中的指令。在Strange1中,这个参数是存储在JVM变量1中的,而在Strange2中,它是存储在JVM变量2中的。这就是两个类之间唯一的差异,但是它所造成的程序行为上的差异是多么地大呀!&lt;/p&gt;

&lt;p&gt;为了运行一个程序,JVM要加载和初始化包含main方法的类。在加载和初始化间,JVM 必须链接类。链接的第一阶段是校验,校验要确保一个类是良构的,并且遵循语言的语法要求。校验非常关键,它维护着可以将像Java这样的安全语言与像C或C++这样的不安全语言区分开的各种承诺。在Strange1和Strange2这两个类中,本地变量m碰巧都被存储在JVM变量1中。两个版本的main都有一个连接点,从两个不同位置而来的控制流汇聚于此。该连接点就是指令20,即从main返回的指令。在正常结束try语句块的情况下,我们执行到指令8,即goto20,从而可以到达指令20;对于在catch语句块中结束的情况,我们将执行指令17,并按顺序执行下去,到达指令20。连接点的存在使得在校验Strange1类时产生异常,而在校验Strange2类时并不会产生异常。当校验执行对Strange1.main的流分析时,由于指令20可以通过两条不同的路径到达,因此校验器必须合并在变量1中的类型。两种类型是通过计算它们的首个公共超类而合并的(两个类的首个公共超类是它们所共有的最详细而精确的超类)。在 Strange1.main方法中,当从指令8到达指令20时,JVM变量1的状态包含了一个 Missing类的实例。当从指令17到达时,它包含了一个NoClassDefFoundError 类的实例。为了计算首个公共超类,校验器必须加载Missing类以确定其超类。因为 Missing.class文件已经被删除了,所以校验器不能加载它,因而抛出了一个NoClassDefFoundError。请注意,这个异常是在校验期间、在类被初始化之前,并且在main方法开始执行之前很早就抛出的。这就解释了为什么没有打印出任何关于这个未被捕获异常的跟踪栈信息。要想编写一个能够探测出某个类是否丢失的程序,请使用反射来引用类而不要使用通常的语言结构。下面展示了用这种技巧重写的程序:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Strange {
  public static void main(String[] args) throws Exception{
    try {
      Object m = Class.forName(&amp;quot;Missing&amp;quot;).newInstance();
    } catch (ClassNotFoundException ex) {
      System.err.println(&amp;quot;Got it!&amp;quot;);
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总之,不要对捕获NoClassDefFoundError形成依赖。语言规范非常仔细地描述了类初始化是在何时发生的,但是类被加载的时机却显得更加不可预测。更一般地讲,捕获Error及其子类型几乎是完全不恰当的。这些异常是为那些不能被恢复的错误而保留的。&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;令人疲惫不堪的测验&lt;/h2&gt;

&lt;p&gt;本谜题将测试你对递归的了解程度。下面的程序将做些什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Workout {
  public static void main(String[] args) {
    workHard();
    System.out.println(&amp;quot;It's nap time.&amp;quot;);
  }

  private static void workHard() {
    try {
      workHard();
    } finally {
      workHard();
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要不是有try-finally语句,该程序的行为将非常明显:workHard方法递归调用它自身,直到StackOverflowError被抛出而终止。但是,try-finally语句把事情搞得复杂了。当它试图抛出StackOverflowError 时,程序将会在finally语句块的workHard方法中终止。这样,它就递归调用了自己。这看起来确实就像是一个无限循环的秘方,但是这个程序真的会无限循环下去吗?如果你运行它,它似乎确实是这么做的,但是要想确认的唯一方式就是分析它的行为。&lt;/p&gt;

&lt;p&gt;Java虚拟机对栈的深度限制到了某个预设的水平。当超过这个水平时,JVM就抛出 StackOverflowError。为了让我们能够更方便地考虑程序的行为,我们假设栈的深度为3,这比它实际的深度要小得多。现在让我们来跟踪其执行过程。main方法调用 workHard,而它又从其try语句块中递归地调用了自己,然后它再一次从其try语句块中调用了自己。在此时,栈的深度是3。当workHard方法试图从其try语句块中再次调用自己时,该调用立即就会以抛出StackOverflowError而失败。这个错误是在最内部的finally语句块中被捕获的,在此处栈的深度已经达到了3。在那里,workHard 方法试图递归地调用它自己,但是该调用却以抛出StackOverflowError而失败。这个错误将在上一级的finally语句块中被捕获,在此处站的深度是2。该finally中的调用与相对应的try语句块具有相同的行为:都会产生一个StackOverflowError。&lt;/p&gt;

&lt;p&gt;所以，一个深度为0的调用(即main中的调用),两个深度为1的调用,四个深度为2的调用,和八个深度为3的调用,总共是15个调用。那八个深度为3的调用每一个都会立即产生StackOverflowError。至少在把栈的深度限制为3的JVM上,该程序不会是一个无限循环:它在15个调用和8个异常之后就会终止。但是对于真实的JVM又会怎样呢?它仍然不会是一个无限循环。其调用图与前面的图相似,只不过要大得多得多而已。那么,究竟大到什么程度呢?许多JVM都将栈的深度限制为1024,因此,调用的数量就是1+2+4+8…+21,024=21,025-1,而抛出的异常的数量是 21,024。假设我们的机器可以在每秒钟内执行1010个调用,并产生1010个异常,按照当前的标准,这个假设的数量已经相当高了。在这样的假设条件下,程序将在大约 1.7×10291年后终止。为了让你对这个时间有直观的概念,我告诉你,我们的太阳的生命周期大约是1010年,所以我们可以很确定,我们中没有任何人能够看到这个程序终止的时刻。尽管它不是一个无限循环,但是它也就算是一个无限循环吧。&lt;/p&gt;

&lt;p&gt;实际上,这个调用是一棵完全二叉树,它的深度就是JVM的栈深度的上限。WorkOut程序的执行过程等于是在先序遍历这棵树。在先序遍历中,程序先访问一个节点,然后递归地访问它的左子树和右子树。对于树中的每一条边,都会产生一个调用,而对于树中的每一个节点,都会抛出一个异常。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>单精度浮点类型的二进制表示格式</title>
   <link href="/blog/2011/08/01/single-precision-binary-floating-point-format/"/>
   <updated>2011-08-01T16:12:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/08/01/single-precision-binary-floating-point-format</id>
   <content type="html">&lt;p&gt;这两天在&lt;a href=&quot;http://stackoverflow.com&quot; title=&quot;Stack Overflow&quot;&gt;Stack Overflow&lt;/a&gt;上闲逛的时候，发现有个关于Java中单精度浮点数（float）的问题:&lt;a href=&quot;http://stackoverflow.com/questions/5849741/what-is-the-maximum-number-in-the-mantissa-part-of-a-java-float&quot; title=&quot;what-is-the-maximum-number-in-the-mantissa-part-of-a-java-float&quot;&gt;what-is-the-maximum-number-in-the-mantissa-part-of-a-java-float&lt;/a&gt;。我不得不承认，我被震精了。因为以前只知道float在Java中占4个字节（即32位），并不知道它内部用来表示1个小数的具体格式是什么。我记得我以前刚学Java的时候，最开始要学的就是基本数据类型（当然其他语言也一样），那时候我就对1个小数用二进制来表示产生过疑问，而且，书上对这个也没有详细的解释。难道这个底层的float表示格式不重要吗？我觉得这个很重要，人家不是都有问题出来了么？那么就乘这次把float的底层的二进制表示格式搞清楚吧。 &lt;/p&gt;

&lt;p&gt;在Java中，float采用的是&lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_754-2008&quot; title=&quot;IEEE Standard for Floating-Point Arithmetic (IEEE 754)&quot;&gt;IEEE Standard for Floating-Point Arithmetic (IEEE 754)&lt;/a&gt;标准,即float占4个字节，也就是32位，具体分配如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;符号位：&lt;strong&gt;1&lt;/strong&gt; 位&lt;/li&gt;
  &lt;li&gt;幂底数位：&lt;strong&gt;8&lt;/strong&gt; 位&lt;/li&gt;
  &lt;li&gt;指数有效位：&lt;strong&gt;23&lt;/strong&gt; 位&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/e/e8/IEEE_754_Single_Floating_Point_Format.svg&quot; alt=&quot;single precision float point format&quot; title=&quot;single precision float point format&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;符号位是从左边数起的第一位数，0代表正数或零，1代表负数，这个没有什么疑问。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;幂底数位是从右边数起的第23位到第30位。我们需要注意的是，这个数是用&lt;a href=&quot;http://en.wikipedia.org/wiki/Offset_binary&quot; title=&quot;offset binary&quot;&gt;偏移二进制（offset binary）&lt;/a&gt;表示的，并不是用二进制的补码来表示，并且这个8位二进制数是没有符号位的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个偏移二进制与二进制补码的对应关系可以查看下面的表格：&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;th&gt;Offset Binary code, K=8&lt;/th&gt;
&lt;th&gt;Decimal code&lt;/th&gt;
&lt;th&gt;Twos' complement Binary&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1111&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;0111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1100&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0111&lt;/td&gt;
&lt;td&gt;−1&lt;/td&gt;
&lt;td&gt;1111&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;td&gt;−2&lt;/td&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0101&lt;/td&gt;
&lt;td&gt;−3&lt;/td&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;td&gt;−4&lt;/td&gt;
&lt;td&gt;1100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;−5&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt;−6&lt;/td&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;td&gt;−7&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;td&gt;−8&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;我们可以从上面的表格看到，偏移和补码的区别只是最高位的区别（右边数起）。当补码最高为是1的（也就是这个数是负数）时候，偏移表示的最高位是0，反之亦然。好了，既然指数的有效位使用偏移来表示的话，那么它的值就不是实际真正的值，而是要用它来与偏移量相减，从而得到真正的指数有效位值。这个偏移量为2&lt;sup&gt;n−1&lt;/sup&gt;−1 ，其中n为所有位数。例如float里是用8位来表示，那么偏移量就是127。&lt;/p&gt;

&lt;p&gt;细心的朋友可能会发现应该减去2&lt;sup&gt;n-1&lt;/sup&gt;才是真正的值，但是为什么不减去2&lt;sup&gt;n&lt;/sup&gt;，而是减去2&lt;sup&gt;n−1&lt;/sup&gt;−1呢？&lt;a href=&quot;http://en.wikipedia.org/wiki/Offset_binary&amp;quot;&quot; title=&quot;offset binary&quot;&gt;维基&lt;/a&gt;上是这么说的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unusually however, instead of using “excess 2^(n-1)” it uses “excess 2^(n-1)-1” which means that inverting the leading (high-order) bit of the exponent will not convert the exponent to correct twos’ complement notation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说这是有意这么做的，为了不把指数转换成正确的二进制补码形式。我搞不懂为什么要这样做，所以就在StackOverflow上提了个&lt;a href=&quot;http://stackoverflow.com/questions/6871501/offset-binary-format-for-float-in-java&quot; title=&quot;offset-binary-format-for-float-in-java&quot;&gt;问题&lt;/a&gt;，大家可以参考一下。&lt;/p&gt;

&lt;p&gt;这样一来，8位无符号指数的范围是0-255，再减去偏移量127，结果则为-127-128。另外全0和全1作为特殊处理,所以表示范围就变成了-126到127。特殊处理说明参考下表：&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;th&gt;Exponent&lt;/th&gt;
&lt;th&gt;Significand zero&lt;/th&gt;
&lt;th&gt;Significand non-zero&lt;/th&gt;
&lt;th&gt;Equation&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;00&lt;sub&gt;H&lt;/sub&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/0_(number)&quot; title=&quot;0 (number)&quot;&gt;zero&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/%E2%88%920&quot; title=&quot;−0&quot; class=&quot;mw-redirect&quot;&gt;−0&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Subnormal_numbers&quot; title=&quot;Subnormal numbers&quot; class=&quot;mw-redirect&quot;&gt;subnormal numbers&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;(−1)&lt;sup&gt;signbits&lt;/sup&gt;×2&lt;sup&gt;−126&lt;/sup&gt;× 0.significandbits&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;01&lt;sub&gt;H&lt;/sub&gt;, ..., FE&lt;sub&gt;H&lt;/sub&gt;&lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;normalized value&lt;/td&gt;
&lt;td&gt;(−1)&lt;sup&gt;signbits&lt;/sup&gt;×2&lt;sup&gt;exponentbits−127&lt;/sup&gt;× 1.significandbits&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FF&lt;sub&gt;H&lt;/sub&gt;&lt;/td&gt;
&lt;td&gt;±&lt;a href=&quot;http://en.wikipedia.org/wiki/Infinity&quot; title=&quot;Infinity&quot;&gt;infinity&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/NaN&quot; title=&quot;NaN&quot;&gt;NaN&lt;/a&gt; (quiet, signalling)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;3.剩下的23位就是所谓的小数位了。但是注意：如果这23位全部是0的话，最高位将多出1位来，且这位上的值是1。&lt;/p&gt;

&lt;p&gt;好了，这样所有32位都有了，自然可以得到二进制转换成十进制的推导公式为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/1/d/e/1de9cd706cf2343bf03714ed2d4e4e65.png&quot; alt=&quot;formula&quot; title=&quot;formula&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对应到上图的例子为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/2/5/6/2567776ddd65d7deb6b0a8e63dd82e52.png&quot; alt=&quot;formula&quot; title=&quot;formula&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，双精度浮点数（double）的64位分配和单精度数差不多，具体情况如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/IEEE_754_Double_Floating_Point_Format.svg/618px-IEEE_754_Double_Floating_Point_Format.svg.png&quot; alt=&quot;double precision floating-point format&quot; title=&quot;double precision floating-point format&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Single_precision_floating-point_format&quot; title=&quot;Single_precision_floating-point_format&quot;&gt;Single_precision_floating-point_format&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_754-1985#Exponent_biasing&quot; title=&quot;Exponent_biasing&quot;&gt;Exponent_biasing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Quora使用的技术</title>
   <link href="/blog/2011/07/16/quora-technology-examined/"/>
   <updated>2011-07-16T15:43:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/07/16/quora-technology-examined</id>
   <content type="html">&lt;p&gt;如果提起&lt;a href=&quot;http://www.quora.com&quot; title=&quot;Quora&quot;&gt;Quora&lt;/a&gt;,国人首先想到的可能会是它在国内的山寨版&lt;a href=&quot;http://www.zhihu.com&quot; title=&quot;知乎&quot;&gt;知乎&lt;/a&gt;。想当初知乎还因为它的条款问题引来网络上的一片骂声，这个事件倒是给我提了个醒，因为我以前基本上不看网站的条款声明，现在看来以后要看明白了再用啊（特别是山寨货），不然怎么死的都不知道。当然我关注的不是山寨货，而是它的本源Quora。 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm7.static.flickr.com/6001/5943445558_12a1fc3061.jpg&quot; alt=&quot;Quora&quot; title=&quot;Quora&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Quora由Facebook前CTO亚当·德安杰洛（Adam D’Angelo）以及Facebook工程技术经理查理·切沃（Charlie Cheever）于2008年创立。2010年初开始内部测试的Quora在3月获得风险投资公司Benchmark Capital的1400万美元投资。据《华尔街日报》报道，估值为8750万美元。但是Quora目前还是执行着邀请制度，这导致它的PV相对于同类型的社交问答网站&lt;a href=&quot;http://stackoverflow.com&quot; title=&quot;Stack Overflow&quot;&gt;Stack Overflow&lt;/a&gt;要少了很多。但这并不能阻止Quora的火爆，其高质量的回答和优秀的用户体验都是它的优势所在。&lt;/p&gt;

&lt;p&gt;作为我自己来讲，更多的还是关心Quora使用到的技术。它的性能为什么这么棒，它的架构是怎样的，它使用的是哪种语言和框架，它的搜索性能为什么这么好等。那就让我们来看看Quora到底用到了哪些技术。&lt;/p&gt;

&lt;h2 id=&quot;the-search-box&quot;&gt;The Search-Box&lt;/h2&gt;

&lt;p&gt;Quora只能搜索问题，主题标签，用户名，和主题标题。没有全文搜索，所以，你无法搜索问题和答案的内容。而搜索中使用前缀搜索方式，比如你输入mi，则Microsoft会马上出来。其搜索还会有一些非常简单的模糊匹配的算法。另外，如果有重复的问题，其中一个问题会自动跳转到另一个问题，但是在搜索中还是会出现。搜索中没有拼写检查。&lt;/p&gt;

&lt;p&gt;一开始，他们使用的是一个开源的搜索服务器，叫&lt;a href=&quot;http://sphinxsearch.com/&quot;&gt;Sphinx&lt;/a&gt;，其支持上述的那些功能。现在他们不用这个服务器了，因为&lt;a href=&quot;http://www.quora.com/What-is-the-best-open-source-solution-for-implementing-fast-auto-complete&quot;&gt;受到了一些限制&lt;/a&gt;。他们做了一个新的解决方案，这个算法由Python实现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.quora.com/What-libraries-does-Quora-use-for-search&quot;&gt;&lt;img width=&quot;16&quot; height=&quot;16&quot; style=&quot;padding-right: 10px;&quot; src=&quot;http://www.quora.com/favicon.ico&quot; /&gt;What libraries does Quora use for search?&lt;/a&gt;&lt;br /&gt;
&lt;small&gt;Adam D’Angelo, Quora Founder (Nov 13, 2010)&lt;/small&gt;&lt;br /&gt;
Our search is custom-written. It doesn’t use any libraries aside from Thrift, and Python’s unicode library, which we use for unicode normalization.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;speedy-queries&quot;&gt;Speedy Queries&lt;/h2&gt;

&lt;p&gt;Quora的查询是非常高速的，其查询请求是通过AJAX的GET请求发送的，结果返回用的是JSON数据格式，但他们解析JSON是在服务器端，而不是通过浏览器的javascript。这么做的原因可能是他们想高亮搜索关键词，似乎使用Client端的Javascript非常不好做。&lt;/p&gt;

&lt;p&gt;Quora的即时搜索好像比较暴力，如果你输入Microsoft（一共9个字符），你会看到其会像后端发送9次查询——每按一个键一次，无论你敲这个单词的速底有多快，每输入一个字符都会发一个请求给后台。对于这样的看上去没有效率的对后台的请求，后台的服务器端会来控制相关的前台请求，所以，就算是前台这样做，也不会增加服务器端的负载，因为后台会做相关的处理。&lt;/p&gt;

&lt;p&gt;Quora的搜索使用HTTP长连接，当你开始敲查询的时候，连接就建立了，这个连接会持续在那里，你下次搜索的时候会继续使用这个连接，除非你60秒没有动作了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.quora.com/Quora-product/Is-Quora-going-to-implement-full-text-search&quot;&gt;&lt;img width=&quot;16&quot; height=&quot;16&quot; style=&quot;padding-right: 10px;&quot; src=&quot;http://www.quora.com/favicon.ico&quot; /&gt;Is Quora going to implement full-text search?&lt;/a&gt;&lt;br /&gt;
&lt;small&gt;Adam D’Angelo, I made a lot of the early Quora … (Sep 1, 2010)&lt;/small&gt;&lt;br /&gt;
Yes, eventually. We haven’t implemented this yet because we’ve prioritized other things, but we will definitely do it in the future.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;webnode2-and-livenode&quot;&gt;Webnode2 And LiveNode&lt;/h2&gt;

&lt;p&gt;Webnode2 和 LiveNode 是 Quora 内部的系统，其用来管理内容。Webnode2 生成 HTML, CSS 和 JavaScript 并且和 LiveNode 紧紧地耦合在一起，Webnode2主要是用来管理内容在网页上显示的，LiveNode主要是用来做动态网页内容更新的。Charlie Cheever 说，如果他可以从新开始，他&lt;a href=&quot;http://www.quora.com/What-limitations-has-Quora-encountered-due-to-LiveNode-WebNode#answers&quot;&gt;第一件事要做的就是重写整个LiveNode&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Quora的工程师看上去对他们搞的这些东西非常的满意，并且&lt;a href=&quot;http://www.quora.com/What-limitations-has-Quora-encountered-due-to-LiveNode-WebNode#answers&quot;&gt;他们也在努力地找到这些东西的弱点&lt;/a&gt;。有一个有意思的关于LiveNode的问题是，如果A和B同时正在看相当的一个问题，那么用户A的一些交互动作会影响B的页面。例如，如果A顶了一下某个答案，那么这个答案可能会往上移动。这样的一个显示变化会通过AJAX更新B的浏览器。如果B此时展开了评论，可能会受到影响。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.quora.com/What-is-LiveNode-written-in&quot;&gt;LiveNode 由这些东西写成：&lt;/a&gt;Python, C++, 和 JavaScript。&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; ，&lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;也用到了。
因为Quora&lt;a href=&quot;http://www.quora.com/Is-Quora-planning-on-open-sourcing-LiveNode&quot;&gt;想要对他们的LiveNode开源&lt;/a&gt; 并准备把他们的代码分开，做这个事可能需要太多的工作和时间。
Charlie Cheever 指出 WebNode2 和&lt;a href=&quot;http://www.quora.com/Quora-Infrastructure/What-is-webnode2&quot;&gt;有一个叫做 “free and easy website builder” 的 Webnode 的 webnode.com&lt;/a&gt; 没有任何的关系。&lt;/p&gt;

&lt;h2 id=&quot;amazon-web-services&quot;&gt;Amazon Web Services&lt;/h2&gt;

&lt;p&gt;Quora全部托管在Amazon的EC2和S3上，因为这样就不像在相当长的时间内自己运营服务器那样成本高昂，他们就是为像Quora这样快速增长的公司量身定做的。&lt;/p&gt;

&lt;h2 id=&quot;ubuntu-linux&quot;&gt;Ubuntu Linux&lt;/h2&gt;

&lt;p&gt;Quora使用Ubuntu Linux作为操作系统。没有什么大惊喜。在Amazon EC2上部署和管理都非常容易。Adam D’Angelo &lt;a href=&quot;http://www.quora.com/Quora-Infrastructure/Which-Linux-flavor-does-Quora-use-Why&quot;&gt;指出&lt;/a&gt;他在高中时就使用Debian Linux，并且一直坚持到大学时还在用。原因就是&lt;a href=&quot;http://www.quora.com/Quora-Infrastructure/Which-Linux-flavor-does-Quora-use-Why&quot;&gt;“它工作的很好，而且没有令人信服的理由用别的操作系统去替代它”&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;static-content&quot;&gt;Static Content&lt;/h2&gt;

&lt;p&gt;你只需要看一下Quora任何一个HTML的源代码，就可以看到他们在使用Amozon的分布式CDN, &lt;a href=&quot;http://aws.amazon.com/cloudfront/&quot;&gt;Cloudfront&lt;/a&gt;。URLs在form里：
&amp;lt;pre lang=&quot;html&quot;&amp;gt;http://d2o7bfz2il9cb7.cloudfront.net/main-thumb-670336-25-7kmigSSkkdusoE6gHRkdQsXfjuTCaxQs.jpeg&amp;lt;/pre&amp;gt;
CloudFront用来处理所有的静态页面,CSS和JavaScript (除了Google的 Analytics JavaScript,这是被Google托管)。&lt;a href=&quot;http://www.quora.com/How-is-Quora-doing-image-uploads-to-Amazon-S3&quot;&gt;图片被上传到EC2服务器,然后调整大小后上传到S3服务器&lt;/a&gt;。这些都是用&lt;a href=&quot;http://aws.amazon.com/code/134&quot;&gt;Python S3 API&lt;/a&gt;来管理的。&lt;/p&gt;

&lt;h2 id=&quot;haproxy-load-balancing&quot;&gt;HAProxy Load-Balancing&lt;/h2&gt;

&lt;p&gt;Quora把&lt;a href=&quot;http://haproxy.1wt.eu/&quot;&gt;HAProxy&lt;/a&gt;放在最前端，作为在它后面的分布式Nginx服务器的负载均衡服务器。&lt;/p&gt;

&lt;h2 id=&quot;nginx&quot;&gt;Nginx&lt;/h2&gt;

&lt;p&gt;反向代理服务器是Nginx，如果要了解更多这种设置方式，我推荐阅读&lt;a href=&quot;http://kovyrin.net/2006/05/18/nginx-as-reverse-proxy/&quot;&gt;Using Nginx As Reverse-Proxy Server On High-Loaded Sites&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;pylons-and-paste&quot;&gt;Pylons And Paste&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://pylonshq.com/&quot;&gt;Pylons&lt;/a&gt;是一个轻量级的Web框架，通常都是在Nginx之后作为主要的web服务器。他们使用默认的&lt;a href=&quot;http://spacepants.org/blog/pylons-paste-stack&quot;&gt;Pylon + Paste stack&lt;/a&gt;方式。选择Pylons就像在万圣节选择南瓜一样。他们把Pylons中的template和ORM用他们自己的用Python写成的技术替换掉，这就是&lt;a href=&quot;http://www.quora.com/What-languages-and-frameworks-were-used-to-code-Quora&quot;&gt;LiveNode和WebNode2所在的地方&lt;/a&gt;。
&lt;a href=&quot;http://www.mochimedia.com/&quot;&gt;MochiMedia&lt;/a&gt;也是使用Pylons的启发中的一个，因为他们自己正在用它。&lt;/p&gt;

&lt;h2 id=&quot;python&quot;&gt;Python&lt;/h2&gt;

&lt;p&gt;从Facebook出来的Charlie和Adam选用了Python而不是PHP。正如Adam指出的 “&lt;a href=&quot;http://www.quora.com/Why-did-Quora-choose-Python-for-its-development&quot;&gt;Facebook is stuck on that for legacy reasons, not because it is the best choice right now&lt;/a&gt;”（Facebook使用PHP并不是因为其好，而是因为历史原因的问题），当然他们也不会使用C#，因为那样一来就会引入一堆微软的东西。当然，也不会是Java，因为Python要比Java更容易写出代码，Scala太年轻了，还需要考验。Ruby看上来很像Python，但是他们对Ruby没有过多的经验。最终还是Python胜出。当然，他们知道Python的弱点是性能和速度，所以，他们在需要速度和性能的地方使用了C/C++。 他们使用Python的版本是2.6。&lt;/p&gt;

&lt;p&gt;使用Python的另一个原因是Python的数据结构和JSON可以很好的映射起来。代码易读性很高。而且有很多的库，调试器和重载器。Quora的B/S结构几乎完全通过JSON进行数据交互。&lt;/p&gt;

&lt;p&gt;他们&lt;a href=&quot;http://www.quora.com/Adam-DAngelo/What-version-of-Python-are-you-programming-in-and-what-IDE-do-you-use&quot;&gt;没有使用IDE&lt;/a&gt;，他们使用得最多的是Emacs，一看就知道这是一个个人的选择，随着他们开发团队的扩大，这种情况会得到改变的。&lt;/p&gt;

&lt;p&gt;另外，他们提到了&lt;a href=&quot;http://pypy.org/&quot;&gt;PyPy&lt;/a&gt;，一个让Python更快更灵活的项目。&lt;/p&gt;

&lt;h2 id=&quot;thrift&quot;&gt;Thrift&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://incubator.apache.org/thrift/&quot;&gt;Thrift&lt;/a&gt; 用于后端服务器间的通讯。Thrift  服务由 C++开发。&lt;a href=&quot;http://coolshell.cn/articles/4549.html&quot;&gt;Facebook同样使用了这个技术&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.quora.com/Why-would-you-write-a-Thrift-service-in-C&quot;&gt;&lt;img width=&quot;16&quot; height=&quot;16&quot; style=&quot;padding-right: 10px;&quot; src=&quot;http://www.quora.com/favicon.ico&quot; /&gt;Why would you write a Thrift service in C++?&lt;/a&gt;&lt;br /&gt;
&lt;small&gt;Adam D’Angelo, I’ve written a lot of Python, in… (Sep 4, 2010)&lt;/small&gt;&lt;br /&gt;
Mainly if you want to keep data in memory between requests, and want to keep your Python code stateless. Writing a Python wrapper around a C library involves some memory management with reference counting that requires some understanding of the Python internals, but writing a thrift interface is simple. You also isolate failures this way – if the service goes down it won’t take the Python code down with it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;tornado&quot;&gt;Tornado&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.tornadoweb.org/&quot;&gt;Tornado&lt;/a&gt; web 框架用于实时更新，其运行在Comet服务器上，其用来处理大量的需要长时间poll和push更新的网络连接。&lt;/p&gt;

&lt;h2 id=&quot;long-polling-comet&quot;&gt;Long Polling (Comet)&lt;/h2&gt;

&lt;p&gt;Quora的网页并不是简单的显示，每一个页面都需要更新，或是创建问题，答案和评论。所以，他们使用了Long Polling而不是传统的Polling，传统的Polling需要浏览器一端不停地重复地向服务器询问——“有更新吗？”，服务器说没有，于是过一会浏览大再问，现在呢？服务器说，还是没有，浏览器过一会又问，现在呢？服务器说，还没好。这样一来，就好像让我们的客户端放到了驾驶室里，这显然是有问题的，因为只有服务器知道什么时候会有更新。而且浏览器这么干，很快会让服务器的负载加上去。&lt;/p&gt;

&lt;p&gt;Long polling也就是我们熟知的&lt;a href=&quot;http://en.wikipedia.org/wiki/Comet_(programming)&quot;&gt;Comet&lt;/a&gt;，其让服务器来控制这些事，让客服端等在那里听服务器的响应。在client和server的会话对于两者是是相同的，而不是client需要等着然后向服务器查询。服务器端可以把一个连接打开很长时间（比如：60秒），在这段时间里，服务器会查看是否有相应的东西需要更新，如果有的话，就发给浏览器。如果没有的话，就等下一次的client询问。可见，这种服务器等一会再响应的方法可以让浏览器少发几次查询。&lt;/p&gt;

&lt;p&gt;对于long-polling的最好的地方是，可以降低浏览器和客户端间来来回回的次数。让服务器端来控制时间，所以，内容更新可能会只是几个毫秒，或是几十秒。 服务器端也可以积攒一堆更新后，一次发给浏览器。这样做会更有效率。&lt;/p&gt;

&lt;p&gt;但是，这个方法的黑暗面是——这会让服务器端出现大量的TCP链接，想一想，Quora也是百万级用户的应用了，只需要10%的在线用户，你就需要一个可以处理10万并发量的架构。注意，如果一个用户在其浏览器里打开了多个Quora网页的话，那么，这个链接器会是非常致命的。&lt;/p&gt;

&lt;p&gt;当然，好的消息是已经有一些技术专门为Long Polling设计，这些技术可以让你在那些等待的连接中只会消耗非常非常少的内存（因为那些等待连接并不需要所有的资源）。例如：Nginx是一个单线程的事件驱动的小型服务器，每一个链接只花非常小的内存。每一个Nginx的进程只会在一个时候处理一个连接。这意味着其很容易扩展成一个可以处理成千上的并发量的服务架构。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a onclick=&quot;javascript:_gaq.push(['_trackEvent','outbound-article','www.quora.com/How-do-you-push-messages-back-to-a-web-browser-client-through-AJAX-Is-there-any-way-to-do-this-without-having-the-client-constantly-polling-the-server-for-updates']);&quot; href=&quot;http://www.quora.com/How-do-you-push-messages-back-to-a-web-browser-client-through-AJAX-Is-there-any-way-to-do-this-without-having-the-client-constantly-polling-the-server-for-updates&quot;&gt;&lt;img width=&quot;16&quot; height=&quot;16&quot; style=&quot;padding-right: 10px;&quot; src=&quot;http://www.quora.com/favicon.ico&quot; /&gt;How do you push messages back to a web-browser client through AJAX?  Is there any way to do this without having the client constantly polling the server for updates?&lt;/a&gt;&lt;br /&gt;
&lt;small&gt;Adam D’Angelo, Quora (Sep 29, 2010)&lt;/small&gt;&lt;br /&gt;
There is no reliable way to do this without having the client polling the server. However, you can make the server stall its responses (50 seconds is a safe bet) and then complete them when a message is ready for the client. This is called “long polling” and it’s how Quora, Gmail, Meebo, etc all handle the problem.
If you have a specialized server that uses epoll or kqueue, you should be able to hold on the order of 100k users per server (depending on how many messages are going). This is called the “c10k” problem. http://www.kegel.com/c10k.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL&lt;/h2&gt;

&lt;p&gt;就像Adam D’Angelo的老东家Facebook一样，Quora同样重度使用MySQL。在回答Quora的问题“&lt;a href=&quot;http://www.quora.com/When-Adam-DAngelo-says-partition-your-data-at-the-application-level-what-exactly-does-he-mean&quot;&gt;When Adam D’Angelo says “partition your data at the application level”, what exactly does he mean?&lt;/a&gt;“, D’Angelo详细描述了怎样使用MySQL(或者一般的关系型数据库）来做分布式数据存储。&lt;/p&gt;

&lt;p&gt;基本建议是，如果需要的话把数据库里的数据分区。尽可能的把数据放在一台机器上，使用hash主键对多数据库中的大规模的数据进行分区。必须避免使用表连接（join）。Adam参考了FriendFeed的一篇文章&lt;a href=&quot;http://bret.appspot.com/entry/how-friendfeed-uses-mysql&quot;&gt;How FriendFeed uses MySQL to store schema-less data&lt;/a&gt;，他&lt;a href=&quot;http://www.quora.com/NoSQL/In-what-parts-of-a-social-site-with-concert-listings-should-one-use-a-NoSQL-DB-versus-a-SQL-DB&quot;&gt;还说&lt;/a&gt;在还没有100万用户之前，不要使用NoSQL。&lt;/p&gt;

&lt;p&gt;并不只是Quora和FriendFeed重度使用MySQL，Google也在一些与搜索无关的应用上使用MySQL。Google已经为MySQL的复制，同步，监控和更快的速度提升发布了&lt;a href=&quot;http://code.google.com/p/google-mysql-tools/wiki/Mysql4Patches&quot;&gt;补丁&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a onclick=&quot;javascript:_gaq.push(['_trackEvent','outbound-article','www.quora.com/How-does-one-evaluate-if-a-database-is-efficient-enough-to-not-crash-as-its-put-under-increasing-load']);&quot; href=&quot;http://www.quora.com/How-does-one-evaluate-if-a-database-is-efficient-enough-to-not-crash-as-its-put-under-increasing-load&quot;&gt;&lt;img width=&quot;16&quot; height=&quot;16&quot; style=&quot;padding-right: 10px;&quot; src=&quot;http://www.quora.com/favicon.ico&quot; /&gt;How does one evaluate if a database is efficient enough to not crash as it’s put under increasing load?&lt;/a&gt;&lt;br /&gt;
&lt;small&gt;Adam D’Angelo, Quora (Oct 10, 2010)&lt;/small&gt;&lt;br /&gt;
One option is to simulate some load. Write a script that mimics the kinds of queries your application will be doing, and make sure it can handle the amount of load you want it to be ready for (especially as the size of the dataset changes).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;memcached&quot;&gt;Memcached&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://memcached.org/&quot;&gt;Memcached&lt;/a&gt;作为MySQL的前端缓存。&lt;/p&gt;

&lt;h2 id=&quot;git&quot;&gt;Git&lt;/h2&gt;

&lt;p&gt;用&lt;a href=&quot;http://git-scm.com/&quot;&gt;Git&lt;/a&gt;作为&lt;a href=&quot;http://www.quora.com/What-languages-and-frameworks-were-used-to-code-Quora&quot;&gt;版本控制工具&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;javascript-placement&quot;&gt;JavaScript Placement&lt;/h2&gt;

&lt;p&gt;如果你看一下Quora的网页源码，你会看到其JavaScript总是在页面的最后。 Charlie Cheever&lt;a href=&quot;http://www.quora.com/Why-is-the-Quora-website-so-fast&quot;&gt;建议&lt;/a&gt;这样做会让页面加载变快，因为会先渲染网页内容，然后再加载JavaScript。&lt;/p&gt;

&lt;h2 id=&quot;charlie-cheever-follows-14-rules-for-faster-loading-web-sites&quot;&gt;Charlie Cheever Follows “14 Rules for Faster-Loading Web Sites”&lt;/h2&gt;

&lt;p&gt;Steve Souders,《High Performance Web Sites》和《Even Faster Web Sites》的作者，列出了&lt;a href=&quot;http://stevesouders.com/hpws/rules.php&quot;&gt;让你网页更快的原则&lt;/a&gt;。Charlie Cheever提到过这个列表，这是Quora的速度快的原因之一。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;尽可能少的HTTP请求&lt;/li&gt;
&lt;li&gt;使用CDN&lt;/li&gt;
&lt;li&gt;添加过期头&lt;/li&gt;
&lt;li&gt;用Gzip压缩组件&lt;/li&gt;
&lt;li&gt;把CSS放在页面的顶部&lt;/li&gt;
&lt;li&gt;把JavaScript放在页面的底部&lt;/li&gt;
&lt;li&gt;避免CSS表达式&lt;/li&gt;
&lt;li&gt;JavaScript,CSS和HTML分离&lt;/li&gt;
&lt;li&gt;减少DNS查询&lt;/li&gt;
&lt;li&gt;最小化JavaScript&lt;/li&gt;
&lt;li&gt;避免重定向&lt;/li&gt;
&lt;li&gt;减少重复的脚本&lt;/li&gt;
&lt;li&gt;定义ETags&lt;/li&gt;
&lt;li&gt;使AJAX可缓存化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.philwhln.com/quoras-technology-examined&quot; title=&quot;quoras technology examined&quot;&gt;quoras technology examined&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://coolshell.cn/articles/4936.html&quot; title=&quot;http:coolshell.cn/articles/4936.html&quot;&gt;http://coolshell.cn/articles/4936.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Stack Overflow的系统架构</title>
   <link href="/blog/2011/07/14/stack-overflow-architecture/"/>
   <updated>2011-07-14T15:31:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/07/14/stack-overflow-architecture</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com&quot; title=&quot;Stack Overflow&quot;&gt;Stack Overflow&lt;/a&gt;是我最喜欢的网站之一，无论是他的问题和回答的质量，内容相关度还是用户体验都是非常优秀的。就我自己而言，如果在编程中遇到问题，我会第一时间上去搜索。如果没有搜到相关的问题，我就会自己提问让老外来回答。一般来说，只要是主流技术，或者说不是太小众的，都会很快得到回答。最主要的是，老外基本上都会非常认真详细地回答你的问题，由于国内没有与之完全对应的网站，就这点来说可以把国内具有类似功能的网站（例如CSDN，ItEye等）暴出屎来。&lt;/p&gt;

&lt;p&gt;今天无意中看到一篇介绍Stack Overflow架构的文章后觉得非常有价值，所以决定翻译成中文，供以后参考。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm7.static.flickr.com/6128/5940332610_b983b2c9a6.jpg&quot; alt=&quot;stackoverflow&quot; title=&quot;stackoverflow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Stack Overflow目前已经有超过1600万用户，并且每月有将近9500万PV。Stack Overflow已经发展并扩大成为了&lt;a href=&quot;http://stackexchange.com&quot; title=&quot;Stack Exchange Network&quot;&gt;Stack Exchange Network&lt;/a&gt;。Stack Exchange Network现在包括&lt;strong&gt;Stack Overflow&lt;/strong&gt;, &lt;strong&gt;Server Fault&lt;/strong&gt;, 和 &lt;strong&gt;Super User&lt;/strong&gt;，旗下拥有43个网站,并且还在以成倍的速度增长。&lt;/p&gt;

&lt;p&gt;Stack Overflow不变的是对他们做的事保有开放的态度，这也是写这篇的原因。最近有一系列关于其成长的文章：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/stack-exchanges-architecture-in-bullet-points/&quot;&gt;Stack Exchange’s Architecture in Bullet Points&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/1432571770/&quot;&gt;Stack Overflow’s New York Data Center&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/1097492931/&quot;&gt;Designing For Scalability of Management and Fault Tolerance&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/2011/01/stack-overflow-search-now-81-less-crappy/&quot;&gt;Stack Overflow Search &amp;mdash; Now 81% Less&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/2010/01/stack-overflow-network-configuration/&quot;&gt;Stack Overflow Network Configuration&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/69164/does-stackoverflow-use-caching-and-if-so-how&quot;&gt;Does StackOverflow use caching and if so, how?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/10369/which-tools-and-technologies-build-the-stack-exchange-network&quot;&gt;Which tools and technologies build the Stack Exchange Network?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;StackOverflow在这段时间里一些明显的变化有：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;快速增长. 更多的用户，更多的PV，更多的数据中心，更多的网站，更多的开发人员，更多的操作系统，更多的数据库，更多的服务器。很多的&lt;a href=&quot;http://blog.stackoverflow.com/2011/01/state-of-the-stack-2010-a-message-from-your-ceo/&quot;&gt;更多&lt;/a&gt;。
    &lt;/li&gt;
    &lt;li&gt;Linux. Stack Overflow被人熟知的是它大量使用部署了Windows的服务器, 但是他们现在使用很多部署了Linux的服务器来跑 HAProxy, Redis, Bacula, Nagios, 日志和路由。 所有需要&lt;a href=&quot;http://blog.serverfault.com/post/1097492931/&quot;&gt;并行处理&lt;/a&gt;的功能都会交给Linux处理。&lt;/li&gt;
    &lt;li&gt;容错. Stack Overflow现在&lt;a href=&quot;http://blog.stackoverflow.com/2010/01/stack-overflow-network-configuration/&quot;&gt;使用两个不同网络线路接入的交换机&lt;/a&gt; 他们增加了冗余的服务器，一些功能也被转移到了第二个数据中心。&lt;/li&gt;
    &lt;li&gt;NoSQL. Redis现在作为整站的&lt;a href=&quot;http://meta.stackoverflow.com/questions/69164/does-stackoverflow-use-caching-and-if-so-how&quot;&gt;缓存层&lt;/a&gt;在使用。以前并没有一个单独的缓存层，平且在Linux服务器上使用NoSQL，所以这是一个很大的变化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;遗憾的是，我没有找到我所关心的问题的答案，比如他们是怎么在这么多不同的特性中处理&lt;a href=&quot;http://en.wikipedia.org/wiki/Multitenancy&quot;&gt;Multitenancy（多租户）&lt;/a&gt;的问题的，但是还是有很多东西可以学习。下面是一些数据汇总：&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;统计信息&lt;/h2&gt;

&lt;ul&gt;
    &lt;li&gt;每月9500万次浏览量&lt;/li&gt;
    &lt;li&gt;每秒800个HTTP请求&lt;/li&gt;
    &lt;li&gt;每秒180个DNS请求&lt;/li&gt;
    &lt;li&gt;每秒55M流量&lt;/li&gt;
    &lt;li&gt;1600万个用户（Stack Overflow的流量在2010年增长了131%，全球每月不重复访客增至1660万人）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数据中心&lt;/h2&gt;

&lt;ul&gt;
    &lt;li&gt;1个机架放在俄勒冈州的Peak Internet（用于放置chat和Data Explorer）&lt;/li&gt;
    &lt;li&gt;2个机架放在纽约州的Peer 1（用于放置Stack Exchange Network的其余部分）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;硬件设备&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;10台戴尔R610 IIS Web服务器（3台专门用于Stack Overflow）：1个英特尔至强处理器E5640，2.66 GHz四核，8线程；16 GB内存；Windows Server 2008 R2&lt;/li&gt;
    &lt;li&gt;2台戴尔R710数据库服务器：2个英特尔至强处理器X5680，3.33 GHz；64 GB内存；8个硬盘；SQL Server 2008 R2&lt;/li&gt;
    &lt;li&gt;2台戴尔R610 HAProxy服务器：1个英特尔至强处理器E5640，2.66 GHz；4 GB内存；Ubuntu Server&lt;/li&gt;
    &lt;li&gt;2台戴尔R610 Redis服务器：2个英特尔至强处理器E5640，2.66 GHz；16 GB内存；CentOS&lt;/li&gt;
    &lt;li&gt;1台戴尔R610 Linux备份服务器，运行Bacula：1个英特尔至强处理器E5640，2.66 GHz；32 GB内存&lt;/li&gt;
    &lt;li&gt;1台戴尔R610 Linux管理服务器，用于Nagios和日志：1个英特尔至强处理器E5640，2.66 GHz；32 GB内存&lt;/li&gt;
    &lt;li&gt;2个戴尔R610 VMWare ESXi域控制器：1个英特尔至强处理器E5640，2.66 GHz；16 GB内存；2只Linux路由器；5台戴尔Power Connect交换机&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;开发工具&lt;/h2&gt;

&lt;ul&gt;
    &lt;li&gt;编程语言：C#（ASP.NET）&lt;/li&gt;
    &lt;li&gt;开发环境：Visual Studio 2010 Team Suite&lt;/li&gt;
    &lt;li&gt;开发框架：Microsoft ASP.NET Framework 4.0&lt;/li&gt;
    &lt;li&gt;Web框架：ASP.NET MVC 3&lt;/li&gt;
    &lt;li&gt;视图引擎：Razor&lt;/li&gt;
    &lt;li&gt;Ajax框架：jQuery 1.4.2&lt;/li&gt;
    &lt;li&gt;数据访问：LINQ to SQL，一些原生SQL&lt;/li&gt;
    &lt;li&gt;版本控制：Mercurial和Kiln&lt;/li&gt;
    &lt;li&gt;代码比较：Beyond Compare 3&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;软件与技术&lt;/h2&gt;

&lt;ul&gt;
    &lt;li&gt;堆栈技术：&lt;a href=&quot;http://blog.stackoverflow.com/2009/03/stack-overflow-and-bizspark/&quot;&gt;BizSpark&lt;/a&gt; 的 &lt;a href=&quot;http://stackoverflow.com/questions/177901/what-does-wisc-stack-mean&quot;&gt;WISC&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;操作系统：&lt;a href=&quot;http://www.microsoft.com/windowsserver2008/en/us/default.aspx&quot;&gt;Windows Server 2008 R2 x64&lt;/a&gt;，&lt;a href=&quot;http://www.ubuntu.com/server&quot;&gt;Ubuntu Server&lt;/a&gt;，&lt;a href=&quot;http://www.centos.org/&quot;&gt;CentOS&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;数据库：运行于Microsoft Windows Server 2008 Enterprise Edition x64 的&lt;a href=&quot;http://www.microsoft.com/sqlserver/en/us/default.aspx&quot;&gt;SQL Server 2008 R2&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;WEB服务器：IIS7.0&lt;/li&gt;
    &lt;li&gt;负载均衡：&lt;a href=&quot;http://haproxy.1wt.eu/&quot;&gt;HAProxy&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;缓存：&amp;nbsp;&lt;a href=&quot;http://redis.io/&quot;&gt;Redis&lt;/a&gt;（分布式缓存）&lt;/li&gt;
    &lt;li&gt;代码部署：&lt;a href=&quot;http://sourceforge.net/projects/ccnet/&quot;&gt;CruiseControl.NET&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;搜索系统：&lt;a href=&quot;http://incubator.apache.org/lucene.net/&quot;&gt;Lucene.NET&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;备份系统：&lt;a href=&quot;http://www.bacula.org/en/&quot;&gt;Bacula&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;监控系统：&lt;a href=&quot;http://www.nagios.org/&quot;&gt;Nagios&lt;/a&gt;&amp;nbsp;(使用 n2rrd 和 drraw 插件)&lt;/li&gt;
    &lt;li&gt;日志分析：&lt;a href=&quot;http://www.splunk.com/&quot;&gt;Splunk&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;SQL Server监控：&lt;a href=&quot;http://www.red-gate.com/products/dba/sql-monitor/&quot;&gt;SQL Monitor from Red Gate&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;DNS解析：&lt;a href=&quot;http://www.isc.org/software/bind&quot;&gt;Bind&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;远程控制：&lt;a href=&quot;http://www.wowwee.com/en/products/tech/telepresence/rovio/rovio&quot;&gt;Rovio&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;外部监控：&lt;a href=&quot;http://tools.pingdom.com/&quot;&gt;Pingdom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;外部组件（作为一部分开发工具并没有包含在代码中）&lt;/h2&gt;

&lt;ul&gt;
    &lt;li&gt;reCAPTCHA&lt;/li&gt;
    &lt;li&gt;DotNetOpenId&lt;/li&gt;
    &lt;li&gt;WMD - Now developed as open source. See github network graph&lt;/li&gt;
    &lt;li&gt;Prettify&lt;/li&gt;
    &lt;li&gt;Google Analytics&lt;/li&gt;
    &lt;li&gt;Cruise Control .NET&lt;/li&gt;
    &lt;li&gt;HAProxy&lt;/li&gt;
    &lt;li&gt;Cacti&lt;/li&gt;
    &lt;li&gt;MarkdownSharp&lt;/li&gt;
    &lt;li&gt;Flot&lt;/li&gt;
    &lt;li&gt;Nginx&lt;/li&gt;
    &lt;li&gt;Kiln&lt;/li&gt;
    &lt;li&gt;CDN: 没有使用CDN，所有静态内容由&lt;a href=&quot;http://sstatic.net&quot;&gt;sstatic.net&lt;/a&gt;提供。sstatic.net是一个快速的、无cookie的域，用于将静态内容分发到Stack Exchange系列网站。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;开发人员和系统管理员&lt;/h2&gt;

&lt;ul&gt;
    &lt;li&gt;14名开发人员&lt;/li&gt;
    &lt;li&gt;2名系统管理员&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;内容&lt;/h2&gt;

&lt;ul&gt;
    &lt;li&gt;协议: Creative Commons Attribution-Share Alike 2.5 Generic&lt;/li&gt;
    &lt;li&gt;标准: OpenSearch, Atom&lt;/li&gt;
    &lt;li&gt;托管: PEAK Internet&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;每个站点有三种不同的缓存：本地缓存、站点缓存和全局缓存&lt;/h2&gt;

&lt;ul&gt;本地缓存：只能被一对服务器或站点访问。&lt;/ul&gt;
&lt;ul&gt;
    
        &lt;li&gt;为了限制网络等待时间，他们使用本地“L1”缓存。基本上是在一台服务器上用HttpRuntime.Cache缓存最近设置或读取的数据。这样就可以使在网络上的缓存查找开销减少到0字节。
        &lt;/li&gt;
        &lt;li&gt;本地缓存包含用户session和待定的查看计数更新。&lt;/li&gt;
        &lt;li&gt;本地缓存只在内存中，没有网络或数据库的访问。&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;站点缓存：可以被单个站点的任何一个服务器上的实例访问。&lt;/ul&gt;
&lt;ul&gt;
        &lt;li&gt;绝大多数的数据被缓存在这里，比如热门问题的id列表和用户的回答被接受的百分比是很好的例子。&lt;/li&gt;
        &lt;li&gt;站点缓存使用的是Redis（在一个不同的数据库里，为了更方便调试）。&lt;/li&gt;
        &lt;li&gt;Redis非常快，导致缓存查找中最慢的部分变成了从网络读字节或写字节到网络中去。
        &lt;/li&gt;
        &lt;li&gt;
        数据是被压缩过后再发送到Redis的。有很多的CPU，并且大多数数据是字符串类型的，所以他们可以得到很好的压缩比率。
        &lt;/li&gt;
        &lt;li&gt;
        Redis所在服务器的CPU使用率是0%。
        &lt;/li&gt;
    &lt;/ul&gt;

&lt;ul&gt;全局缓存：所有站点和服务器共享。&lt;/ul&gt;

&lt;ul&gt;
        &lt;li&gt;包括收件箱，API使用的引用和一些其他全局数据。&lt;/li&gt;
        &lt;li&gt;全局缓存使用Redis（在DB 0，同样为了调试方便）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-9&quot;&gt;更多的架构和经验&lt;/h2&gt;

&lt;ul&gt;
    &lt;li&gt;使用HAProxy替代Windows NLB 的原因是：HAProxy不仅使用简单而且还是免费的，通过Hyper-V可以成为优秀的网络上的一个512M虚拟机“设备”。它运行在服务器的前端，所以对服务器来说完全透明，而且作为一个不同的网络层，比起和windows的配置混在一起，更容易故障检测，&lt;/li&gt;
    &lt;li&gt;没有使用CDN，因为就连亚马逊这样“便宜的”CDN，如果考虑捆绑到现有主机方案中的带宽，其费用都相当昂贵的。根据亚马逊的CDN费用和Stack Overflow使用的带宽，每月至少要支付1000美元。&lt;/li&gt;
    &lt;li&gt;为了快速恢复，把数据备份到磁盘上。为了历史归档，把数据备份到磁带（tape）上。&lt;/li&gt;
    &lt;li&gt;SQL Server对的全文搜索的集成相当差，bug多，功能少，所以改用了Lucene。&lt;/li&gt;
    &lt;li&gt;最让人感兴趣的是他们能够确保可以处理的HTTP请求峰值。&lt;/li&gt;
    &lt;li&gt;所有特性都运行在Stack Exchange平台上。Stack Overflow、Super User、Server Fault、Meta、WebApps和Meta Web Apps都运行同一软件上。&lt;/li&gt;
    &lt;li&gt;对StackExchange的用户进行区分是因为拥有不同专业技能的人不应该在不同主题的站点之间穿梭。&lt;a href=&quot;http://meta.stackoverflow.com/questions/69422/why-separate-stack-exchange-accounts&quot;&gt;你可以是世界上最出色的大厨，但这并不能说明修复服务器的能力&lt;/a&gt;。&lt;/li&gt;
    &lt;li&gt;尽可能缓存所有数据。&lt;/li&gt;
    &lt;li&gt;所有匿名用户访问的页面都由&lt;a href=&quot;http://learn.iis.net/page.aspx/154/walkthrough-iis-70-output-caching/&quot;&gt;Output Caching&lt;/a&gt;缓存。&lt;/li&gt;
    
    &lt;li&gt;
    大多数数据会在超时时间段后过期（通常是几分钟），并且他们不会被显示地删除。
    当需要特定的缓存失效时，使用&lt;a href=&quot;http://code.google.com/p/redis/wiki/PublishSubscribe&quot;&gt;Redis messaging&lt;/a&gt;向“L1”缓存发送删除通知。
    &lt;/li&gt;
    &lt;li&gt;
    Joel Spolsky并不是微软的忠实用户，他并不对Stack Overflow做技术决策，他认为微软许可发放是个错误。认为你自己是正确的&lt;a href=&quot;http://news.ycombinator.com/item?id=2284900&quot;&gt;Hacker News commentor&lt;/a&gt;。
    &lt;/li&gt;
    &lt;li&gt;
    他们在&lt;a href=&quot;http://www.intel.com/design/flash/nand/extreme/index.htm&quot;&gt;Intel X25 solid state drives&lt;/a&gt;上做RAID 10来作为IO系统。RAID解决了可靠性的顾虑，并且对比FusionIO，SSD性能更好，价格更便宜。
    &lt;/li&gt;
    &lt;li&gt;
    全部的微软许可&lt;a href=&quot;http://news.ycombinator.com/item?id=2285931&quot;&gt;费用&lt;/a&gt;大约是$242K，因为Stack Overflow使用的是Bizspark，所以并没有支付全价，但这已经是他们可能支付的最大费用。
    &lt;/li&gt;
    &lt;li&gt;
    &lt;a href=&quot;http://blog.serverfault.com/post/broadcom-die-mutha/&quot;&gt;Intel NICs are replacing Broadcom NICs&lt;/a&gt;和他们主要的生产环境服务器。这样就解决了连接丢失，包丢失和ARP表冲突。
    &lt;/li&gt;

&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;相关文章&lt;/h2&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://news.ycombinator.com/item?id=2284900&quot;&gt;Hacker News Thread on this Post&lt;/a&gt; / &lt;a href=&quot;http://www.reddit.com/r/programming/comments/fwpik/stackoverflow_scales_using_a_mixture_of_linux_and/&quot;&gt;Reddit Thread&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/stack-exchanges-architecture-in-bullet-points/&quot;&gt;Stack Exchange’s Architecture in Bullet Points&lt;/a&gt; / &lt;a href=&quot;http://news.ycombinator.com/item?id=2207789&quot;&gt;HackerNews Thread&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/1432571770/&quot;&gt;Stack Overflow’s New York Data Center&lt;/a&gt; - &lt;span style=&quot;font-family: 'Trebuchet MS',Arial,'Bitstream Vera Sans',sans-serif; line-height: 17px; color: rgb(0, 0, 0);&quot;&gt;hardware of the various machines?&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/1097492931/&quot;&gt;Designing For Scalability of Management and Fault Tolerance&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/&quot;&gt;Stack Overflow Blog&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/2011/01/stack-overflow-search-now-81-less-crappy/&quot;&gt;Stack Overflow Search &amp;mdash; Now 81% Less Crappy&lt;/a&gt;&amp;nbsp;- Lucene is now running on an underused cluster.&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/2011/01/state-of-the-stack-2010-a-message-from-your-ceo/&quot;&gt;State of the Stack 2010 (a message from your CEO)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/2010/01/stack-overflow-network-configuration/&quot;&gt;Stack Overflow Network Configuration&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/69164/does-stackoverflow-use-caching-and-if-so-how&quot;&gt;Does StackOverflow use caching and if so, how?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/&quot;&gt;Meta StackOverflow&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/6435/how-does-stackoverflow-handle-cache-invalidation&quot;&gt;How does StackOverflow handle cache invalidation?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/10369/which-tools-and-technologies-build-the-stack-exchange-network&quot;&gt;Which tools and technologies build the Stack Exchange Network?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/2765/how-does-stack-overflow-handle-spam&quot;&gt;How does Stack Overflow handle spam?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/our-storage-decision/&quot;&gt;Our Storage Decision&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/4766/how-are-hot-questions-selected&quot;&gt;How are “Hot” Questions Selected?&lt;/a&gt;&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/20473/how-are-related-questions-selected&quot;&gt;How are “related” questions selected?&lt;/a&gt;&amp;nbsp;- the title, the question body, and the tags.&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/2010/04/stack-overflow-and-dvcs/&quot;&gt;Stack Overflow and DVCS&lt;/a&gt;&amp;nbsp;- Stack Overflow selects Mercurial for source code control.&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://chat.stackexchange.com/rooms/127/the-comms-room&quot;&gt;Server Fault Chat Room&lt;/a&gt;&amp;nbsp;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://github.com/ServiceStack/ServiceStack.Redis&quot;&gt;C# Redis Client&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/broadcom-die-mutha/&quot;&gt;Broadcom, Die Mutha&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;http://highscalability.com/blog/2011/3/3/stack-overflow-architecture-update-now-at-95-million-page-vi.html&quot; title=&quot;stack-overflow-architecture-update-now-at-95-million-page-vi&quot;&gt;stack-overflow-architecture-update-now-at-95-million-page-vi&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>方法的标记参数</title>
   <link href="/blog/2011/06/28/flag-argument/"/>
   <updated>2011-06-28T15:16:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/06/28/flag-argument</id>
   <content type="html">&lt;p&gt;Martin Fowler在他的博客里发表了一篇关于方法的标志参数（Flag Argument）的博文，原文参见&lt;a href=&quot;http://martinfowler.com/bliki/FlagArgument.html&quot; title=&quot;http://martinfowler.com/bliki/FlagArgument.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我读完后立刻开始回忆起我以前的做法来，假设有这样一个场景，我们有两类人（即有钱人和穷人），现在房地产那边需要定义个买房子的方法，如果是有钱人就能买房；反之，如果是穷人则买不了房子。好了，如果是我的话，我想我会这么定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Customer buyHouse(Customer customer, boolean isRich){
    //do something
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种作法非常简单，只要在这个方法里再根据这个布尔值判断一下就行了。但是在我看完这篇博文后，我的想法发生了比较大的改变。这样定义方法虽然简单，但对于阅读代码的人来说却很头大。如果结合真实情况来看，这个&lt;strong&gt;isRich&lt;/strong&gt;参数在大多数情况下都要通过调用另外一个方法计算出来再传入这个方法。也就是说，在调用这个方法的时候，&lt;strong&gt;isRich&lt;/strong&gt;是&lt;strong&gt;True&lt;/strong&gt;还是&lt;strong&gt;False&lt;/strong&gt;是不确定的。&lt;/p&gt;

&lt;p&gt;这样做有问题吗？按照Martin Fowler在博文上写的，他偏向于定义两个方法来处理这种情况，即：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Customer richesCanBuyHouse(Customer customer){...}
public Customer poorsCantBuyHouse(Customer customer){...}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Martin Fowler的理由是调用这个方法的时候，就能清楚的知道程序员的意图，而不是要记住这个标记参数的意义。经过思考和实验，我发现将方法中的功能尽量单一化的做法将使整个系统收益，不仅可以提高测试覆盖率，易于定位bug，而且还易于修改和重构。&lt;/p&gt;

&lt;p&gt;Martin Fowler还举了另外一个例子，即布尔值的Set方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//提倡这种做法
void setOn();
void setOff();

//而不是这种做法
void setSwitch(boolean on);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子其实和上面的例子差不多，虽然多了一个方法，但是程序将会变得清晰易读。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Ubuntu下编译安装Vim</title>
   <link href="/blog/2011/06/25/compile-and-install-vim-on-ubuntu/"/>
   <updated>2011-06-25T14:56:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/06/25/compile-and-install-vim-on-ubuntu</id>
   <content type="html">&lt;h2 id=&quot;vim&quot;&gt;编译安装最新版本Vim&lt;/h2&gt;

&lt;p&gt;我们都知道在Ubuntu下如果直接在终端中用命令安装Vim，那么安装的都不是最新版本。如果要想安装最新版本只有下载最新版源代码包，然后再编译安装。&lt;/p&gt;

&lt;p&gt;首先，Vim最新版源代码包可以在 &lt;a href=&quot;http://www.vim.org/&quot; title=&quot;官网&quot;&gt;官网&lt;/a&gt; 下载，下载源代码包到本地Ubuntu主机后，解压缩，进入该目录，进行配置，编译和安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar xzvf vim-7.3.tar.bz2
cd vim73
./configure --prefix=/usr/local/vim --enable-rubyinterp --enable-multibyte --enable-gui=gnome2 --enable-xim --enable-fontset --with-features=huge
make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果安装出现错误则有可能是目录的权限问题，试试下面的命令吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo chmod 777 /usr/bin
sudo chmod 777 /usr/local/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，如果不出什么意外的话，Vim应该已经安装好了，接下来就是要安装和配置插件了。首先，要在主目录里新建&lt;strong&gt;.vimrc&lt;/strong&gt;文件，然后在这个文件里配置Vim。
配置可以参考&lt;a href=&quot;https://github.com/panweizeng/env&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果运行错误：  (gvim:6667): Gtk-WARNING **: Invalid input string&lt;/p&gt;

&lt;p&gt;解决办法是在主目录里 CTRL+H 显示 .bashrc 文件，然后在这里文件里添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export  LANG=zh_CN.UTF-8;
export  LC_CTYPE=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_NUMERIC=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_TIME=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_COLLATE=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_MONETARY=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_MESSAGES=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_PAPER=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_NAME=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_ADDRESS=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_TELEPHONE=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_MEASUREMENT=&amp;quot;zh_CN.UTF-8&amp;quot;;
export  LC_IDENTIFICATION=&amp;quot;zh_CN.UTF-8&amp;quot;;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vimruby&quot;&gt;配置Vim对Ruby的支持&lt;/h2&gt;

&lt;p&gt;我主要用Vim来写Ruby代码，所以比如代码高亮，自动补全等都是必须的:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;安装Ruby也可以去&lt;a href=&quot;http://www.ruby-lang.org/&quot; title=&quot;官网&quot;&gt;官网&lt;/a&gt;上下载最新版本，然后编译安装。  &lt;/li&gt;
  &lt;li&gt;设置环境变量。在 .bashrc 文件里添加如下代码：export PATH=/usr/local/ruby/bin:$PATH&lt;/li&gt;
  &lt;li&gt;下载&lt;a href=&quot;http://rubyforge.org/projects/vim-ruby/&quot; title=&quot;vim-ruby&quot;&gt;vim-ruby&lt;/a&gt;插件，解压后复制道Vim安装目录里。现在开始写Ruby代码吧，然后按F5看下运行结果是不是出来了呢。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后Show一下我的Vim：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm6.static.flickr.com/5067/5868623217_70b3bcae76_z.jpg&quot; alt=&quot;vim&quot; title=&quot;vim&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JMeter的简单介绍</title>
   <link href="/blog/2011/06/11/a-brief-introduction-to-jmeter/"/>
   <updated>2011-06-11T14:37:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/06/11/a-brief-introduction-to-jmeter</id>
   <content type="html">&lt;div style=&quot;width:600px&quot;&gt; &lt;strong style=&quot;display:block;margin:12px 0 4px&quot;&gt;&lt;a href=&quot;http://www.slideshare.net/Foredoomed/abriefintroductiontojmeter&quot; title=&quot;A_Brief_Introduction_to_JMeter&quot; target=&quot;_blank&quot;&gt;A_Brief_Introduction_to_JMeter&lt;/a&gt;&lt;/strong&gt; &lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/9351110&quot; width=&quot;600&quot; height=&quot;500&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; &lt;div style=&quot;padding:5px 0 12px&quot;&gt; View more &lt;a href=&quot;http://www.slideshare.net/&quot; target=&quot;_blank&quot;&gt;presentations&lt;/a&gt; from &lt;a href=&quot;http://www.slideshare.net/Foredoomed&quot; target=&quot;_blank&quot;&gt;Foredoomed&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>悲凉和无奈</title>
   <link href="/blog/2011/06/09/nothing-but-sad/"/>
   <updated>2011-06-09T14:28:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/06/09/nothing-but-sad</id>
   <content type="html">&lt;p&gt;今天一下子看完了两本我认为非常好的书，一本是时寒冰老师的《经济大棋局，我们怎么办》，另一本是彼得.海斯勒（中文名：何伟）的《寻路中国》。&lt;/p&gt;

&lt;p&gt;读完这两本书，我的心情就是悲凉中参杂着无奈，无奈中渗透着悲凉。时寒冰老师用10年的时间写成的这本书来告诉我们中国人，现在的中国已经走到了什么地步。他用通俗易懂的语言告诉我们老百姓世界经济的走势和规律。时老师还在苦口婆心的给政府提建议，可是效果有多少呢？正如时老师的预言，因果报应将在不久的将来真正到来。&lt;/p&gt;

&lt;p&gt;《寻路中国》又是另一个风格，讲述的是作者在中国的生活故事和见闻，作者何伟以他一个美国人的角度审视着中国，特别是2002年以后经济发展迅速的中国。在书中可以看到作者对中国的了解和研究之深足以让很多中国专家汗颜。那是整个中国的缩影，而在作者的眼中是那么的奇怪。&lt;/p&gt;

&lt;p&gt;最近还在看另一本书《春秋大义》，再结合上面两本书，我突然发现一切是那么的自然。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>NoSQL数据库比较</title>
   <link href="/blog/2011/06/03/comparison-of-nosql-databases/"/>
   <updated>2011-06-03T13:59:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/06/03/comparison-of-nosql-databases</id>
   <content type="html">&lt;p&gt;随着Web2.0时代的来临以及宽带技术的迅猛发展，许多Web应用都感受到了来自高并发以及高数据量的挑战。而大多数情况下这种挑战来自于数据库，即二维关系型数据库的缺陷导致了RDBMS成为了高并发和高数据量下的瓶颈。正是为了消除这种瓶颈，才诞生了NoSQL。NoSQL是当下最热的技术话题，而且越来越多的公司开始选择NoSQL产品来提高Web应用的性能及伸缩性，我们完全可以想象在不远的将来NoSQL取代现在的关系型数据库，成为数据存储的第一选择。&lt;/p&gt;

&lt;h2 id=&quot;nosql&quot;&gt;NoSQL数据库的分类&lt;/h2&gt;

&lt;p&gt;NoSQL按存储方式主要分为四类：&lt;/p&gt;

&lt;h3 id=&quot;key-values-stores&quot;&gt;Key-values Stores&lt;/h3&gt;

&lt;p&gt;主要的想法是用hash表，里面包括一个unique key和指向特定数据的指针。Key-value 模型是最简单和最容易实现的. 但是它对查询和更新部分数据时效率不高。&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tr&gt;
&lt;td&gt;Examples&lt;/td&gt;
&lt;td&gt;Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;典型应用场景&lt;/td&gt;
&lt;td&gt;内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据模型&lt;/td&gt;
&lt;td&gt;Key 指向 Value 的键值对，通常用hash table来实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;强项&lt;/td&gt;
&lt;td&gt;查找速度快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;弱项&lt;/td&gt;
&lt;td&gt;数据无结构化，通常只被当作字符串或者二进制数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;document-databases&quot;&gt;Document Databases&lt;/h3&gt;

&lt;p&gt;这个模型是包含key-value集合的文档，并且这个文档被标记过版本的。这些半结构文档是以类似于JSON的形式存储。Document databases基本上是更高级的Key-value形式，允许每个key的value可以多级嵌套。Document databases 支持更有效的查询。&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tr&gt;
&lt;td&gt;Examples&lt;/td&gt;
&lt;td&gt;CouchDB, MongoDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;典型应用场景&lt;/td&gt;
&lt;td&gt;Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据模型&lt;/td&gt;
&lt;td&gt;Key-Value对应的键值对，Value为结构化数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;强项&lt;/td&gt;
&lt;td&gt;数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;弱项&lt;/td&gt;
&lt;td&gt;查询性能不高，而且缺乏统一的查询语法。&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;column-family-stores&quot;&gt;Column Family Stores&lt;/h3&gt;

&lt;p&gt;这类NoSQL主要是用来存储和处理大容量分布式数据。仍然有key，但指向的是多列，并且列是由column family来组织。&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tr&gt;
&lt;td&gt;Examples&lt;/td&gt;
&lt;td&gt;Cassandra, HBase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;典型应用场景&lt;/td&gt;
&lt;td&gt;分布式的文件系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据模型&lt;/td&gt;
&lt;td&gt;以列簇式存储，将同一列数据存在一起&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;强项&lt;/td&gt;
&lt;td&gt;查找速度快，可扩展性强，更容易进行分布式扩展&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;弱项&lt;/td&gt;
&lt;td&gt;功能相对局限&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;graph-databases&quot;&gt;Graph Databases&lt;/h3&gt;

&lt;p&gt;这类NoSQL的结构不是一般的二维表结构，而是更有弹性的图形模型。并且需要指定数据模型来查询这类数据库。&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tr&gt;
&lt;td&gt;Examples&lt;/td&gt;
&lt;td&gt;Neo4J, InfoGrid, Infinite Graph&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;典型应用场景&lt;/td&gt;
&lt;td&gt;社交网络，推荐系统等。专注于构建关系图谱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据模型&lt;/td&gt;
&lt;td&gt;图结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;强项&lt;/td&gt;
&lt;td&gt;利用图结构相关算法。比如最短路径寻址，N度关系查找等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;弱项&lt;/td&gt;
&lt;td&gt;很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rdbmsnosql&quot;&gt;RDBMS和NoSQL的选择&lt;/h2&gt;

&lt;p&gt;NoSQL: &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实时状态或分析&lt;/li&gt;
  &lt;li&gt;日志或归档&lt;/li&gt;
  &lt;li&gt;社交计算&lt;/li&gt;
  &lt;li&gt;外部数据Feed集成&lt;/li&gt;
  &lt;li&gt;前端顺序处理系统&lt;/li&gt;
  &lt;li&gt;企业内容管理服务&lt;/li&gt;
  &lt;li&gt;处理非常高负载的存储能力&lt;/li&gt;
  &lt;li&gt;对于持久化数据有非常多的写操作&lt;/li&gt;
  &lt;li&gt;希望具有水平扩展的能力&lt;/li&gt;
  &lt;li&gt;如果你需要动态查询&lt;/li&gt;
  &lt;li&gt;简单的查询语句(没有“join”)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RDBMS:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;希望有高负责情况下的存储能力，但是主要的是读操作&lt;/li&gt;
  &lt;li&gt;比起优雅的数据结构，你更看重性能&lt;/li&gt;
  &lt;li&gt;你需要强大的SQL查询语言&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mongodbredis&quot;&gt;MongoDB和Redis的比较&lt;/h2&gt;

&lt;h3 id=&quot;mongodb&quot;&gt;MongoDB的特性：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;用C++实现的&lt;/li&gt;
  &lt;li&gt;保留了一些SQL的友好的特性（查询，索引）&lt;/li&gt;
  &lt;li&gt;在AGPL许可下发布&lt;/li&gt;
  &lt;li&gt;自定义的二进制协议（BSON）&lt;/li&gt;
  &lt;li&gt;Master/slave形式的数据同步&lt;/li&gt;
  &lt;li&gt;查询语句是javascript表达式&lt;/li&gt;
  &lt;li&gt;在服务器端执行任意的javascript函数&lt;/li&gt;
  &lt;li&gt;比起CouchDB，有更好的即时更新（update-in-place）性能&lt;/li&gt;
  &lt;li&gt;内建分片&lt;/li&gt;
  &lt;li&gt;用内存映射存储数据&lt;/li&gt;
  &lt;li&gt;追求性能而不是特性&lt;/li&gt;
  &lt;li&gt;一旦崩溃，它需要去修复表&lt;/li&gt;
  &lt;li&gt;在1.8版本中将有更好的持久性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mongodb-1&quot;&gt;MongoDB的主要事项:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;对于分开的读和写，MongoDB会用一个该死的全局锁。&lt;/li&gt;
  &lt;li&gt;MongoDB没有一个统计计划优化程序。&lt;/li&gt;
  &lt;li&gt;在分片的时候才需要Mongos进程。&lt;/li&gt;
  &lt;li&gt;MongoDB支持Master-Slave和Replica-Sets的数据同步模式。&lt;/li&gt;
  &lt;li&gt;在第二次复制时，MongoDB支持“slave-delay”&lt;/li&gt;
  &lt;li&gt;MongoDB不应该在32位环境下运行。&lt;/li&gt;
  &lt;li&gt;MongoDB会自动记录任何超过100ms的查询语句。&lt;/li&gt;
  &lt;li&gt;如果一个查询语句要消耗较长的一段时间，MongoDB可以用来做性能提高工具。&lt;/li&gt;
  &lt;li&gt;MongoDB不支持multi-master数据同步。他们认为这样保持逻辑简单很好。而且，系统因为不用担心在多master的情况下发生写冲突而简单很多。&lt;/li&gt;
  &lt;li&gt;在复制安装情况下，MongoDB支持一个叫做Arbiter，它的工作就是把结打开。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;redis&quot;&gt;Redis的特性：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;用C++实现的&lt;/li&gt;
  &lt;li&gt;主要特点：Blazing fast&lt;/li&gt;
  &lt;li&gt;在BSD许可下发布&lt;/li&gt;
  &lt;li&gt;协议：Telnet-like&lt;/li&gt;
  &lt;li&gt;以硬盘为后备的内存数据库&lt;/li&gt;
  &lt;li&gt;从2.0后,可以交换到磁盘上&lt;/li&gt;
  &lt;li&gt;Master/slave形式的数据同步&lt;/li&gt;
  &lt;li&gt;简单的keys和values&lt;/li&gt;
  &lt;li&gt;复杂的操作，像ZREVRANGEBYSCORE&lt;/li&gt;
  &lt;li&gt;增长和压缩（对比率和统计有好处）&lt;/li&gt;
  &lt;li&gt;Sets(also union/diff/inter)&lt;/li&gt;
  &lt;li&gt;lists(also a queue; blocking pop)&lt;/li&gt;
  &lt;li&gt;hashes(多属性的对象)&lt;/li&gt;
  &lt;li&gt;在所有这些数据之中，只有Redis支持事务&lt;/li&gt;
  &lt;li&gt;数据可以设置为过期（因为在cache中）&lt;/li&gt;
  &lt;li&gt;Sorted sets（高分数表，对处理查询有好处）&lt;/li&gt;
  &lt;li&gt;发布/订阅和看管数据变化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最佳应用: 对于在可预见的数据库容量下快速改变的数据（绝大部分在内存）。例如：股价，分析，实时数据收集，实时交流。 &lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.monitis.com/index.php/2011/05/22/picking-the-right-nosql-database-tool&quot; title=&quot;picking-the-right-nosql-database-tool&quot;&gt;picking-the-right-nosql-database-tool&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://kkovacs.eu/cassandra-vs-mongodb-vs-couchdb-vs-redis&quot; title=&quot;cassandra-vs-mongodb-vs-couchdb-vs-redis&quot;&gt;cassandra-vs-mongodb-vs-couchdb-vs-redis&lt;/a&gt;  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.nosqlfan.com/html/1727.html&quot; title=&quot;如何选择最适合你的NoSQL数据库&quot;&gt;如何选择最适合你的NoSQL数据库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>如何选择开源许可协议</title>
   <link href="/blog/2011/06/01/how-to-choose-opensource-licenses/"/>
   <updated>2011-06-01T13:43:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/06/01/how-to-choose-opensource-licenses</id>
   <content type="html">&lt;p&gt;转自阮一峰的博客：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1256.photobucket.com/albums/ii494/Foredoomed/opensource_licences_zpsbbbbbe5b.png&quot; alt=&quot;如何选择开源许可协议&quot; /&gt;&lt;/p&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html&quot; title=&quot;如何选择开源许可协议&quot;&gt;如何选择开源许可协议&lt;/a&gt; &lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>屏蔽优酷和土豆广告的方法</title>
   <link href="/blog/2011/05/19/block-advertising-on-youku-and-tudou/"/>
   <updated>2011-05-19T22:58:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/05/19/block-advertising-on-youku-and-tudou</id>
   <content type="html">&lt;p&gt;Windows: C:\WINDOWS\system32\drivers\etc\hosts&lt;/p&gt;

&lt;p&gt;Linux: /etc/hosts&lt;/p&gt;

&lt;p&gt;根据你所用的操作系统，用文本编辑工具打开上面的文件，然后添加下面的代码：&lt;/p&gt;

&lt;p&gt;#优酷&lt;br /&gt;
127.0.0.1 atm.youku.com&lt;br /&gt;
127.0.0.1 Fvid.atm.youku.com&lt;br /&gt;
127.0.0.1 html.atm.youku.com&lt;br /&gt;
127.0.0.1 valb.atm.youku.com&lt;br /&gt;
127.0.0.1 valf.atm.youku.com&lt;br /&gt;
127.0.0.1 valo.atm.youku.com&lt;br /&gt;
127.0.0.1 valp.atm.youku.com&lt;br /&gt;
127.0.0.1 lstat.youku.com&lt;br /&gt;
127.0.0.1 speed.lstat.youku.com&lt;br /&gt;
127.0.0.1 urchin.lstat.youku.com&lt;br /&gt;
127.0.0.1 stat.youku.com&lt;br /&gt;
127.0.0.1 static.lstat.youku.com&lt;br /&gt;
127.0.0.1 valc.atm.youku.com&lt;br /&gt;
127.0.0.1 vid.atm.youku.com&lt;br /&gt;
127.0.0.1 walp.atm.youku.com  &lt;/p&gt;

&lt;p&gt;#土豆&lt;br /&gt;
127.0.0.1 adextensioncontrol.tudou.com&lt;br /&gt;
127.0.0.1 iwstat.tudou.com&lt;br /&gt;
127.0.0.1 nstat.tudou.com&lt;br /&gt;
127.0.0.1 stats.tudou.com&lt;br /&gt;
127.0.0.1 *.p2v.tudou.com*&lt;br /&gt;
127.0.0.1 at-img1.tdimg.com&lt;br /&gt;
127.0.0.1 at-img2.tdimg.com&lt;br /&gt;
127.0.0.1 at-img3.tdimg.com&lt;br /&gt;
127.0.0.1 adplay.tudou.com&lt;br /&gt;
127.0.0.1 adcontrol.tudou.com&lt;br /&gt;
127.0.0.1 stat.tudou.com  &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Facebook的系统架构</title>
   <link href="/blog/2011/05/10/facebook-architecture/"/>
   <updated>2011-05-10T22:46:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/05/10/facebook-architecture</id>
   <content type="html">&lt;ul&gt;
  &lt;li&gt;Web前端用PHP写的。然后，Facebook的HipHop[1]把它转换成C++,用g++编译, 这样做可以提供高性能模板和Web逻辑执行层。&lt;/li&gt;
  &lt;li&gt;业务逻辑用Thrift[2]作为服务暴露处理。这其中的一些服务是用PHP实现的，C++或Java要看服务的需求（也可能使用其他一些语言…)。&lt;/li&gt;
  &lt;li&gt;用Java实现的服务不使用任何一个普通的企业级应用服务器，而是用Facebook为自己定制开发的应用服务器。一开始这样做是被看作重复造轮子，但是当这些服务只（或绝大多数）使用Thrift暴露和消费，Tomcat甚至Jetty的开销可能会非常大，而且还没有加入他们需要的重要的作用。&lt;/li&gt;
  &lt;li&gt;持久化使用MySQL, Memcached[3], Facebook’s Cassandra[4], Hadoop’s HBase[5]。Memcached被用作MySQL的缓存和一般目的的缓存。Facebook的工程师们承认他们目前对于Cassandra的使用正在减少，他们更喜欢使用HBase,因为HBase有简单的一致性模型和MapReduce功能。&lt;/li&gt;
  &lt;li&gt;线下处理使用Hadoop和Hive处理。&lt;/li&gt;
  &lt;li&gt;像日志，点击和feeds等数据用Scribe[6]处理，这些数据被聚集和储存在Hadoop分布式文件系统Scribe-HDFS[7]中, 这样可以让MapReduce做扩展分析。&lt;/li&gt;
  &lt;li&gt;BigPipe[8]是他们定制的技术，这个技术使用流水线逻辑可以加速网页渲染速度。&lt;/li&gt;
  &lt;li&gt;Varnish Cache[9]被用作HTTP代理。他们更喜欢使用Varnish，因为它的高性能表现[10]。&lt;/li&gt;
  &lt;li&gt;使用Haystack处理数10亿的照片的存储，Facebook自己开发的点对点存储解决方案带来的是低等级的优化和只能增加的写操作[11]。&lt;/li&gt;
  &lt;li&gt;Facebook Messages使用的是他们自己的架构，这个架构是构建在基础设施分区和动态集群管理。业务逻辑和持久化被包装在所谓的’单元’（cell）里。每个单元处理一部分用户；随着用户的增长新的单元能够被增加[12]。持久化数据用HBase归档[13]。&lt;/li&gt;
  &lt;li&gt;Facebook Messages的搜索引擎是用存储在HBase里倒转的索引构建的[14]。&lt;/li&gt;
  &lt;li&gt;Facebook搜索引擎的实现细节还不清楚，自动完成搜索使用一个自定义的存储和检索逻辑[15]。&lt;/li&gt;
  &lt;li&gt;聊天功能是在用Erlang开发的Epoll服务器上，而且可以被Thrift访问[16]。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于为这些组件中的每个提供的资源，一些信息和数据:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Facebook被估计拥有超过60,000台服务器[17]。他们最近新的在普赖恩维尔和俄勒冈州的数据中心的硬件都是自己他们自己设计的[18]，而且最近作为Open Compute Project[19]公诸于众。&lt;/li&gt;
  &lt;li&gt;300TB的数据被存储在memcached processes[20]里。&lt;/li&gt;
  &lt;li&gt;Hadoop和Hive集群是用3000台8核，32G内存，12TB硬盘的服务器里[20]。&lt;/li&gt;
  &lt;li&gt;每天1亿的点击量，500亿的照片，缓存着3兆的对象，到2010年7月为止，每天有130TB的日志[21]。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[1] &lt;em&gt;HipHop for PHP&lt;/em&gt;: &lt;a href=&quot;http://developers.facebook.com/blog/post/358&quot; title=&quot;http://developers.facebook.com/b...&quot;&gt;http://developers.facebook.com/b…&lt;/a&gt;&lt;br /&gt;
[2] &lt;em&gt;Thrift&lt;/em&gt;: &lt;a href=&quot;http://thrift.apache.org/&quot; title=&quot;http://thrift.apache.org&quot;&gt;http://thrift.apache.org&lt;/a&gt;&lt;br /&gt;
[3] &lt;em&gt;Memcached&lt;/em&gt;: &lt;a href=&quot;http://memcached.org/&quot; title=&quot;http://memcached.org&quot;&gt;http://memcached.org&lt;/a&gt;&lt;br /&gt;
[4] &lt;em&gt;Cassandra&lt;/em&gt;: &lt;a href=&quot;http://cassandra.apache.org/&quot; title=&quot;http://cassandra.apache.org&quot;&gt;http://cassandra.apache.org&lt;/a&gt;&lt;br /&gt;
[5] &lt;em&gt;HBase&lt;/em&gt;: &lt;a href=&quot;http://hbase.apache.org/&quot; title=&quot;http://hbase.apache.org&quot;&gt;http://hbase.apache.org&lt;/a&gt;&lt;br /&gt;
[6] &lt;em&gt;Scribe&lt;/em&gt;: &lt;a href=&quot;https://github.com/facebook/scribe&quot; title=&quot;https://github.com/facebook/scribe&quot;&gt;https://github.com/facebook/scribe&lt;/a&gt;&lt;br /&gt;
[7] &lt;em&gt;Scribe-HDFS&lt;/em&gt;: &lt;a href=&quot;http://hadoopblog.blogspot.com/2009/06/hdfs-scribe-integration.html&quot; title=&quot;http://hadoopblog.blogspot.com/2...&quot;&gt;http://hadoopblog.blogspot.com/2…&lt;/a&gt;&lt;br /&gt;
[8] &lt;em&gt;BigPipe&lt;/em&gt;: &lt;a href=&quot;http://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919&quot; title=&quot;http://www.facebook.com/notes/fa...&quot;&gt;http://www.facebook.com/notes/fa…&lt;/a&gt;&lt;br /&gt;
[9] &lt;em&gt;Varnish Cache&lt;/em&gt;: &lt;a href=&quot;http://www.varnish-cache.org/&quot; title=&quot;http://www.varnish-cache.org&quot;&gt;http://www.varnish-cache.org&lt;/a&gt;&lt;br /&gt;
[10] &lt;em&gt;Facebook goes for Varnish&lt;/em&gt;: &lt;a href=&quot;http://www.varnish-software.com/customers/facebook&quot; title=&quot;http://www.varnish-software.com/...&quot;&gt;http://www.varnish-software.com/…&lt;/a&gt;&lt;br /&gt;
[11] &lt;em&gt;Needle in a haystack&lt;/em&gt;: efficient storage of billions of photos: &lt;a href=&quot;http://www.facebook.com/note.php?note_id=76191543919&quot; title=&quot;http://www.facebook.com/note.php...&quot;&gt;http://www.facebook.com/note.php…&lt;/a&gt;&lt;br /&gt;
[12] &lt;em&gt;Scaling the Messages Application Back End&lt;/em&gt;: &lt;a href=&quot;http://www.facebook.com/note.php?note_id=10150148835363920&quot; title=&quot;http://www.facebook.com/note.php...&quot;&gt;http://www.facebook.com/note.php…&lt;/a&gt;&lt;br /&gt;
[13] &lt;em&gt;The Underlying Technology of Messages&lt;/em&gt;: &lt;a href=&quot;https://www.facebook.com/note.php?note_id=454991608919&quot; title=&quot;https://www.facebook.com/note.ph...&quot;&gt;https://www.facebook.com/note.ph…&lt;/a&gt;&lt;br /&gt;
[14] &lt;em&gt;The Underlying Technology of Messages Tech Talk&lt;/em&gt;: &lt;a href=&quot;http://www.facebook.com/video/video.php?v=690851516105&quot; title=&quot;http://www.facebook.com/video/vi...&quot;&gt;http://www.facebook.com/video/vi…&lt;/a&gt;&lt;br /&gt;
[15] &lt;em&gt;Facebook’s typeahead search architecture&lt;/em&gt;: &lt;a href=&quot;http://www.facebook.com/video/video.php?v=432864835468&quot; title=&quot;http://www.facebook.com/video/vi...&quot;&gt;http://www.facebook.com/video/vi…&lt;/a&gt;&lt;br /&gt;
[16] &lt;em&gt;Facebook Chat&lt;/em&gt;: &lt;a href=&quot;http://www.facebook.com/note.php?note_id=14218138919&quot; title=&quot;http://www.facebook.com/note.php...&quot;&gt;http://www.facebook.com/note.php…&lt;/a&gt;&lt;br /&gt;
[17] &lt;em&gt;Who has the most Web Servers?&lt;/em&gt;: &lt;a href=&quot;http://www.datacenterknowledge.com/archives/2009/05/14/whos-got-the-most-web-servers/&quot; title=&quot;http://www.datacenterknowledge.c...&quot;&gt;http://www.datacenterknowledge.c…&lt;/a&gt;&lt;br /&gt;
[18] &lt;em&gt;Building Efficient Data Centers with the Open Compute Project&lt;/em&gt;: &lt;a href=&quot;http://www.facebook.com/note.php?note_id=10150144039563920&quot; title=&quot;http://www.facebook.com/note.php...&quot;&gt;http://www.facebook.com/note.php…&lt;/a&gt;&lt;br /&gt;
[19] &lt;em&gt;Open Compute Project&lt;/em&gt;: &lt;a href=&quot;http://opencompute.org/&quot; title=&quot;http://opencompute.org&quot;&gt;http://opencompute.org&lt;/a&gt;&lt;br /&gt;
[20] &lt;em&gt;Facebook’s architecture presentation at Devoxx 2010&lt;/em&gt;: &lt;a href=&quot;http://www.devoxx.com&quot; title=&quot;http://www.devoxx.com&quot;&gt;http://www.devoxx.com&lt;/a&gt;&lt;br /&gt;
[21] &lt;em&gt;Scaling Facebook to 500 millions users and beyond&lt;/em&gt;: &lt;a href=&quot;http://www.facebook.com/note.php?note_id=409881258919&quot; title=&quot;http://www.facebook.com/note.php...&quot;&gt;http://www.facebook.com/note.php…&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;http://www.quora.com/What-is-Facebooks-architecture&quot; title=&quot;What is Facebooks architecture&quot;&gt;What is Facebooks architecture&lt;/a&gt; &lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>《Pragmatic Programmers - Practices of an Agile Developer》读书笔记</title>
   <link href="/blog/2011/05/08/pragmatic-programmers-practices-of-an-agile-developer-note/"/>
   <updated>2011-05-08T21:26:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/05/08/pragmatic-programmers-practices-of-an-agile-developer-note</id>
   <content type="html">&lt;h2 id=&quot;beginning-agility&quot;&gt;Beginning Agility&lt;/h2&gt;

&lt;p&gt;1.Work for Outcome&lt;/p&gt;

&lt;p&gt;2.Quick Fixes Become Quicksand&lt;/p&gt;

&lt;p&gt;3.Criticize Ideas,Not People&lt;/p&gt;

&lt;p&gt;4.Damnthe Torpedoes,Go Ahead&lt;/p&gt;

&lt;h2 id=&quot;feeding-agility&quot;&gt;Feeding Agility&lt;/h2&gt;

&lt;p&gt;5.Keep Up with Change&lt;/p&gt;

&lt;p&gt;6.Invest in Your Team&lt;/p&gt;

&lt;p&gt;7.Know When to Un learn&lt;/p&gt;

&lt;p&gt;8.Question Until You Understand&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.Feel the Rhythm&lt;/strong&gt;
(我觉得软件开发的节奏是很重要的。但是敏捷有迭代周期，不使用敏捷这个节奏就比较难控制了，要么需求变化不大并且前期设计考虑周全。我碰到过一个项目，前期需求分析和设计都做的相当差，到了编码阶段都是在不断的修正前期的错误，时间就这样过去了，前期制定的计划都没有按时完成，项目来不及就往后拖。每次自己感觉编码差不多了可以进行集成测试了，拿到客户那里演示后发觉距离他们的真正的需求还有十万八千里，我们就这样迭代下去。。。交付日期也遥遥无期。。。这个时候是真正陷入了焦油地啊）.&lt;/p&gt;

&lt;h2 id=&quot;delivering-what-users-want&quot;&gt;Delivering What Users Want&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;10.Let Customers Make Decisions&lt;/strong&gt;&lt;br /&gt;
(对于这点我也是深有体会。“拍脑袋”或许就是那些所谓PM的特征吧。。。当我们做的和真正的需求渐行渐远的时候，最终是妥协还是部分妥协，还是以技术难题为理由一意孤行？我的实际经验是部分妥协。。。最终是不是全部妥协就不得而知了）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11.Let Design Guide,Not Dictate&lt;/strong&gt;&lt;br /&gt;
（我觉得文档是必须的，因为“拍脑袋”的PM记性也不怎么样，如果有一天他问我：“你为什么这么做？“的时候直接把文档甩给他，让他涨涨记性）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12.Justify Technology Use&lt;/strong&gt;&lt;br /&gt;
（当遇到用项目套技术的PM的时候，那个无奈啊。。。）&lt;/p&gt;

&lt;p&gt;13.Keep It Releasable&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14.Integrate Early,Integrate Often&lt;/strong&gt;&lt;br /&gt;
（这个集成并不是整个系统的测试，应该把集成的粒度变细。。。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15.Automate Deployment Early&lt;/strong&gt;&lt;br /&gt;
（能用自动化的就用自动化）&lt;/p&gt;

&lt;p&gt;16.Get Frequent Feedback Using Demos&lt;/p&gt;

&lt;p&gt;17.Use Short Iterations,Release in Increments&lt;/p&gt;

&lt;p&gt;18.Fixed Prices Are Broken Promises&lt;/p&gt;

&lt;h2 id=&quot;agile-feed-back&quot;&gt;Agile Feed back&lt;/h2&gt;

&lt;p&gt;19.Put Angels on Your Shoulders&lt;/p&gt;

&lt;p&gt;20.Use It Before You Build It&lt;/p&gt;

&lt;p&gt;21.Different Makes a Difference&lt;/p&gt;

&lt;p&gt;22.Automate Acceptance Testing&lt;/p&gt;

&lt;p&gt;23.Measure Real Progress&lt;/p&gt;

&lt;p&gt;24.Listen to Users&lt;/p&gt;

&lt;h2 id=&quot;agile-coding&quot;&gt;Agile Coding&lt;/h2&gt;

&lt;p&gt;25.Program Intently and Expressively&lt;/p&gt;

&lt;p&gt;26.Communicate in Code&lt;/p&gt;

&lt;p&gt;27.Actively Evaluate Trade-Offs&lt;/p&gt;

&lt;p&gt;28.Code in Increments&lt;/p&gt;

&lt;p&gt;29.Keep It Simple&lt;/p&gt;

&lt;p&gt;30.Write Cohesive Code&lt;/p&gt;

&lt;p&gt;31.Tell,Don’t Ask&lt;/p&gt;

&lt;p&gt;32.Substitute by Contract&lt;/p&gt;

&lt;h2 id=&quot;agile-debugging&quot;&gt;Agile Debugging&lt;/h2&gt;

&lt;p&gt;33.Keep a Solutions Log&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;34.Warnings Are Really Errors&lt;/strong&gt;&lt;br /&gt;
（你能容忍你的项目有上千个warnings吗？至少有些PM能。。。）&lt;/p&gt;

&lt;p&gt;35.Attack Problems in Isolation&lt;/p&gt;

&lt;p&gt;36.Report All Exceptions&lt;/p&gt;

&lt;p&gt;37.Provide Useful Error Messages&lt;/p&gt;

&lt;h2 id=&quot;agile-collaboration&quot;&gt;Agile Collaboration&lt;/h2&gt;

&lt;p&gt;38.Schedule Regular Face Time&lt;/p&gt;

&lt;p&gt;39.Architects Must Write Code&lt;/p&gt;

&lt;p&gt;40.Practice Collective Ownership&lt;/p&gt;

&lt;p&gt;41.Be a Mentor&lt;/p&gt;

&lt;p&gt;42.Allow People to Figure It Out&lt;/p&gt;

&lt;p&gt;43.Share Code Only When Ready&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Review Code&lt;/strong&gt;（现在越发觉得这个的重要性）&lt;/p&gt;

&lt;p&gt;45.Keep Others Informed&lt;/p&gt;

&lt;p&gt;读后感：当老外在深入研究软件开发方法论的时候，我们还在为按时交付软件而苦恼。正确的方 法可以使增加达到正确的结果的可能，但是很多时候我们不重视方法而只重视结果，只要项目完成就可以了，遗憾的是软件开发完成但是他的生命周期并没有结束，为此付出的代价会更加沉重。。。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Initialization-on-demand holder idiom</title>
   <link href="/blog/2011/05/06/initialization-on-demand-holder-idiom/"/>
   <updated>2011-05-06T20:04:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/05/06/initialization-on-demand-holder-idiom</id>
   <content type="html">&lt;p&gt;在软件开发中，需求持有者的初始化指的是一种延迟加载的单例设计模式。它可以在单线程和多线程环境中实现，但是在多线程环境中需要多加小心。&lt;/p&gt;

&lt;p&gt;这个实现版本兼顾性能和线程安全。Bill Pugh的最初的版本是在Steve Quirk的工作基础上改进而来，把LazyHolder.INSTANCE的作用域减小为了private final。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Something {
  private Something() {
  }
 
  private static class LazyHolder {
    private static final Something something = new Something();
  }
 
  public static Something getInstance() {
    return LazyHolder.something;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;工作原理&lt;/h2&gt;

&lt;p&gt;实现是根据详细描述的JVM初始化执行阶段的文档，具体参见Java Language Specification(JLS)的&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4&quot;&gt;12.4&lt;/a&gt;节。&lt;/p&gt;

&lt;p&gt;当JVM加载Something类的时候，它就要被初始化。因为它没有静态变量需要初始化，所以初始化就变得很简单。静态内部类LazyHolder直到JVM决定要执行它时才会被初始化。LazyHolder只有在getInstance方法被调用时才会被执行，并且在第一次执行的时候初始化LazyHolder类。LazyHolder的初始化使静态实例变量something通过私有构造方法被初始化。JLS保证了类的初始化阶段是顺序执行的：单线程， getInstance方法的加载和初始化不需要同步。又因为初始化阶段是串行地写something变量，所以以后的getInstance的并发调用会返回相同的正确初始化后的something类而不会引起额外的同步开销。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;适用情况&lt;/h2&gt;

&lt;p&gt;如果类的初始化是昂贵并且不是线程安全的情况下可以使用这个模式。这个模式的关键是安全地解决了单例模式的多线程同步开销。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;不适用情况&lt;/h2&gt;

&lt;p&gt;如果在Something类的构造方法中有错误代码的情况下使用这个模式会引起无法预料的结果。例如在构造方法中建立外部连接，但是出错了，这种情况下程序会进入到无法恢复的状态中去。这是因为在第一次调用的时候，静态内部类LazyHolder已经被初始化并且被JVM加载了，这时候静态实例变量INSTANCE已经被初始化为null (因为私有构造方法抛出了异常)。任何以后的getInstance调用会引起NoClassDefFoundError错误。&lt;/p&gt;

&lt;p&gt;原文地址： &lt;a href=&quot;http://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom&quot;&gt;Initialization-on-demand holder idiom&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>《HTTP: The Definitive Guide》读书笔记</title>
   <link href="/blog/2011/05/04/http-definitive-guide-note/"/>
   <updated>2011-05-04T19:20:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/05/04/http-definitive-guide-note</id>
   <content type="html">&lt;p&gt;1.MIME(Multipurpose Internet Mail Extensions):是一个数据格式标签，用来解决不同的电子邮件系统中传输消息时遇到的问题。 &lt;/p&gt;

&lt;p&gt;MIME是一个文本类型的标签，用一个主要对象类型和一个特指的子类型，中间加上斜杠表示&lt;br /&gt;
例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;An HTML-formatted text document would be labeled with type text/html.  &lt;/li&gt;
  &lt;li&gt;A plain ASCII text document would be labeled with type text/plain.  &lt;/li&gt;
  &lt;li&gt;A JPEG version of an image would be image/jpeg.  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.URI（Uniform resource identifier）： 每个服务器资源都有个名字，这个名字就叫做URI。它是唯一制定的。&lt;/p&gt;

&lt;p&gt;3.URL（Uniform resource locator）： 是URI的最常用的表示形式。URL表示的是一个资源在特定服务器上的指定位置。它是URI的一个子集。&lt;/p&gt;

&lt;p&gt;URI与URL的区别：&lt;/p&gt;

&lt;p&gt;URI例子:  &lt;/p&gt;

&lt;p&gt;ftp://ftp.is.co.za/rfc/rfc1808.txt&lt;br /&gt;
  http://www.ietf.org/rfc/rfc2396.txt&lt;br /&gt;
  ldap://[2001:db8::7]/c=GB?objectClass?one&lt;br /&gt;
  mailto:John.Doe@example.com&lt;br /&gt;
  news:comp.infosystems.www.servers.unix&lt;br /&gt;
  tel:+1-816-555-1212&lt;br /&gt;
  telnet://192.0.2.16:80/&lt;br /&gt;
  urn:oasis:names:specification:docbook:dtd:xml:4.1.2  &lt;/p&gt;

&lt;p&gt;URL：指定协议，网络地址和服务器上的资源名。协议多为http。&lt;/p&gt;

&lt;p&gt;URN（Uniform Resource Name）：特定内容唯一的名字，与资源目前的位置无关。也是URI的一个子集。&lt;/p&gt;

&lt;p&gt;4.http支持几个不同的请求命令，称为http方法。每个http请求消息都有一个方法。这个方法告诉服务器去执行什么动作。&lt;/p&gt;

&lt;p&gt;GET：Send named resource from the server to the client.&lt;/p&gt;

&lt;p&gt;PUT：Store data from client into a named server resource.&lt;/p&gt;

&lt;p&gt;DELETE：Delete the named resource from a server.&lt;/p&gt;

&lt;p&gt;POST：Send client data into a server gateway application.&lt;/p&gt;

&lt;p&gt;HEAD：Send just the HTTP headers from the response for the named resource.&lt;/p&gt;

&lt;p&gt;5.状态码&lt;/p&gt;

&lt;p&gt;200：OK. Document returned correctly.&lt;/p&gt;

&lt;p&gt;302：Redirect. Go someplace else to get the resource.&lt;/p&gt;

&lt;p&gt;404：Not Found. Can’t find this resource.&lt;/p&gt;

&lt;p&gt;HTTP会和数字状态码一起发送一段解释性的文本，例如：200 OK&lt;/p&gt;

&lt;p&gt;6.http消息有三部分组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;start line：消息的第一行，表示请求要去做什么或者应答要发生什么。&lt;/li&gt;
  &lt;li&gt;header fields：0个或多个头部信息在start line之后，每个头部信息有一个名字和对应的值组成，用“：”隔开,头部消息用一行空行结束。&lt;/li&gt;
  &lt;li&gt;在一行空行之后是一个可选的正文消息，不同于上面2种是有组织的并且是文本类型的，这个消息可以是任何类型的数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;7.TCP/IP&lt;/p&gt;

&lt;p&gt;TCP提供：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无错的数据传输&lt;/li&gt;
  &lt;li&gt;有组织的分发&lt;/li&gt;
  &lt;li&gt;不分段的数据流&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;8.OSI七层从下到上：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层&lt;/p&gt;

&lt;p&gt;9.浏览器访问http页面的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The browser extracts the server’s hostname from the URL.&lt;/li&gt;
  &lt;li&gt;The browser converts the server’s hostname into the server’s IP address.&lt;/li&gt;
  &lt;li&gt;The browser extracts the port number (if any) from the URL.&lt;/li&gt;
  &lt;li&gt;The browser establishes a TCP connection with the web server.&lt;/li&gt;
  &lt;li&gt;The browser sends an HTTP request message to the server.&lt;/li&gt;
  &lt;li&gt;The server sends an HTTP response back to the browser.&lt;/li&gt;
  &lt;li&gt;The connection is closed, and the browser displays the document.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;10.Status code classes &lt;/p&gt;

&lt;p&gt;Overall range  Defined range  Category&lt;/p&gt;

&lt;p&gt;100-199        100-101        Informational&lt;/p&gt;

&lt;p&gt;200-299        200-206        Successful&lt;/p&gt;

&lt;p&gt;300-399        300-305        Redirection&lt;/p&gt;

&lt;p&gt;400-499        400-415        Client error&lt;/p&gt;

&lt;p&gt;500-599        500-505        Server error&lt;/p&gt;

&lt;p&gt;11.Header example                    Description&lt;/p&gt;

&lt;p&gt;Date: Tue, 3 Oct 1997 02:16:03 GMT  The date the server generated the response&lt;/p&gt;

&lt;p&gt;Content-length: 15040               The entity body contains 15,040 bytes of data&lt;/p&gt;

&lt;p&gt;Content-type: image/gif             The entity body is a GIF image&lt;/p&gt;

&lt;p&gt;Accept: image/gif, image/jpeg, text/html   The client accepts GIF and JPEG images and HTML&lt;/p&gt;

&lt;p&gt;Cache-Control: max-age: The max-age value defines the maximum age of the document—the maximum legal elapsed time(in seconds) from when a document is first generated to when it can no longer be                          considered fresh enough to serve.(Cache-Control: max-age=484200)&lt;/p&gt;

&lt;p&gt;Expires: Specifies an absolute expiration date. If the expiration date is in the past, the document is no longer fresh.(Expires: Fri, 05 Jul 2002, 05:00:00 GMT)&lt;/p&gt;

&lt;p&gt;If-Modified-Since: &lt;/p&gt;

&lt;p&gt;Perform the requested method if the document has been modified since the specified date. This is used in conjunction with the Last-Modified server response header, to fetch content only if the content has been modified from the cached version.&lt;/p&gt;

&lt;p&gt;If-None-Match: &lt;/p&gt;

&lt;p&gt;Instead of matching on last-modified date, the server may provide special tags (see ETag) on the document that act like serial numbers. The If-None-Match header performs the requested method if the cached tags differ from the tags in the server’s document.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>invokeinterface,invokespecial,invokestatic和invokevirtual的含义和区别</title>
   <link href="/blog/2011/04/13/explain-java-bytecode-invokeinterface-invokespecial-invokestatic-invokevirtual/"/>
   <updated>2011-04-13T19:13:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/04/13/explain-java-bytecode-invokeinterface-invokespecial-invokestatic-invokevirtual</id>
   <content type="html">&lt;p&gt;在解释之前，首先需要理解JVM中的两个数据结构：&lt;strong&gt;栈帧(Frames)&lt;/strong&gt;和&lt;strong&gt;操作数栈(Operand Stack)&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;栈帧&lt;/h2&gt;

&lt;p&gt;在JVM中，栈帧是用来保存数据和部分结果，执行动态链接，返回方法调用的结果，分发异常。&lt;/p&gt;

&lt;p&gt;每一次当一个方法被调用时就会创建一个新的栈帧，并且栈帧会在方法调用完毕后(无论方法是否正常执行结束或者因未捕获的异常而终止)消亡。&lt;/p&gt;

&lt;p&gt;栈帧是由JVM中创建栈帧的线程分配的。每个栈帧里含有：他自己的本地变量(基本数据类型或引用类型)的数组，他自己的操作数栈和一个当前方法所在类的常量池的引用。&lt;/p&gt;

&lt;p&gt;本地变量数组和操作数栈的大小在编译的时候就已经决定了，并且一直提供给和栈帧关联的方法使用。因此，栈帧的大小只跟JVM的实现以及方法被调用时这些数据结构同时在内存中被分配的大小决定。&lt;/p&gt;

&lt;p&gt;在一个线程执行过程中，任何时候只有一个栈帧(也就是正在执行的方法的栈帧)处于活动状态。这个栈帧就被认为是当前栈帧，并且他包含的方法就是当前正在执行的方法。当前方法所在的类称为当前类。在本地变量和操作数栈上的操作都含有当前栈帧的引用。&lt;/p&gt;

&lt;p&gt;当栈帧的方法调用另外的方法或者他的方法完成了，那么当前栈帧就会停止。当一个方法被调用的时候，会创建一个新的栈帧，并且当新的方法获得CPU控制权时这个新创建的栈帧会变成当前栈帧，当方法返回的时候，当前栈帧传回他的方法调用的结果，如果这个结果有的话将被传递给前一个栈帧。当之前的一个栈帧变成当前栈帧的时候，当前栈帧就会被丢弃。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;操作数栈&lt;/h2&gt;

&lt;p&gt;每个栈帧都有一个last-in-first-out(LIFO)的栈，这个栈就被称为操作数栈。操作数栈的最大深度在编译时就已经确定，并且供与这个栈帧相关联的方法使用。&lt;/p&gt;

&lt;p&gt;当栈帧被创建时，操作数栈是空的。JVM发出指令装载本地变量中的常量和值到操作数栈中去。另外的指令是从操作数栈中取数，运算完成后把结果再放入操作数栈中。操作数栈还被用来保存方法的参数和方法的返回值。&lt;/p&gt;

&lt;p&gt;操作数栈中的值都是一个Java基本类型或者引用类型。操作数栈中的值必须在适合他们的类型的方式下操作。一小部分JVM指令(dup，swap)执行时不考虑值的类型，这些指令不能修改和分开单个的值，这些操作数栈的限制通过类文件检查时强制执行。&lt;/p&gt;

&lt;p&gt;long和double类型在操作数栈有2个单元长度，其他类型都是1个单元长度。&lt;/p&gt;

&lt;h2 id=&quot;invokeinterface&quot;&gt;invokeinterface&lt;/h2&gt;

&lt;p&gt;当调用接口中的方法的时候，就会使用invokeinterface指令。&lt;/p&gt;

&lt;p&gt;Operand Stack
    …, objectref, [arg1, [arg2 …]]  …&lt;/p&gt;

&lt;p&gt;实际被调用的方法将会遵循下面的查找步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果objectref这个类中含有和将要被调用的方法有相同的方法名和参数的方法，那么objectref这个类中的方法将会被调用，并且查找过程结束。&lt;/li&gt;
  &lt;li&gt;如果经过(1)后没有找到合适的方法，并且如果objectref有父类的话，那么就会在他的父类里迭代执行。&lt;/li&gt;
  &lt;li&gt;如果(1)，(2)后都没有找到，则会抛出AbstractMethodError。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;invokespecial&quot;&gt;invokespecial&lt;/h2&gt;

&lt;p&gt;当调用类的任何构造方法时，就会使用invokespecial指令。&lt;/p&gt;

&lt;p&gt;Operand Stack
    …, objectref, [arg1, [arg2 …]]  …&lt;/p&gt;

&lt;p&gt;如果将要被调用的构造方法是“protected”的，并且要么是当前类的成员，要么是当前类父类的成员，那么objectref必须要么是当前类，要么是当前类的子类。&lt;/p&gt;

&lt;p&gt;当下面的条件都为“true”时，才会调用方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当前类已经设置好ACC_SUPER标志位。&lt;/li&gt;
  &lt;li&gt;要调用构造方法所在的类是当前类的父类。&lt;/li&gt;
  &lt;li&gt;要调用的构造方法所在的类还没有被实例化。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当上面的条件都为“true”时，实际将要被调用的方法将会遵循下面的查找步骤。(假定C是当前类的直接父类):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果C中有声明过相同的方法(包括方法签名和参数)，那么这个方法将会被调用，并且查找过程结束。&lt;/li&gt;
  &lt;li&gt;如果(1)不满足，并且C有父类，那么会在C的父类中迭代(1)，实际被调用的方法就是这个迭代查找过程的结果，并且查找过程结束。&lt;/li&gt;
  &lt;li&gt;如果(1),(2)都不满足，将会抛出AbstractMethodError。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;invokestatic&quot;&gt;invokestatic&lt;/h2&gt;

&lt;p&gt;当调用类的静态方法时，就会使用invokestatic指令。&lt;/p&gt;

&lt;p&gt;Operand Stack
    …, [arg1, [arg2 …]]  …&lt;/p&gt;

&lt;p&gt;被调用的方法必须是静态方法，而且不能是抽象方法，并且如果要使用类的属性的话，那么类的属性也必须是静态的。&lt;/p&gt;

&lt;p&gt;如果这个静态方法是synchronized的，那么需要获得与这个类相关的monitor。&lt;/p&gt;

&lt;p&gt;如果这个被调用的方法不是native的话，操作数栈里保存的参数将会被弹出，并且为这个方法创建一个新的栈帧，弹出的参数按顺序赋值给新创建的栈帧的本地变量。如果弹出的参数是浮点类型的值的话，那么在保存为新栈帧的本地变量之前将会被类型转型(转换为最接近这个浮点类型值的类型)。&lt;/p&gt;

&lt;h2 id=&quot;invokevirtual&quot;&gt;invokevirtual&lt;/h2&gt;

&lt;p&gt;当调用类的实例方法时，就会使用invokevirtual指令。&lt;/p&gt;

&lt;p&gt;值得注意的是，Java中的所有实例方法默认都是virtual的。&lt;/p&gt;

&lt;p&gt;Operand Stack
    …, objectref, [arg1, [arg2 …]]  …&lt;/p&gt;

&lt;p&gt;如果被调用的方法是protected，并且他要么是当前类的成员，要么是当前类的父类里的成员，那么objectref必须要么是当前类，要么是当前类的子类。&lt;/p&gt;

&lt;p&gt;实际被调用的方法将会遵循以下查找过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果objectref中有相同方法签名和参数的方法，并且这个方法可以从objectref中访问到，那么这个方法就会被调用，并且查找过程结束。&lt;/li&gt;
  &lt;li&gt;如果(1)不满足，并且objectref有一个父类，那么会在父类中迭代(1)，实际被调用的方法就是这个迭代查找过程的结果，并且查找过程结束。&lt;/li&gt;
  &lt;li&gt;如果(1),(2)都不满足，将会抛出AbstractMethodError 。&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>JVM内存管理和垃圾收集</title>
   <link href="/blog/2011/04/03/jvm-memory-management-and-gc/"/>
   <updated>2011-04-03T18:52:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/04/03/jvm-memory-management-and-gc</id>
   <content type="html">&lt;h2 id=&quot;java&quot;&gt;Java基本类型和类的大小&lt;/h2&gt;

&lt;p&gt;Java手册上的类型大小&lt;/p&gt;

&lt;p&gt;byte : 8-bit                           &lt;br /&gt;
short : 16-bit&lt;br /&gt;
char : 16-bit unsigned integer                       &lt;br /&gt;
Int : 32-bit&lt;br /&gt;
float : 32-bit                             &lt;br /&gt;
long : 64-bit                           &lt;br /&gt;
double: 64-bit                              &lt;br /&gt;
boolean: 1-bit                             &lt;/p&gt;

&lt;p&gt;实际存储大小(根据JVM实现而定)&lt;/p&gt;

&lt;p&gt;Byte : 16 bytes&lt;br /&gt;
Short : 16 bytes&lt;br /&gt;
Integer : 16 bytes&lt;br /&gt;
Long : 16 bytes&lt;br /&gt;
Character : 16 bytes&lt;br /&gt;
Float : 16 bytes&lt;br /&gt;
Double : 16 bytes&lt;br /&gt;
Boolean : 16 bytes&lt;br /&gt;
Object ：8 bytes  &lt;/p&gt;

&lt;h2 id=&quot;jvm&quot;&gt;JVM的堆结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://farm6.static.flickr.com/5136/5504939947_19ed9a8dbc.jpg&quot; alt=&quot;JVMHeapStructure&quot; title=&quot;JVMHeapStructure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;运行时数据区域，所有类实例和数组的内存均从此处分配，由Java 虚拟机启动时创建。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。&lt;/p&gt;

&lt;p&gt;堆由两部分组成:&lt;/p&gt;

&lt;p&gt;Eden + From Space(S0) + To Space(S1): 也叫做Young Generation(年轻代)&lt;/p&gt;

&lt;p&gt;Tenured Space: 也叫做Old Generation(老年代)&lt;/p&gt;

&lt;p&gt;Survivor Space: 包括S0和S1&lt;/p&gt;

&lt;p&gt;permanent space(方法区)： JVM具有一个由所有线程共享的方法区。它存储每个类结构，如运行时常数池、字段和方法数据，以及方法和构造方法的代码，它是在Java虚拟机启动时创建的，&lt;strong&gt;不包括在JVM堆内&lt;/strong&gt;，默认为4M。 &lt;/p&gt;

&lt;p&gt;这个区域主要存放：&lt;/p&gt;

&lt;p&gt;类的信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;包名&lt;/li&gt;
  &lt;li&gt;父类的包名&lt;/li&gt;
  &lt;li&gt;类或接口&lt;/li&gt;
  &lt;li&gt;类型修饰符&lt;/li&gt;
  &lt;li&gt;父接口包名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其它信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类型的常量池&lt;/li&gt;
  &lt;li&gt;属性 &lt;/li&gt;
  &lt;li&gt;方法&lt;/li&gt;
  &lt;li&gt;类里的静态变量(除了常量)&lt;/li&gt;
  &lt;li&gt;一个指向ClassLoader的引用 &lt;/li&gt;
  &lt;li&gt;一个指向Class类的引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gc&quot;&gt;GC的工作流程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;绝大多数情况下对象初始化被分配在 Eden 中(一个非常大的对象会被分配在老年代中)。  &lt;/li&gt;
  &lt;li&gt;如果 Eden 空间占满了，会触发 minor GC。 Minor GC 后仍然存活的对象会被复制到 S0 中去。这样 Eden 就被清空可以分配给新的对象。  &lt;/li&gt;
  &lt;li&gt;又触发了一次 Minor GC，S0 和 Eden 中存活的对象被复制到 S1 中，并且 S0 和 Eden 被清空。 在同一时刻, 只有 Eden 和一个 Survivor Space 同时被操作。  &lt;/li&gt;
  &lt;li&gt;当每次对象从 Eden 复制到 Survivor Space 或者从 Survivor Space 中的一个复制到另外一个，有一个计数器会自动增加值。 默认情况下如果复制发生超过16次， JVM 会停止复制并把他们移到老年代中去。  &lt;/li&gt;
  &lt;li&gt;如果一个对象不能在 Eden 中被创建，它会直接被创建在老年代中。 如果老年代的空间被占满会触发老年代的 GC，也被称为 Full GC。full GC 是一个压缩处理过程，所以它比 Minor GC 要慢很多。  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;gc-1&quot;&gt;GC算法&lt;/h2&gt;

&lt;h3 id=&quot;serial-collector&quot;&gt;Serial Collector&lt;/h3&gt;

&lt;p&gt;大部分平台默认，或者强制 java -client。
Young Generation  = Serial
Old Generation  = Serial (Mark-Sweep-Compact)
这种方法的缺点很明显：Stop-the-world, 速度慢，服务器应用不推荐使用。&lt;/p&gt;

&lt;h3 id=&quot;parallel-collector&quot;&gt;Parallel Collector&lt;/h3&gt;

&lt;p&gt;在Linux x64上默认是这种算法，其他平台要加 java -server 参数。
Young Generation = parallel，多个thread同时copy
Old Generation = Mark-Sweep-Compact = 1
优点：新生代回收更快。因为系统大部分时间做的GC都是新生代的，这样提高了Throughput(CPU用于非GC时间)。
缺点：当运行在8G/16G Server 上 Old Generation 存活对象太多的时候暂停时间(Pause Time)过长。&lt;/p&gt;

&lt;h3 id=&quot;parallel-compacting-collector-parallelold&quot;&gt;Parallel Compacting Collector (ParallelOld)&lt;/h3&gt;

&lt;p&gt;Young Generation = parallel 
Old Generation = parallel
优点：Old Generation 上性能较 Parallel Collector 方式有提高。
缺点：大部分Server系统Old Generation内存占用会达到60%-80%, Compact方面开销比起Parallel Collector并没明显减少。&lt;/p&gt;

&lt;h3 id=&quot;concurent-mark-sweepcms-collector-low-latency-collector&quot;&gt;Concurent Mark-Sweep(CMS) Collector (low-latency collector)&lt;/h3&gt;

&lt;p&gt;Young Generation = parallel 
Old Generation = CMS
同时不做 compact 操作。
优点：Pause Time会降低，Pause Time敏感但CPU有空闲的场景需要建议使用。缺点：CPU占用过多，CPU密集型服务器不适合。需要更大的堆空间，会造成很多碎片。&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;173&quot; valign=&quot;top&quot; /&gt;
&lt;td width=&quot;100&quot; valign=&quot;top&quot;&gt;Generational Area&lt;/td&gt;
&lt;td width=&quot;550&quot; valign=&quot;top&quot;&gt;Characteristics&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;173&quot; valign=&quot;top&quot;&gt;Serial&lt;/td&gt;
&lt;td width=&quot;100&quot; valign=&quot;top&quot;&gt;Young&lt;/td&gt;
&lt;td width=&quot;550&quot; valign=&quot;top&quot;&gt;Stop The World, Copying Collector, Single GC thread.   (works as described in the previous article).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;173&quot; valign=&quot;top&quot;&gt;Serial Old (MSC)&lt;/td&gt;
&lt;td width=&quot;100&quot; valign=&quot;top&quot;&gt;Old&lt;/td&gt;
&lt;td width=&quot;550&quot; valign=&quot;top&quot;&gt;Stop the World, Mark Sweep Compact (MSC), Single GC thread&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;173&quot; valign=&quot;top&quot;&gt;Parallel Scavenge&lt;/td&gt;
&lt;td width=&quot;100&quot; valign=&quot;top&quot;&gt;Young&lt;/td&gt;
&lt;td width=&quot;550&quot; valign=&quot;top&quot;&gt;Stop the World, copying collector, multiple GC threads.   Provides higher throughput by executing GC tasks in parallel with each other   (but not the app).&lt;p /&gt;
&lt;p&gt;Cannot run during concurrent phases of the CMS.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;173&quot; valign=&quot;top&quot;&gt;Parallel New&lt;/td&gt;
&lt;td width=&quot;100&quot; valign=&quot;top&quot;&gt;Young&lt;/td&gt;
&lt;td width=&quot;550&quot; valign=&quot;top&quot;&gt;As Parallel Scavenge, but can run during the concurrent   phases of the CMS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;173&quot; valign=&quot;top&quot;&gt;Parallel Old/ Parallel Compacting&lt;/td&gt;
&lt;td width=&quot;100&quot; valign=&quot;top&quot;&gt;Old&lt;/td&gt;
&lt;td width=&quot;550&quot; valign=&quot;top&quot;&gt;Similar to Parallel Scavenge, but operates on the old generation.&lt;p /&gt;
&lt;p&gt;uses multiple GC threads to speed up the work of Serial   Old (MSC).&lt;/p&gt;
&lt;p&gt;STW collector, but higher throughput for old generation   collections.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;173&quot; valign=&quot;top&quot;&gt;Concurrent Mark-Sweep (CMS)&lt;/td&gt;
&lt;td width=&quot;100&quot; valign=&quot;top&quot;&gt;Old&lt;/td&gt;
&lt;td width=&quot;550&quot; valign=&quot;top&quot;&gt;Breaks up its work into phases, and executes most of its phases concurrently with the application thread – resulting in low latency. However, it introduces substantial management overhead and results in a fragmented heap.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section&quot;&gt;垃圾收集器的选择&lt;/h2&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;179&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;Switch &lt;/strong&gt;&lt;/td&gt;
&lt;td width=&quot;151&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;Young Generation&lt;/strong&gt;&lt;/td&gt;
&lt;td width=&quot;385&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;Old Generation&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;179&quot; valign=&quot;top&quot;&gt;UseSerialGC&lt;/td&gt;
&lt;td width=&quot;151&quot; valign=&quot;top&quot;&gt;&lt;em&gt;Serial&lt;/em&gt;&lt;/td&gt;
&lt;td width=&quot;385&quot; valign=&quot;top&quot;&gt;Serial Old (MSC)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;179&quot; valign=&quot;top&quot;&gt;UseParNewGC&lt;/td&gt;
&lt;td width=&quot;151&quot; valign=&quot;top&quot;&gt;ParNew&lt;/td&gt;
&lt;td width=&quot;385&quot; valign=&quot;top&quot;&gt;Serial Old (MSC)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;179&quot; valign=&quot;top&quot;&gt;UseConcMarkSweepGC&lt;/td&gt;
&lt;td width=&quot;151&quot; valign=&quot;top&quot;&gt;ParNew&lt;/td&gt;
&lt;td width=&quot;385&quot; valign=&quot;top&quot;&gt;&lt;em&gt;CMS (mostly used)&lt;/em&gt;&lt;p /&gt;
&lt;p&gt;Serial Old (used when concurrent mode failure occurs)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;179&quot; valign=&quot;top&quot;&gt;+UseParallelGC&lt;/td&gt;
&lt;td width=&quot;151&quot; valign=&quot;top&quot;&gt;&lt;em&gt;Parallel Scavenge&lt;/em&gt;&lt;/td&gt;
&lt;td width=&quot;385&quot; valign=&quot;top&quot;&gt;Serial Old&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;179&quot; valign=&quot;top&quot;&gt;UseParallelOldGC&lt;/td&gt;
&lt;td width=&quot;151&quot; valign=&quot;top&quot;&gt;&lt;em&gt;Parallel Scavenge&lt;/em&gt;&lt;/td&gt;
&lt;td width=&quot;385&quot; valign=&quot;top&quot;&gt;&lt;em&gt;Parallel Old&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;179&quot; valign=&quot;top&quot;&gt;+UseConcMarkSweepGC&lt;br /&gt;
-UseParNewGC&lt;/td&gt;
&lt;td width=&quot;151&quot; valign=&quot;top&quot;&gt;&lt;em&gt;Serial&lt;/em&gt;&lt;/td&gt;
&lt;td width=&quot;385&quot; valign=&quot;top&quot;&gt;&lt;em&gt;CMS&lt;br /&gt;
&lt;span style=&quot;font-style: normal;&quot;&gt;Serial Old&lt;/span&gt;&lt;/em&gt;&lt;p /&gt;
&lt;p&gt;&lt;em&gt; &lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;jvm-1&quot;&gt;JVM的默认设置&lt;/h2&gt;

&lt;p&gt;堆（heap）即（New Generation 和 Old Generaion 之和）的设置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始分配的内存由 -Xms 指定，默认是物理内存的1/64但小于1G。&lt;/li&gt;
  &lt;li&gt;最大分配的内存由 -Xmx 指定，默认是物理内存的1/4但小于1G。&lt;/li&gt;
  &lt;li&gt;默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以由 -XX:MinHeapFreeRatio 指定。&lt;/li&gt;
  &lt;li&gt;默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以由 -XX:MaxHeapFreeRatio 指定。&lt;/li&gt;
  &lt;li&gt;服务器一般设置 -Xms 、 -Xmx 相等以避免在每次GC后调整堆的大小，所以上面的两个参数没啥用。 &lt;/li&gt;
  &lt;li&gt;-Xmn 设置Young Generation的heap大小。&lt;/li&gt;
  &lt;li&gt;-XX:MinHeapFreeRatio 与 -XX:MaxHeapFreeRatio 设定空闲内存占总内存的比例范围，这两个参数会影响GC的频率和单次GC的耗时。 -XX:NewRatio 决定Young与Old Generation的比例。Young generation空间越大，Minor GC频率越低，但是Old Generation空间小了，又可能导致Major GC频率增加。 -XX:NewSize 和 -XX:MaxNewSize 直接指定了Young Generation的缺省大小和最大大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;非堆内存的设置&lt;/p&gt;

&lt;p&gt;默认分配为64M&lt;/p&gt;

&lt;p&gt;-XX:PermSize 设置最小分配空间， -XX:MaxPermSize 设置最大分配空间。一般把这两个数值设为相同，以减少申请内存空间的时间。&lt;/p&gt;

&lt;h2 id=&quot;gc-2&quot;&gt;GC调优&lt;/h2&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://java.sun.com/docs/hotspot/gc1.4.2/example.html&quot; title=&quot;GC调优例子&quot;&gt;GC调优例子&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置Xms=Xmx=3/4物理内存(或50%-70%)，-Xmn为1/4的-Xmx值，新生代必须小于堆的一半大&lt;/li&gt;
  &lt;li&gt;如果是CPU密集型服务器，使用–XX:+UseParallelOldGC, 否则–XX:+UseConcMarkSweepGC&lt;/li&gt;
  &lt;li&gt;新生代,Parallel/ParallelOld可设大于Xmx1/4，CMS可设小，小于Xmx1/4&lt;/li&gt;
  &lt;li&gt;通常情况下，JVM堆的大小应为物理内存的80%&lt;/li&gt;
  &lt;li&gt;使用-verbose:gc和-XX:+PrintGCDetails观察GC性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dump-heap&quot;&gt;Dump heap&lt;/h2&gt;

&lt;p&gt;Linux下： jmap -dump:file=xxx.hprof pid  (其中 pid 通过 ps -aux 命令查看)&lt;/p&gt;

&lt;p&gt;命令行: jstat -gcutil pid p1 p2  (其中 p1 表示每多少毫秒打印一次； p2 表示一共打印几次)&lt;/p&gt;

&lt;p&gt;输出的参数含义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S0：Heap上的 Survivor space 0 段已使用空间的百分比&lt;/li&gt;
  &lt;li&gt;S1：Heap上的 Survivor space 1 段已使用空间的百分比&lt;/li&gt;
  &lt;li&gt;E： Heap上的 Eden space 段已使用空间的百分比&lt;/li&gt;
  &lt;li&gt;O： Heap上的 Old space 段已使用空间的百分比&lt;/li&gt;
  &lt;li&gt;P： Perm space 已使用空间的百分比&lt;/li&gt;
  &lt;li&gt;YGC：从程序启动到采样时发生Young GC的次数&lt;/li&gt;
  &lt;li&gt;YGCT：Young GC所用的时间(单位秒)&lt;/li&gt;
  &lt;li&gt;FGC：从程序启动到采样时发生Full GC的次数&lt;/li&gt;
  &lt;li&gt;FGCT：Full GC所用的时间(单位秒)&lt;/li&gt;
  &lt;li&gt;GCT：用于垃圾回收的总时间(单位秒)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jstat命令其他参数含义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jstat -class pid:显示加载class的数量，及所占空间等信息。 &lt;/li&gt;
  &lt;li&gt;jstat -compiler pid:显示VM实时编译的数量等信息。 &lt;/li&gt;
  &lt;li&gt;jstat -gc pid:可以显示gc的信息，查看gc的次数，及时间。其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full  gc的时间，gc的总时间。 &lt;/li&gt;
  &lt;li&gt;jstat -gccapacity:可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。其他的可以根据这个类推， OC是old内纯的占用量。 &lt;/li&gt;
  &lt;li&gt;jstat -gcnew pid:new对象的信息。 &lt;/li&gt;
  &lt;li&gt;jstat -gcnewcapacity pid:new对象的信息及其占用量。 &lt;/li&gt;
  &lt;li&gt;jstat -gcold pid:old对象的信息。 &lt;/li&gt;
  &lt;li&gt;jstat -gcoldcapacity pid:old对象的信息及其占用量。 &lt;/li&gt;
  &lt;li&gt;jstat -gcpermcapacity pid: perm对象的信息及其占用量。 &lt;/li&gt;
  &lt;li&gt;jstat -util pid:统计gc信息统计。 &lt;/li&gt;
  &lt;li&gt;jstat -printcompilation pid:当前VM执行的信息。 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GC日志： -Xloggc:d:\gc.log -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps – add time stamp &lt;/p&gt;

&lt;h2 id=&quot;javalangoutofmemoryerror&quot;&gt;内存泄漏-java.lang.OutOfMemoryError&lt;/h2&gt;

&lt;p&gt;Java heap space&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Configuration issue: -Xmx&lt;/li&gt;
  &lt;li&gt;Memory Leak: The excessive use of finalizers&lt;/li&gt;
  &lt;li&gt;PermGen space: Too many classes -XX:MaxPermSize &lt;/li&gt;
  &lt;li&gt;Requested array size exceeds VM limit: Need a so big array?&lt;/li&gt;
  &lt;li&gt;Request &lt;size&gt; bytes for &lt;reason&gt;: Out of swap space?&lt;/reason&gt;&lt;/size&gt;&lt;/li&gt;
  &lt;li&gt;Native Memory Leak&lt;/li&gt;
  &lt;li&gt;
    &lt;reason&gt; &lt;stack trace=&quot;&quot;&gt; (Native method)
&lt;/stack&gt;&lt;/reason&gt;
  &lt;/li&gt;
  &lt;li&gt;Native Memory Allocation Issue &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Perm Memory Leak&lt;/p&gt;

&lt;p&gt;Too Many Interned String&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;String.intern()&lt;/li&gt;
  &lt;li&gt;Constant String will be interned implicitly&lt;/li&gt;
  &lt;li&gt;No Enough Info provided by Heap Dump on Interned String&lt;/li&gt;
  &lt;li&gt;If Perm Memory increased dynamically, be careful&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Too Many Classes or Class Load Leak&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Enlarge the perm generation&lt;/li&gt;
  &lt;li&gt;Avoid duplicated class loader&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Out of Swap Space&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Enlarge the swap space&lt;/li&gt;
  &lt;li&gt;Systems with 4GB of ram or less require a minimum of 2GB of swap space&lt;/li&gt;
  &lt;li&gt;Systems with 4GB to 16GB of ram require a minimum of 4GB of swap space&lt;/li&gt;
  &lt;li&gt;For Unix Family OS, use pmdump or pmap, libumem for Solaris&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>MyEclipse优化设置</title>
   <link href="/blog/2011/03/24/myeclipse-optimization/"/>
   <updated>2011-03-24T18:27:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/03/24/myeclipse-optimization</id>
   <content type="html">&lt;h2 id=&quot;validation&quot;&gt;第一步: 取消自动validation&lt;/h2&gt;

&lt;p&gt;validation有一堆，什么xml、jsp、jsf、js等等，我们没有必要全部都去自动校验一下，只是需要的时候才会手工校验一下！
取消方法：
windows–&amp;gt;perferences–&amp;gt;myeclipse–&amp;gt;validation
除开Manual下面的复选框全部选中之外，其他全部不选&lt;/p&gt;

&lt;p&gt;手工验证方法：
在要验证的文件上，单击鼠标右键–&amp;gt;myeclipse–&amp;gt;run validation&lt;/p&gt;

&lt;h2 id=&quot;eclipse&quot;&gt;第二步：取消eclipse拼写检查&lt;/h2&gt;

&lt;p&gt;拼写检查会给我们带来不少的麻烦，我们的方法命名都会是单词的缩写，他也会提示有错，所以最好去掉，没有多大的用处
windows–&amp;gt;perferences–&amp;gt;general–&amp;gt;validation-&amp;gt;editors-&amp;gt;Text Editors-&amp;gt;spelling&lt;/p&gt;

&lt;h2 id=&quot;myeclipse&quot;&gt;第三步：取消myeclipse的启动项&lt;/h2&gt;

&lt;p&gt;myeclipse会有很多的启动项，而其中很多我们都用不着，或者只用一两个，取消前面不用的就可以
windows–&amp;gt;perferences–&amp;gt;general–&amp;gt;startup and shutdown  (详见底端介绍)&lt;/p&gt;

&lt;h2 id=&quot;jsp&quot;&gt;第四步：更改JSP默认打开的方式&lt;/h2&gt;

&lt;p&gt;安装了myeclipse后，编辑jsp页面，会打开他的编辑页面，同时也有预览页面，速度很慢，不适合开发。
修改windows–&amp;gt;perferences–&amp;gt;general–&amp;gt;editors-&amp;gt;file associations
在下方选择一种编辑器，然后点击左边的default按钮&lt;/p&gt;

&lt;h2 id=&quot;ctrl&quot;&gt;第五步：更改代码提示快捷键(不建议使用增强提示,使用Ctrl+/在自己需要的时候提示更佳)&lt;/h2&gt;

&lt;p&gt;现在的代码提示快捷键，默认为 ctrl+space，而我们输入法切换也是，所以会有冲突。找到windows–&amp;gt;perferences–&amp;gt;general–&amp;gt;Keys，更改 content assist 为 alt+/。同时由于 alt+/ 已经被 word completion 占用，所以得同时修改 word completion 的快捷键值。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;第六步: 更改内存使用文件&lt;/h2&gt;

&lt;p&gt;1、打开 eclipse.ini&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-showsplash 
com.genuitec.myeclipse.product
--launcher.XXMaxPermSize 256M
-vmargs
-Dosgi.requiredJavaVersion=1.5
-Xms256m
-Xmx1024m   
-Dosgi.splashLocation=e:MyEclipse 6.0eclipseMyEclipseSplash.bmp
-Duser.language=en
-XX:PermSize=128M
-XX:MaxPermSize=256M&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把下面的那个 -XX:MaxPermSize 调大，比如 -XX:MaxPermSize=512M，再把 -XX:PermSize 调成跟 -XX:MaxPermSize 一样大。原因：大家一定对这个画面很熟悉吧：几乎每次eclipse卡到当都是因为这个非堆内存不足造成的，把最大跟最小调成一样是因为不让myeclipse频繁的换内存区域大小。&lt;/p&gt;

&lt;p&gt;注意： XX:MaxPermSize 和 Xmx 的大小之和不能超过你的电脑内存大小&lt;/p&gt;

&lt;h2 id=&quot;struts-configxml&quot;&gt;第七步: 修改Struts-config.xml文件打开错误&lt;/h2&gt;

&lt;p&gt;有时点击myeclipse里的struts的xml配置文件，会报错：
Error opening the editorUnable to open the editor ,unknow the editor id…..
把这个窗口关闭后才出正确的xml文件显示，这个我们这样改：
windows–&amp;gt;perferences–&amp;gt;general–&amp;gt;editors-&amp;gt;file associations选择*.xml，选择myeclipse xml editor为default。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;第八步: 取消自动验证,该成手动验证&lt;/h2&gt;

&lt;p&gt;windows–&amp;gt;perferences–&amp;gt;myeclipse–&amp;gt;validation
将Build下全部勾取消,保留Manual(手动) 如果你需要验证某个文件的时候，我们可以单独去验证它。方法是，在需要验证的文件上(右键 -&amp;gt; MyEclipse -&amp;gt; Run Validation)&lt;/p&gt;

&lt;h2 id=&quot;maven&quot;&gt;第九步: 取消Maven更新(启动更新)&lt;/h2&gt;

&lt;p&gt;Window &amp;gt; Preferences &amp;gt; Myeclipse Enterprise Workbench &amp;gt; Maven4Myeclipse &amp;gt; Maven&amp;gt;禁用Download repository index updates on startup&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;附件&lt;/h2&gt;

&lt;p&gt;第一项: 启动功能介绍和样例(红色为需要保留的文件,此为本人样例,请按需选择)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;Automatic&amp;nbsp;Updates&amp;nbsp;Scheduler&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(0, 130, 0);&quot;&gt;//自动升级调度&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;span&gt;MyEclipse&amp;nbsp;QuickSetup&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(0, 130, 0);&quot;&gt;//快速启动&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;
&lt;span&gt;MyEclipse&amp;nbsp;Derby&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(0, 130, 0);&quot;&gt;//derby是一个开源数据库的名字&lt;/span&gt;&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Geronimo&amp;nbsp;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;//同色都是应用服务器的名字&lt;/span&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Geronimo&amp;nbsp;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;JBOSS&amp;nbsp;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;JBOSS&amp;nbsp;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;JBOSS&amp;nbsp;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;JBOSS&amp;nbsp;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;JBOSS&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Jetty&amp;nbsp;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Jetty&amp;nbsp;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Jetty&amp;nbsp;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Jetty&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;JOnAS&amp;nbsp;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;JOnAS&amp;nbsp;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;JOnAS&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;JRun&amp;nbsp;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;JRun&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Oracle&amp;nbsp;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&amp;nbsp;AS&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Oracle&amp;nbsp;&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&amp;nbsp;AS&lt;/span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Oracle&amp;nbsp;AS&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Orion&amp;nbsp;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Orion&amp;nbsp;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Resin&amp;nbsp;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Resin&amp;nbsp;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Resin&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Sun&amp;nbsp;&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.x&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Sun&amp;nbsp;&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Sun&amp;nbsp;&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Glassfish&amp;nbsp;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Glassfish&amp;nbsp;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Sun&amp;nbsp;One&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;MyEclipse&amp;nbsp;Tomcat&amp;nbsp;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&amp;nbsp;Server&lt;/span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Tomcat&amp;nbsp;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Tomcat&amp;nbsp;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Tomcat&amp;nbsp;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;Tomcat&lt;/span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;WebLogic&amp;nbsp;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;WebLogic&amp;nbsp;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;WebLogic&amp;nbsp;&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;WebLogic&amp;nbsp;&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;WebLogic&amp;nbsp;&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;WebLogic&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;WebSphere&amp;nbsp;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;WebSphere&amp;nbsp;&lt;/span&gt;&lt;span&gt;6.1&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;WebSphere&amp;nbsp;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color: rgb(34, 177, 76);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;EASIE&amp;nbsp;WebSphere&amp;nbsp;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;
&lt;span&gt;MyEclipse&amp;nbsp;Examples&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(0, 130, 0);&quot;&gt;//样例&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;Memory&amp;nbsp;Monitor&amp;nbsp;&lt;/span&gt;&lt;span&gt;//内存监控&lt;/span&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;span&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;MyEclipse&amp;nbsp;Tapestry&amp;nbsp;Integration&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(0, 130, 0);&quot;&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;//插件集成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;JSP&amp;nbsp;Debug&amp;nbsp;Tooling&amp;nbsp;&lt;/span&gt;&lt;span&gt;//jsp调试插件&lt;/span&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;File&amp;nbsp;Creation&amp;nbsp;Wizards&amp;nbsp;&lt;/span&gt;&lt;span&gt;//文件创建程序&amp;nbsp;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&lt;span&gt;ICEfaces Integration for MyEclipse //基于Ajax的JSF开发框架()&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&lt;span&gt;MyEclipse&amp;nbsp;Backward&amp;nbsp;Compatibility&amp;nbsp;&lt;/span&gt;&lt;span&gt;//后台功能&lt;/span&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;span&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;MyEclipse&amp;nbsp;Perspective&amp;nbsp;Plug-in&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(0, 130, 0);&quot;&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;//透视图插件&lt;/span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span&gt;Pluse Collaboration Control Center //Eclipse的网页管理中心&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;eclipse-cs 4.x.x -&amp;gt; 5.0.0 Migration Plug-in&amp;nbsp; //Eclipse插件兼容组件&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;span&gt;Mozilla&amp;nbsp;Debug&amp;nbsp;UI&amp;nbsp;Plug-in(Incubation)&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(0, 130, 0);&quot;&gt;//Mozilla调试插件（Mozilla是一款浏览器)&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;Dynamic Languages ToolKit Core UI //对入PHP等动态语言支持的用户接口&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;span&gt;WTP&amp;nbsp;Webservice&amp;nbsp;UI&amp;nbsp;Plug-in&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(0, 130, 0);&quot;&gt;//Web&amp;nbsp;服务视图插件&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&lt;span&gt;JavaServer&amp;nbsp;Faces&amp;nbsp;Tools&amp;nbsp;-&amp;nbsp;Core&amp;nbsp;&lt;/span&gt;&lt;span&gt;//jsf工具核心包&amp;nbsp;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Automatic Updates Scheduler //自动更新&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;Service policy&amp;nbsp; //Web提供的服务性能目标定义,自动管理&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;Atfdebug Plug-in(Incubation)&amp;nbsp; //动态语言的调试工具&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;Auxiliary Web Module Support for MeEclipse// 辅助的Web模块支持.(可能是Struts等文件自动添加)&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color: rgb(237, 28, 36);&quot;&gt;&lt;span&gt;JSF&amp;nbsp;Editor&amp;nbsp;Preview&amp;nbsp;Support&amp;nbsp;&lt;/span&gt;&lt;span&gt;**for**&lt;/span&gt;&lt;span&gt;&amp;nbsp;MyEclipse&lt;/span&gt;&lt;span&gt;//jsf编辑器&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;http://www.javaeye.com/topic/789541&quot; title=&quot;MyEclipse优化设置&quot;&gt;MyEclipse优化设置&lt;/a&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java疑惑和陷阱(一)</title>
   <link href="/blog/2011/03/16/java-puzzles-and-traps-one/"/>
   <updated>2011-03-16T17:12:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/03/16/java-puzzles-and-traps-one</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;找零时刻&lt;/h2&gt;

&lt;p&gt;一定要用BigDecimal(String)构造器，而千万不要BigDecimal(double)。后一个构造器将用它的参数的“精确”值来创建一个实例: new BigDecimal(.1)将返回一个表示0.100000000000000055511151231257827021181583404541015625的BigDecimal。&lt;/p&gt;

&lt;p&gt;在需要精确答案的地方，要避免使用float和double，对于货币计算，要使用int、long或BigDecimal。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;长整除&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class LongDivision{
  public static void main(String args[]){
    final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000;
    final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
    System.out.println(MICROS_PER_DAY/MILLIS_PER_DAY);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段程序打印出的值是5而不是1000。问题在于常数MICROS_PER_DAY的计算&lt;strong&gt;确实&lt;/strong&gt;溢出了。这个计算完全是以int运算来执行的，并且只有在运算完成之后，其结果才被提升到long，而此时已经溢出了。&lt;/p&gt;

&lt;p&gt;这个教训很简单:当你在操作很大的数字时，千万要提防溢出——它可是一个缄默杀手。即使用来保存结果的变量已显得足够大，也并不意味着要产生结果的计算具有正确的类型。当你拿不准时，就使用long运算来执行整个计算。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;初级问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Elementary{
  public static void main(String[] args){
    System.out.println(12345 + 5432l);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从表面上看，程序必定打印66666，但实际上它打印出的是17777。请注意左操作数开头的数字“1“和右操作数结尾的小写字母“l“之间的细微差异。恶心啊！&lt;/p&gt;

&lt;p&gt;小写字母“l“和数字“1“在大多数打字机字体中都是几乎一样的。为避免你的程序的读者对二者产生混淆，千万不要使用小写的“l“来作为long型字面常量的结尾或是作为变量名。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;多重转型&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Multicast{
  public static void main (String[] args){
    System.out.println((int)(char)(byte) -1);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java使用了基于2的补码的二进制运算，因此int类型的数值-1的所有32位都是置位的。从int到byte的转型是很简单的，它执行了一个窄化原始类型转化，直接将除低8位之外的所有位全部砍掉，这样做留下的是一个8位都被置位了的byte，它仍旧表示-1。从byte到char的转型稍微麻烦一点，因为byte是一个有符号类型，而char是一个无符号类型。在将一个整数类型转换成另一个宽度更宽的整数类型时，通常是可以保持其数值的，但是却不可能将一个负的byte数值表示成一个char。因此，从byte到char的转换被认为不是一个拓宽原始类型的转换，而是一个拓宽并窄化原始类型的转换:byte被转换成了int，而这个int又被转换成了char。&lt;/p&gt;

&lt;p&gt;所有这些听起来有点复杂，幸运的是，有一条很简单的规则能够描述从较窄的整型转换成较宽的整型时的符号扩展行为:如果最初的数值类型是有符号的，那么就执行符号扩展;如果它是char，那么不管它将要被转换成什么类型，都执行零扩展。因为byte是一个有符号的类型，所以在将byte数值-1转换成char时，会发生符号扩展。作为结果的char数值的16个位就都被置位了，因此它等于2^16-1，即65535。从char到int的转型也是一个拓宽原始类型转换，所以这条规则告诉我们，它将执行零扩展而不是符号扩展。作为结果的int数值也就成了65535，这正是程序打印出的结果。&lt;/p&gt;

&lt;p&gt;如果你在将一个char数值c转型为一个宽度更宽的类型，并且你不希望有符号扩展，那么为清晰表达意图，可以考虑使用一个位掩码，即使它并不是必需的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i = c &amp;amp; 0xffff;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者，书写一句注释来描述转换的行为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i = c; //不会执行符号扩展&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你在将一个char数值c转型为一个宽度更宽的整型，并且你希望有符号扩展，那么就先将char转型为一个short，它与char具有同样的宽度，但是它是有符号的。在给出了这种细微的代码之后，你应该也为它书写一句注释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i = (short) c; //转型将引起符号扩展&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你在将一个byte数值b转型为一个char，并且你不希望有符号扩展，那么你必须使用一个位掩码来限制它。这是一种通用做法，所以不需要任何注释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char c = (char) (b &amp;amp; 0xff);&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dos-equis&quot;&gt;Dos Equis&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class DosEquis{
  public static void main(String[] args){
    char x = 'X';
    int i = 0;
    System.out.println(true ? x : 0);
    System.out.println(false ? i : x);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个程序应该打印:XX，然而，如果你运行该程序，你就会发现它打印出来的是&lt;strong&gt;X88&lt;/strong&gt;。为什么呢？请注意在这两个表达式中，每一个表达式的第二个和第三个操作数的类型都不相同:x是char类型的，而0和i都是int类型的。混合类型的计算会引起混乱，而这一点比在条件表达式中比在其它任何地方都表现得更明显。&lt;/p&gt;

&lt;p&gt;确定条件表达式结果类型的规则过于冗长和复杂，很难完全记住它们，但是其核心就是以下三点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果第二个和第三个操作数具有相同的类型，那么它就是条件表达式的类型。换句话说，你可以通过绕过混合类型的计算来避免大麻烦。&lt;/li&gt;
  &lt;li&gt;如果一个操作数的类型是T，T表示byte、short或char，而另一个操作数是一个int类型的常量表达式，它的值是可以用类型T表示的，那么条件表达式的类型就是T。&lt;/li&gt;
  &lt;li&gt;否则，将对操作数类型运用二进制数字提升，而条件表达式的类型就是第二个和第三个操作数被提升之后的类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在程序的两个条件表达式中，一个操作数的类型是char，另一个的类型是int。在两个表达式中，int操作数都是0，它可以被表示成一个char。然而，只有第一个表达式中的int操作数是常量(0)，而第二个表达式中的int操作数是变量(i)。因此，第2点被应用到了第一个表达式上，它返回的类型是char，而第3点被应用到了第二个表达式上，其返回的类型是对int和char运用了二进制数字提升之后的类型，即int。&lt;/p&gt;

&lt;p&gt;条件表达式的类型将确定哪一个重载的print方法将被调用。对第一个表达式来说， PrintStream.print(char)将被调用，而对第二个表达式来说， PrintStream.print(int)将被调用。前一个重载方法将变量x的值作为Unicode字符(X)来打印，而后一个重载方法将其作为一个十进制整数(88)来打印。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;复合赋值&lt;/h2&gt;

&lt;p&gt;我们给出一个对变量x和i的声明即可，它肯定是一个合法的语句:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x += i;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，它并不是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = x + i;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;许多程序员都会认为该迷题中的第一个表达式x += i只是第二个表达式 x =x + i的简写方式。但是这并不十分准确。这两个表达式都被称为赋值表达式。
第二条语句使用的是简单赋值操作符(=)，而第一条语句使用的是复合赋值操作符。复合赋值操作符包括 +=、-=、*=、/=、%=、&amp;lt; &amp;lt;=、»=、»&amp;gt;=、&amp;amp;=、^=
和|=，Java语言规范中讲到，复合赋值 E1 op= E2 等价于简单赋值 E1 =(T)((E1)op(E2))，其中”T”是”E1”的类型，除非”E1”只被计算一次。&lt;/p&gt;

&lt;p&gt;换句话说，复合赋值表达式自动地将它们所执行的计算的结果转型为其左侧变量的类型。如果结果的类型与该变量的类型相同，那么这个转型不会造成任何影响。然而，如果结果的类型比该变量的类型要宽，那么复合赋值操作符将悄悄地执行一个窄化原始类型转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;short x = 0;
int i = 123456;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复合赋值编译将不会产生任何错误:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x += i; //包含了一个隐藏的转型!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能期望x的值在这条语句执行之后是123456，但是并非如此，它的值是-7616。因为int类型的数值123456对于short来说太大了，自动产生的转型悄悄地把int数值的高两位给截掉了。&lt;/p&gt;

&lt;p&gt;相对应的简单赋值是非法的，因为它试图将int数值赋值给short变量，它需要一个显式的转型:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = x + i; //不能编译，需要显示转换——“可能会丢失精度”&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复合赋值操作符要求两个操作数都是原始类型的，例如int，或包装了的原始类型，例如Integer，但是有一个例外:如果在+=操作符左侧的操作数是String类型的，那么它允许右侧的操作数是任意类型，在这种情况下，该操作符执行的是字符串连接操作。简单赋值操作符(=)允许其左侧的是对象引用类型，这就显得要宽松许多了:你可以使用它们来表示任何你想要表示的内容，只要表达式的右侧与左侧的变量是赋值兼容的即可。&lt;/p&gt;

&lt;p&gt;总之，复合赋值操作符会悄悄地产生一个转型。如果计算结果的类型宽于变量的类型，那么所产生的转型就是一个危险的窄化转型。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;字符串奶酪&lt;/h2&gt;

&lt;p&gt;下面的程序从一个字节序列创建了一个字符串，然后迭代遍历字符串中的字符，并将它们作为数字打印。请描述一下程序打印出来的数字序列:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class StringCheese {
  public static void main(String[] args) {
    byte bytes[] = new byte[256];
    for (int i = 0; i &amp;lt; 256; i++)
    bytes[i] = (byte)i;
    String str = new String(bytes);
    for (int i = 0， n = str.length(); i &amp;lt; n; i++)
      System.out.println((int)str.charAt(i) + &amp;quot; &amp;quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，byte数组用从0到255每一个可能的byte数值进行了初始化，然后这些byte数值通过String构造器被转换成了char数值。最后，char数值被转型为int数值并被打印。打印出来的数值肯定是非负整数，因为char数值是无符号的，因此，你可能期望该程序将按顺序打印出0到255的整数。&lt;/p&gt;

&lt;p&gt;如果你运行该程序，可能会看到这样的序列。但是再运行一次，可能看到的就不是这个序列了。我们在四台机器上运行它，会看到四个不同的序列，包括前面描述的那个序列。这个程序甚至都不能保证会正常终止，比打印其他任何特定字符串都要缺乏这种保证，它的行为完全是不确定的。&lt;/p&gt;

&lt;p&gt;这里的罪魁祸首就是String(byte[])构造器。有关它的规范描述道:“在通过解码使用平台缺省字符集的指定byte数组来构造一个新的String时，该新String的长度是字符集的一个函数，因此，它可能不等于byte数组的长度。当给定的所有字节在缺省字符集中并非全部有效时，这个构造器的行为是不确定的”。&lt;/p&gt;

&lt;p&gt;J2SE运行期环境(JRE)的缺省字符集依赖于底层的操作系统和语言。如果你想知道你的JRE的缺省字符集，并且你使用的是5.0或更新的版本，那么你可以通过调用 java.nio.charset.Charset.defaultCharset()来了解。如果你使用的是较早的版本，那么你可以通过阅读系统属性file.encoding来了解。&lt;/p&gt;

&lt;p&gt;当你在char序列和byte序列之间做转换时，你可以且通常是应该显式地指定字符集。还可以接受一个字符集名称的String构造器就是专为除了接受byte数字之外，此目的而设计的。如果你用下面的构造器去替换在最初的程序中的String构造器，那么不管缺省的字符集是什么，该程序都保证能够按照顺序打印从0到255的整数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String str = new String(bytes， &amp;quot;ISO-8859-1&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个谜题的教训是:每当你要将一个byte序列转换成一个String时，你都在使用某一个字符集，不管你是否显式地指定了它。如果你想让你的程序的行为是可预知的，那么就请你在每次使用字符集时都明确地指定。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;漂亮的火花&lt;/h2&gt;

&lt;p&gt;面的程序用一个方法对字符进行了分类。这个程序会打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Classifier {
  public static void main(String[] args) {
    System.out.println(
    classify('n') + classify('+') + classify('2'));
  }
  static String classify(char ch) {
    if (&amp;quot;0123456789&amp;quot;.indexOf(ch) &amp;gt;= 0)
      return &amp;quot;NUMERAL &amp;quot;;
    if (&amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;.indexOf(ch) &amp;gt;= 0)
      return &amp;quot;LETTER &amp;quot;;
    /* (Operators not supported yet)
    if (&amp;quot;+-*/&amp;amp;|!=&amp;quot; &amp;gt;= 0)
      return &amp;quot;OPERATOR &amp;quot;;
    */
    return &amp;quot;UNKNOWN&amp;quot;;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你猜想该程序将打印&lt;strong&gt;LETTER UNKNOWN NUMERAL&lt;/strong&gt;，那么你就掉进陷阱里面了。这个程序连编译都通不过。让我们再看一看相关的部分，这一次我们用粗体字突出注释部分:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (&amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;.indexOf(ch) &amp;gt;= 0)
    return &amp;quot;LETTER &amp;quot;;
  /* (Operators not supported yet)
  if(&amp;quot;+-*/&amp;amp;|!=&amp;quot; &amp;gt;= 0)
    return &amp;quot;OPERATOR &amp;quot;;
  */
  return &amp;quot;UNKNOWN&amp;quot;;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你之所见，注释在包含了字符*/的字符串内部就结束了，结果使得程序在语法上变成非法的了。我们将程序中的一部分注释出来的尝试之所以失败了，是因为字符串字面常量在注释中没有被特殊处理。&lt;/p&gt;

&lt;p&gt;总之，块注释不能可靠地注释掉代码段，应该用单行的注释序列来代替。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;我的类是什么?&lt;/h2&gt;

&lt;p&gt;下面这段程序会打印出什么呢：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.javapuzzlers;
public class Me {
  public static void main(String[] args){
    System.out.println(
    Me.class.getName().
    replaceAll(&amp;quot;.&amp;quot;，&amp;quot;/&amp;quot;) + &amp;quot;.class&amp;quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该程序看起来会获得它的类名com.javapuzzlers.Me，然后用“/”替换掉所有出现的字符串“.”，并在末尾追加字符串”.class”。你可能会认为该程序将打印com/javapuzzlers/Me.class，该程序正式从这个类文件中被加载的。如果你运行这个程序，就会发现它实际上打印的是&lt;strong&gt;///////////////////.class&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;问题在于String.replaceAll接受了一个正则表达式作为它的第一个参数，而并非接受了一个字符序列字面常量。(正则表达式已经被添加到了Java平台的1.4版中。)正则表达式“.”可以匹配任何单个的字符，因此，类名中的每一个字符都被替换成了一个斜杠，进而产生了我们看到的输出。&lt;/p&gt;

&lt;p&gt;事实证明，String.replaceAll的第二个参数不是一个普通的字符串，而是一个替代字符串，就像在java.util.regex规范中所定义的样。在替代字符串中出现的反斜杠会把紧随其后的字符进行转义，从而导致其被按字面含义而处理了。&lt;/p&gt;

&lt;p&gt;把上面的程序修改一下就能得到正确的输出了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.javapuzzlers;
public class Me {
  public static void main(String[] args){
    System.out.println(
    Me.class.getName().replaceAll(&amp;quot;\\.&amp;quot;，&amp;quot;/&amp;quot;) + &amp;quot;.class&amp;quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;url&quot;&gt;URL的愚弄&lt;/h2&gt;

&lt;p&gt;本谜题利用了Java编程语言中一个很少被人了解的特性。请考虑下面的程序将会做些什么?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class BrowserTest {
  public static void main(String[] args) {
    System.out.print(&amp;quot;iexplore:&amp;quot;);
    http://www.google.com;
    System.out.println(&amp;quot;:maximize&amp;quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个有点诡异的问题。该程序将不会做任何特殊的事情，而是直接打印&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iexplore::maximize**。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在本谜题中所引用的“Java编程语言中很少被人了解的特性”实际上就是你可以在任何语句前面放置标号。这个程序标注了一个表达式语句，它是合法的，但是却没什么用处。&lt;/p&gt;

&lt;p&gt;这就是说，我们没有任何可能的理由去使用与程序没有任何关系的标号和注释。本谜题的教训是:令人误解的注释和无关的代码会引起混乱。要仔细地写注释，并让它们跟上时代;要切除那些已遭废弃的代码。还有就是如果某些东西看起来过于奇怪，以至于不像对的，那么它极有可能就是错的。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;尽情享受每一个字节&lt;/h2&gt;

&lt;p&gt;下面的程序循环遍历byte数值，以查找某个特定值。这个程序会打印出什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class BigDelight {
  public static void main(String[] args) {
    for (byte b = Byte.MIN_VALUE; b &amp;lt; Byte.MAX_VALUE; b++) {
      if (b == 0x90)
      System.out.print(&amp;quot;Joy!&amp;quot;);
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个循环在除了Byte.MAX_VALUE之外所有的byte数值中进行迭代，以查找0x90。这个数值适合用byte表示，并且不等于Byte.MAX_VALUE，因此你可能会想这个循环在该迭代会找到它一次，并将打印出”Joy!”。但是，所见为虚。如果你运行该程序，就会发现它没有打印任何东西。怎么回事?&lt;/p&gt;

&lt;p&gt;简单地说，0x90是一个int常量，它超出了byte数值的范围。这与直觉是相悖的，因为0x90是一个两位的十六进制字面常量，每一个十六进制位都占据4个比特的位置，所以整个数值也只占据8个比特，即1个字节。问题在于字节（byte）是有符号类型。常量 0x90是一个正的最高位被置位的8位int数值。合法的byte数值是从-128到+127，但是int常量0x90等于&lt;strong&gt;+144&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;请考虑表达式((byte)0x90 == 0x90)，尽管外表看起来是成立的，但是它却等于 false。为了比较byte数值(byte)0x90和int数值0x90，Java通过拓宽原始类型转换将byte提升为一个int，然后比较这两个int数值。因为byte是一个有符号类型，所以这个转换执行的是符号扩展，将负的byte数值提升为了在数字上相等的int数值。&lt;/p&gt;

&lt;p&gt;在本例中，该转换将(byte)0x90提升为int数值-112，它不等于int数值0x90，即+144。当你阅读这个程序时，请记住Java使用的是基于“2“的补码的二进制算术运算。(byte)0x90被转换成int类型的-112的步骤如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.  10010000  //“0x90“是十进制表示，这是二进制表示
2.  11111111111111111111111110010000  //byte类型符号扩展为int类型
3.  //求上面这个二进制补码的十进制表式（先对各位取反，将其转换为十进制数
    //然后加上负号，再减去1）
4.  -112  //“(byte)0x90”被转换成int类型的十进制表示&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-9&quot;&gt;无情的增量操作&lt;/h2&gt;

&lt;p&gt;下面的程序对一个变量重复地进行增量操作，然后打印它的值。那么这个值是什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Increment {
  public static void main(String[] args) {
    int j = 0;
    for (int i = 0; i &amp;lt; 100; i++){
      j = j++;
    }
    System.out.println(j);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;乍一看，这个程序可能会打印100。毕竟，它对j做了100次增量操作。可能会令你感到有些震惊，它打印的不是100而是0。所有的增量操作都无影无踪了，为什么?&lt;/p&gt;

&lt;p&gt;问题出在了执行增量操作的语句上:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;j = j++;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当++操作符被置于一个变量值之后时，其作用就是一个后缀增量操作符:表达式&lt;code&gt;j++&lt;/code&gt;的值等于j在执行增量操作&lt;strong&gt;之前&lt;/strong&gt;的初始值。因此，前面提到的赋值语句首先保存j的值，然后将j设置为其值加1，最后将j复位到它的初始值。换句话说，这个赋值操作等价于下面的语句序列:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int temp = j;
j = j + 1;
j = temp;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序重复该过程100次，之后j的值还是等于它在循环开始之前的值，即0。&lt;/p&gt;

&lt;p&gt;订正该程序非常简单，只需从循环中移除无关的赋值操作，只留下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; 100; i++){
  j++;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;教训:不要在单个的表达式中对相同的变量赋值超过一次。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;在循环中&lt;/h2&gt;

&lt;p&gt;下面的程序计算了一个循环的迭代次数，并且在该循环终止时将这个计数值打印了出来。那么，它打印的是什么呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class InTheLoop {
  public static final int END = Integer.MAX_VALUE;
  public static final int START = END - 100;
  public static void main(String[] args) {
    int count = 0;
    for (int i = START; i &amp;lt; = END; i++){
      count++;
    }
    System.out.println(count);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能会认为它将打印101，但如果你运行该程序，就会发现它压根就什么都没有印。更糟的是，它会持续运行直到你撤销它为止。它从来都没有机会去打印 count，因为在打印它的语句之前插入的是一个无限循环。&lt;/p&gt;

&lt;p&gt;问题在于这个循环会在循环索引(i)小于或等于Integer.MAX_VALUE时持续运行，但是所有的int变量都是小于或等于Integer.MAX_VALUE的。因为它被定义为所有int数值中的最大值。当i达到Integer.MAX_VALUE，并且再次被执行增量操作时，它就有绕回到了Integer.MIN_VALUE。&lt;/p&gt;

&lt;p&gt;如果你需要的循环会迭代到int数值的边界附近时，你最好是使用一个long变量作为循环索引。只需将循环索引的类型从int改变为long就可以解决该问题，从而使程序打印出我们所期望的101:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (long i = START; i &amp;lt; = END; i++)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不使用long类型的循环索引变量也可以解决该问题，但是它看起来并不那么漂亮:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i = START;
do {
  count++;
}while (i++ != END);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果清晰性和简洁性占据了极其重要的地位，那么在这种情况下使用一个long类型的循环索引几乎总是最佳方案。但是有一个例外:如果你在所有的(或者几乎所有的)int数值上迭代，那么使用int类型的循环索引的速度大约可以提高一倍。&lt;/p&gt;

&lt;h2 id=&quot;i&quot;&gt;变幻莫测的i值&lt;/h2&gt;

&lt;p&gt;当你阅读这个程序时，请记住Java使用的是基于2的补码的二进制算术运算，因此-1 在任何有符号的整数类型中(byte、short、int或long)的表示都是所有的位被置位:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Shifty {
  public static void main(String[] args) {
    int i = 0;
    while (-1 &amp;lt; &amp;lt; i != 0)
      i++;
    System.out.println(i);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常量-1是所有32位都被置位的int数值0xffffffff。左移操作符将0移入到由移位所空出的右边的最低位， 移位表达式将i最右边的位设置为0，并保持其余的32-i位为1。很明显，这个循环将完成32次迭代，因为(-1&amp;lt; &amp;lt;i)对任何小于32的i来说都不等于0。你可能期望终止条件测试在i等于32时返回false，从而使程序打印32，但是它打印的并不是32。实际上，它不会打印任何东西，而是进入了一个无限循环。&lt;/p&gt;

&lt;p&gt;问题在于&lt;code&gt;-1&amp;lt;&amp;lt;32&lt;/code&gt;等于-1而不是0，因为移位操作符之使用其右操作数的低5位作为移位长度。如果其左操作数是一个long类型数值，用其低6位来移位。这条规则作用于全部的三个移位操作符:«、»和»&amp;gt;。移位长度总是介于0到31之间，如果左操作数是long类型的，则介于0到63之间。这个长度是对32取余的，如果左操作数是long类型的，则对64取余。如果试图对一个int数值移位32位，或者是对一个long数值移位64位，都只能返回这个数值&lt;strong&gt;自身的值&lt;/strong&gt;。没有任何移位长度可以让一个 int数值丢弃其所有的32位，或者是让一个long数值丢弃其所有的64位。&lt;/p&gt;

&lt;p&gt;幸运的是，有一个非常容易的方式能够订正该问题。我们不是让-1重复地移位不同的移位长度，而是将前一次移位操作的结果保存起来，并且让它在每一次迭代时都向左再移 1位。下面这个版本的程序就可以打印出我们所期望的32:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Shifty {
  public static void main(String[] args) {
    int distance = 0;
    for (int val = -1; val != 0; val &amp;lt; &amp;lt;= 1)
      distance++;
    System.out.println(distance);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-11&quot;&gt;循环者&lt;/h2&gt;

&lt;p&gt;考虑下面的for循环，使得该循环无限循环下去:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = start; i &amp;lt; = start + 1; i++) {}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来它好像应该只迭代两次，但是通过利用溢出行为，可以使它无限循环下去。下面的的声明就采用了这项技巧:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int start = Integer.MAX_VALUE - 1;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在该轮到你了。什么样的声明能够让下面的循环变成一个无限循环?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (i == i + 1) {}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细查看这个while循环，它真的好像应该立即终止。一个数字永远不会等于它自己加1，对吗?嗯，如果这个数字是无穷大的，又会怎样呢?Java强制要求使用IEEE754浮点数算术运算，它可以让你用一个double或float来表示无穷大。正如我们在学校里面学到的，无穷大加1还是无穷大。如果i在循环开始之前被初始化为无穷大，那么终止条件测试i == i + 1就会被计算为true，从而使循环永远都不会终止。&lt;/p&gt;

&lt;p&gt;你可以用任何被计算为无穷大的浮点算术表达式来初始化i，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double i = 1.0 / 0.0;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，你最好是能够利用标准类库为你提供的常量:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double i = Double.POSITIVE_INFINITY;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上，你不必将i初始化为无穷大以确保循环永远执行。任何足够大的浮点数都可以实现这一目的，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double i = 1.0e40;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个例子:请提供一个对i的声明，将下面的循环转变为一个无限循环:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (i != i) {
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个循环可能比前一个还要使人感到困惑。不管在它前面作何种声明，它看起来确实应该立即终止。一个数字总是等于它自己，对吗?&lt;/p&gt;

&lt;p&gt;对，但是IEEE754浮点算术保留了一个特殊的值用来表示一个不是数字的数量。这个值就是NaN(“不是一个数字(Not a Number)”的缩写)，对于所有没有良好的数字定义的浮点计算，例如 0.0/0.0，其值都是它。规范中描述道，NaN不等于任何浮点数值，包括它自身在内。因此，如果i在循环开始之前被初始化为NaN，那么终止条件测试(i != i)的计算结果就是true，循环就永远不会终止。很奇怪但却是事实。&lt;/p&gt;

&lt;p&gt;你可以用任何计算结果为NaN的浮点算术表达式来初始化i，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double i = 0.0 / 0.0;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，为了表达清晰，你可以使用标准类库提供的常量:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;double i = Double.NaN;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NaN还有其他的惊人之处。任何浮点操作，只要它的一个或多个操作数为NaN，那么其结果为NaN。这条规则是非常合理的，但是它却具有奇怪的结果。例如，下面的程序将打印false:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Test {
  public static void main(String[] args) {
    double i = 0.0 / 0.0;
    System.out.println(i - i == 0);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这条计算NaN的规则所基于的原理是:一旦一个计算产生了NaN，它就被损坏了，没有任何更进一步的计算可以修复这样的损坏。NaN值意图使受损的计算继续执行下去，直到方便处理这种情况的地方为止。&lt;/p&gt;

&lt;p&gt;总之，float和double类型都有一个特殊的NaN值，用来表示不是数字的数量。对于涉及NaN值的计算，其规则很简单也很明智，但是这些规则的结果可能是违背直觉的。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Java的四种引用类型</title>
   <link href="/blog/2011/03/05/four-types-of-reference-in-java/"/>
   <updated>2011-03-05T14:58:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/03/05/four-types-of-reference-in-java</id>
   <content type="html">&lt;p&gt;在Java中有四种引用类型，他们是：强引用(Strong Reference)，软引用(Soft Reference)，弱引用(Weak Reference) 和 虚引用(Phantom Reference)。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;四种引用类型的解释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JVM会持有一般对象直到他们不再是可触及的状态。换句话说，当没有任何有效引用指向他们的时候会被垃圾回收，无效引用不会被计算在内。&lt;/li&gt;
&lt;li&gt;软引用指向的对象会在不存在任何指向他们的引用并且内存空间不足情况下被垃圾收集。大多数情况下被用来实现内存敏感的缓存。没有GC的时间限制，会在OOM发生之前清理完毕。&lt;/li&gt;
&lt;li&gt;弱引用指向的对象会在没有任何引用指向他们的时候立即被垃圾收集。如果一个对象只有弱引用的话，那么这个对象是不可触及的。这些对象会在任何时候被垃圾收集并且会在下一个GC周期里被丢弃。&lt;/li&gt;
&lt;li&gt;虚引用指向的是已经执行finalize方法，但是还没有回收内存的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;四种引用类型的比较&lt;/h2&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tr&gt;
&lt;td colspan=&quot;5&quot; style=&quot;text-align:center;&quot;&gt;Strong vs Soft vs Weak vs Phantom References
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;类型&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;目的&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;作用&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;触发GC条件&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;实现类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;强引用&lt;/td&gt;
&lt;td&gt;普通引用类型，只要对象的引用是强引用，他们就不会被垃圾收集&lt;/td&gt;
&lt;td&gt;普通引用&lt;/td&gt;
&lt;td&gt;任何对象如果不是强引用都可以被垃圾收集&lt;/td&gt;
&lt;td&gt;默认类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;软引用&lt;/td&gt;
&lt;td&gt;在内存足够的时候，对象不会被垃圾收集&lt;/td&gt;
&lt;td&gt;为了保证即使对象没有任何引用指向它的时候也不会被垃圾收集，防止有引用再次指向这个对象&lt;/td&gt;
&lt;td&gt;在第一次GC后，JVM需要回收更多的空间&lt;/td&gt;
&lt;td&gt;java.lang.ref.SoftReference&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;弱引用&lt;/td&gt;
&lt;td&gt;在对象可触及的状态下不会被垃圾收集&lt;/td&gt;
&lt;td&gt;如果对象不再被引用会被自动回收&lt;/td&gt;
&lt;td&gt;GC后对象只有弱引用&lt;/td&gt;
&lt;td&gt;java.lang.ref.WeakReference
&lt;br /&gt;
java.util.WeakHashMap&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;虚引用&lt;/td&gt;
&lt;td&gt;让你可以清理已经执行finalize方法，但是还没有回收内存的对象&lt;/td&gt;
&lt;td&gt;特殊清理&lt;/td&gt;
&lt;td&gt;finalize方法执行之后&lt;/td&gt;
&lt;td&gt;java.lang.ref.PhantomReference&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;
</content>
 </entry>
 
 <entry>
   <title>Objective-C学习笔记</title>
   <link href="/blog/2011/02/24/objective-c-note/"/>
   <updated>2011-02-24T14:26:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/02/24/objective-c-note</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;基本数据类型&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://farm6.static.flickr.com/5214/5488573123_a7dfd0551c_z.jpg&quot; alt=&quot;基本数据类型&quot; title=&quot;基本数据类型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm6.static.flickr.com/5176/5488563233_153dd27348_z.jpg&quot; alt=&quot;基本数据类型&quot; title=&quot;基本数据类型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;id : 可以保存任何类型的对象，也就是对象的泛型类型。(id类型非常重要，因为他是Objective-C中的重要特性多态和动态绑定的基础)&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;类,对象和函数&lt;/h2&gt;

&lt;p&gt;(1) 函数调用方式&lt;/p&gt;

&lt;p&gt;[ ClassOrInstance method ] 也可以理解为： [ receiver message ]&lt;/p&gt;

&lt;p&gt;(2) 类的声明与实现&lt;/p&gt;

&lt;p&gt;@interface是类的声明关键字，一般的格式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface NewClassName: ParentClassName 
{ 
    memberDeclarations; 
}  
methodDeclarations; 
@end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@implementation是类的实现关键字，一般的格式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@implementation NewClassName 
    methodDefinitions; 
@end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3) 自动生成类属性的setter和getter函数的方法&lt;/p&gt;

&lt;p&gt;先在类的声明里用&lt;strong&gt;@property&lt;/strong&gt;关键字定义类的属性，然后在类实现文件中用&lt;strong&gt;@synthesize&lt;/strong&gt;关键字。&lt;/p&gt;

&lt;p&gt;(4) self： 本类的实例&lt;/p&gt;

&lt;p&gt;(5) @class： 可以让编译器知道要引用的类的类型，但如果用到类中的属性或函数，那就要用 #import “XXX.h“ 来代替。&lt;/p&gt;

&lt;p&gt;(6) 如果某个对象调用继承自NSObject中的release函数，那么这个对象只会在没有任何引用的情况下才会释放内存，release函数通过调用实际释放内存的 dealloc函数来实现释放内存的操作(不要重写release函数，而是重写dealloc函数)。&lt;/p&gt;

&lt;p&gt;(6) 异常捕获&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@try { 
  statement 
  statement 
  ... 
} 
@catch (NSException *exception) { 
  statement 
  statement 
  ... 
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(7) volatile： 防止编译器优化看似多余的变量赋值&lt;/p&gt;

&lt;p&gt;(8) @protocol： 类似于Java中的接口，跟在@interface后尖括号（&amp;lt; …&amp;gt;）中。声明在@protocol中的函数必须实现，而声明在@optional中的函数可以不实现。&lt;/p&gt;

&lt;p&gt;(9) 属性特性&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm6.static.flickr.com/5180/5488588537_1f41be3c8e_z.jpg&quot; alt=&quot;属性特性&quot; title=&quot;属性特性&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>闭包及其在Java中的模拟实现</title>
   <link href="/blog/2011/02/10/simulate-closure-in-java/"/>
   <updated>2011-02-10T14:04:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/02/10/simulate-closure-in-java</id>
   <content type="html">&lt;p&gt;在上一篇博文 &lt;a href=&quot;http://liuxuan.info/blog/2011/01/28/java-anonymous-class/&quot; title=&quot;为什么Java匿名内部类中的方法参数必须定义为final&quot;&gt;为什么Java匿名内部类中的方法参数必须定义为final&lt;/a&gt; 中提到在Stackoverflow上搜索答案时，有老外在答案中提到了&lt;strong&gt;Closure&lt;/strong&gt;这个词，而这篇博文中就是关于闭包的。&lt;/p&gt;

&lt;p&gt;我们先来看一下维基上给出的关于闭包的解释：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In computer science, a &lt;strong&gt;closure&lt;/strong&gt; is a first-class function with free variables that are bound in the lexical &amp;gt; environment. Such a function is said to be “closed over” its free variables. A closure is defined within the scope of &amp;gt; its free variables, and the extent of those variables is at least as long as the lifetime of the closure itself.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第一次看这段英文的解释的时候很难搞懂他的意思，原因在于其中出现了较多第一次碰见的计算机编程领域的专业术语，如果不把这些专业术语搞明白的话整段话就自然而然搞不明白了。&lt;/p&gt;

&lt;p&gt;我们来逐个看一下这些专业名词，首先第一个是&lt;strong&gt;first-class function&lt;/strong&gt;。有一个与first-class function对应的名词是first-class object，维基上给出的解释是：第一类对象是个实体，它可以被当作函数的参数，可以从子程序中返回，可以赋值给变量。那么套用到first-class function的话就是：如果某种函数可以作为其他函数的参数传入，可以赋值给变量，可以被函数动态的创建和返回，那么这类函数被称为first-class function即第一类函数。&lt;/p&gt;

&lt;p&gt;看了这个定义后你可能会有这样一个疑问：在命令式编程语言（例如Java）中我们也可以把返回类型不是void的函数的调用作为另一个函数的参数传入。其实在这个场景里，函数参数的类型还是基本类型或者引用类型，我们只是把原来的两行代码写在了一行里，真正传入的还是基本类型或者引用类型。而第一类函数可以作为参数传入另一个函数是指：可以在一段程序的执行过程中可以创建新的函数，可以在数据结构中保存新创建的函数，可以把这些新创建的函数作为参数传给其他函数，并且可以作为其他函数的返回值。也就是说其他函数可以把第一类函数（整个声明体或匿名）做为他的参数存在，这是和一般的命令式编程语言很大的区别（C#等混合语言除外）。&lt;/p&gt;

&lt;p&gt;好了，上面只是文字上的解释，我们来看一下第一类函数的例子：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第一类函数赋值给变量，这个函数的作用是对每个Int类型的值都加1：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;var increase = (x : Int) =&amp;gt; x + 1&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;第一类函数作为参数传给另一个函数，这个函数的作用是打印集合中的每个元素：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;List.foreach((x : Int) =&amp;gt; println(x))&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;第一类函数作为返回值，这个函数的作用是对x求导：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;using System;
class Program
{
    // f: function that takes a double and returns a double
    // deltaX: small positive number
    // returns a function that is an approximate derivative of f
    static Func＜double , double＞ MakeDerivative(Func＜double , double＞ f, double deltaX)
    {
        return x =&amp;gt; (f(x + deltaX) - f(x)) / deltaX;
    }
    static void Main()
    {
        var cos = MakeDerivative(Math.Sin, 0.00000001);
        Console.WriteLine(cos(0));                    // 1
        Console.WriteLine(cos(Math.PI / 2));          // 0
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再来看看&lt;strong&gt;free variable（自由变量）&lt;/strong&gt;是个什么东西。维基上的解释是：自由变量是一个函数中的变量，并且既没有在上下文声明过，也不是函数的参数，并且会在函数的创建执行过程中被特定的值替换。lexical environment可以理解为变量的作用域。&lt;/p&gt;

&lt;p&gt;现在我们可以来翻译这段关于闭包的解释了：
&amp;gt; 闭包是第一类函数和自由变量绑定在作用域中，这种函数被称为“关闭”他的自由变量。闭包是被定义在他的自由变量的作用域中，并且这些自由变量的生命周期至少跟闭包本身的生命周期一样。
因为闭包需要的第一类函数和自由变量是函数式编程语言必须的要素，所以闭包更多的是在函数式编程语言中应用（JavaScript除外）。而Java不支持第一类函数，所以Java目前还不支持闭包（至少目前不支持），但是我们可以通过内部类来模拟闭包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final User user = new User();
new AbstractExecutionThreadService() {
    @Override
    protected void run() throws Exception {
    mailManager.sendActivateMail(user);
    }
}.start();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实关于Java引入闭包的争论由来已久，几个月之前有消息说在JDK 7中将支持lamda表达式。我也看过Java的lamda语法的示例，但是看过后就感觉即使把那些蛋疼的语法加入到Java中去，是不是也会有蛋疼的程序员去用？如果蛋疼的程序员写了蛋疼的代码，那读代码的人岂不是更蛋疼？&lt;/p&gt;

&lt;p&gt;现在已经有很多OO和FP混合的语言，比如Scala,Ruby,Python，C#现在更是把动态语言的特性也引入进去。我想说是不是真的有必要这么做？以C#为例，Linq可以把几行的循环代码等价转换成只有一行代码，这确实提高了编码效率。但是从我的感受来说，如果大段的命令式代码中突然夹杂了几行函数式的代码有一种非常强烈的跳跃感，除非你对命令式和函数式语言都非常的熟悉。&lt;/p&gt;

&lt;p&gt;语言之争（或者平台之争）一直是在激烈的持续着，这种情况下有点像冷战思维也不觉得奇怪，但是我觉得Java没必要跟C#学，C#想把自己变成一把瑞士军刀，但是，我们日常生活中有多少机会会用到这把功能虽多但很难用的刀呢？&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>为什么Java匿名内部类中的方法参数必须定义为final</title>
   <link href="/blog/2011/01/28/java-anonymous-class/"/>
   <updated>2011-01-28T13:01:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/01/28/java-anonymous-class</id>
   <content type="html">&lt;p&gt;今天在做一个功能，就是用户在注册后给他发送帐号激活邮件。在做这个功能的时候，我用匿名内部类来创建一个线程发送激活邮件，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Controller()
@RequestMapping(value = &amp;quot;/users&amp;quot;)
public class UserController {

  @Autowired
  private MailManager mailManager;

  public void setMailManager(MailManager  mailManager) {
    this.mailManager = mailManager;
  }

  @RequestMapping(method = RequestMethod.POST)
  public String doingSignUp(@RequestParam(&amp;quot;user_email_address&amp;quot;) String user_email_address, @RequestParam(&amp;quot;user_password&amp;quot;) String user_password, @RequestParam(&amp;quot;user_name&amp;quot;) String user_name) {

    try {
      //用户注册代码省略
      new AbstractExecutionThreadService() {
      @Override
      protected void run() throws Exception {
      mailManager.sendActivateMail(user);//发送邮件
      }}.start();
    } catch (Exception e) {
      e.printStackTrace();
    }
      return &amp;quot;index&amp;quot;;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MVC框架用的是SpringMVC，创建多线程的时候使用了Google的 &lt;a href=&quot;http://code.google.com/p/guava-libraries/&quot; title=&quot;guava&quot;&gt;guava&lt;/a&gt; 工具包。从代码中可以看到，AbstractExecutionThreadService是抽象类并且里面重写了run方法，而run方法里面就是干发送邮件这一件事。那么到这里就有一个问题了，由于sendActivateMail这个方法需要一个User类作为参数，而这个发送邮件的方法是在匿名内部类的里面，所以这个User类必须满足下列两个条件之一：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;作为UserController类的实例变量&lt;/li&gt;
  &lt;li&gt;在doingSignUp方法中把User类定义为final的局部变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般在写Web程序的时候碰到类的实例变量的时候我们就因该当心多线程问题了，这里也是一样。由于SpringMVC里的Controller类不是线程安全的，所以第一种把User类定义为实例变量的方法就不能用了。剩下就只有用第二种方法：把User类定义为final。到这里第二个问题来了，这个问题也是我以前没有想过的：为什么匿名内部类里的方法参数只能是final的。&lt;/p&gt;

&lt;p&gt;在《Core Java 8th Editon》里是这么说的： &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A local variable  that is declared final cannot be modified after it has been initialized. Thus,  it is guaranteed that the local variable and the copy that is made inside the  local class always have the same value.  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这句话是在介绍局部内部类的时候说的，用到匿名内部类上是一样的。简单的两句话只说了局部变量要和它的拷贝要保持一致，但为什么要保持一致没有说。&lt;/p&gt;

&lt;p&gt;继续在Stackoverflow上搜索了，发现了这个帖子： &lt;a href=&quot;http://stackoverflow.com/questions/3910324?tab=active#tab-top&quot; title=&quot;Why inner  classes require &amp;quot;final&amp;quot; outer instance variables&quot;&gt;Why inner  classes require “final” outer instance variables&lt;/a&gt;。 在这个帖子里还提到了另一个词：「Closure」即&lt;strong&gt;闭包&lt;/strong&gt;。这里只给出 &lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot; title=&quot;维基百科上关于闭包的解释&quot;&gt;维基百科上关于闭包的解释&lt;/a&gt; 。在这个帖子里又一次提到了为了防止在匿名内部类中的方法执行之前改变外部类局部变量的值，避免一些不可预测（奇怪）的问题，必须把外部类的局部变量声明为final。&lt;/p&gt;

&lt;p&gt;我们再来研究一下编译好的class文件会发现，UserController类被编译成了两个class文件：UserController.class和UserController$1.class。其中UserController.class就是UserController.java编译的字节码文件，而UserController$1.class则是UserController类里的匿名内部类。&lt;/p&gt;

&lt;p&gt;现在我们来看一下这两个class文件里面都有些什么。命令行输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\&amp;gt;javap -private UserController
Compiled from &amp;quot;UserController.java&amp;quot;
public class info.liuxuan.controller.UserController extends java.lang.Object{
private info.liuxuan.mail.MailManager mailManager;
public info.liuxuan.controller.UserController();
public void setMailManager(info.liuxuan.mail.MailManager);
public java.lang.String doingSignUp(java.lang.String, java.lang.String, java.lang.String);
static info.liuxuan.mail.MailManager access$0(info.liuxuan.controller.UserController);
}

D:\&amp;gt;javap -private UserController$1
Compiled from &amp;quot;UserController.java&amp;quot;
class info.liuxuan.controller.UserController$1 extends com.google.common.util.concurrent.AbstractExecutionThreadService{
final info.liuxuan.controller.UserController this$0;
private final info.liuxuan.entity.User val$user;
info.liuxuan.controller.UserController$1(info.liuxuan.controller.UserController,  info.liuxuan.entity.User);
protected void run() throws java.lang.Exception;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以清楚的看到在UserController$1.class中User类已经变成了UserController$1的私有成员变量，并且通过构造方法来初始化。现在来看的话就可以理解为什么要保持一致了：&lt;strong&gt;构造方法传入外部类方法的局部变量，如果在内部类方法执行之前改变的话将发生与意料之外的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也许你已经注意到了，在UserController.class中的access$0方法被定义成了static，那么这又是为什么呢？答案是为了不被其他子类重写。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>2011年的计划</title>
   <link href="/blog/2011/01/01/plans-for-2011/"/>
   <updated>2011-01-01T11:19:00+08:00</updated>
   <id>http://liuxuan.info/blog/2011/01/01/plans-for-2011</id>
   <content type="html">&lt;p&gt;2011年到了，离2012也只有一年的时间了。以前没有博客的时候也没有个地方在年初的时候制定个计划，从今年开始，在每年年初给自己制定个计划，到了年末再回过头来看看完成了其中的多少，给自己一个鞭策。&lt;/p&gt;

&lt;p&gt;在2011年里我希望可以完成这几件事:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;读10本以上的书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;至少研究2个框架的源代码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多写博客&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看完韩语教程1-3&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多做一些运动&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;买一个苹果的笔记本（争取在今年完成）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等到明年这个时候再来看看完成了多少。&lt;/p&gt;
</content>
 </entry>
 

</feed>