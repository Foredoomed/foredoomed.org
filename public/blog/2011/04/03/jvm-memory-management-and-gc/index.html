<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Foredoomed">
  <meta name="generator" content="jekyll">
  <meta name="description" content="The homepage of Zhixingheyi">
  <link href="favicon.ico" rel="icon" type="image/x-icon" />
  <link rel="stylesheet" href="/css/highlight.css" type="text/css">
  <title></title>
</head>

<body>

<div style="width:700px">
  <h1>JVM内存管理和垃圾收集</h1>

<em>By Foredoomed on <time date="2011-04-03 18:52:00 +0800">April  3, 2011</time></em>

<h2 id="java">Java基本类型和类的大小</h2>

<p>Java手册上的类型大小</p>

<p>byte : 8-bit                           <br />
short : 16-bit<br />
char : 16-bit unsigned integer                       <br />
Int : 32-bit<br />
float : 32-bit                             <br />
long : 64-bit                           <br />
double: 64-bit                              <br />
boolean: 1-bit                             </p>

<p>实际存储大小(根据JVM实现而定)</p>

<p>Byte : 16 bytes<br />
Short : 16 bytes<br />
Integer : 16 bytes<br />
Long : 16 bytes<br />
Character : 16 bytes<br />
Float : 16 bytes<br />
Double : 16 bytes<br />
Boolean : 16 bytes<br />
Object ：8 bytes  </p>

<h2 id="jvm">JVM的堆结构</h2>

<p><img src="http://farm6.static.flickr.com/5136/5504939947_19ed9a8dbc.jpg" alt="JVMHeapStructure" title="JVMHeapStructure" /></p>

<p>运行时数据区域，所有类实例和数组的内存均从此处分配，由Java 虚拟机启动时创建。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。</p>

<p>堆由两部分组成:</p>

<p>Eden + From Space(S0) + To Space(S1): 也叫做Young Generation(年轻代)</p>

<p>Tenured Space: 也叫做Old Generation(老年代)</p>

<p>Survivor Space: 包括S0和S1</p>

<p>permanent space(方法区)： JVM具有一个由所有线程共享的方法区。它存储每个类结构，如运行时常数池、字段和方法数据，以及方法和构造方法的代码，它是在Java虚拟机启动时创建的，<strong>不包括在JVM堆内</strong>，默认为4M。 </p>

<p>这个区域主要存放：</p>

<p>类的信息</p>

<ul>
  <li>包名</li>
  <li>父类的包名</li>
  <li>类或接口</li>
  <li>类型修饰符</li>
  <li>父接口包名</li>
</ul>

<p>其它信息</p>

<ul>
  <li>类型的常量池</li>
  <li>属性 </li>
  <li>方法</li>
  <li>类里的静态变量(除了常量)</li>
  <li>一个指向ClassLoader的引用 </li>
  <li>一个指向Class类的引用</li>
</ul>

<h2 id="gc">GC的工作流程</h2>

<ol>
  <li>绝大多数情况下对象初始化被分配在 Eden 中(一个非常大的对象会被分配在老年代中)。  </li>
  <li>如果 Eden 空间占满了，会触发 minor GC。 Minor GC 后仍然存活的对象会被复制到 S0 中去。这样 Eden 就被清空可以分配给新的对象。  </li>
  <li>又触发了一次 Minor GC，S0 和 Eden 中存活的对象被复制到 S1 中，并且 S0 和 Eden 被清空。 在同一时刻, 只有 Eden 和一个 Survivor Space 同时被操作。  </li>
  <li>当每次对象从 Eden 复制到 Survivor Space 或者从 Survivor Space 中的一个复制到另外一个，有一个计数器会自动增加值。 默认情况下如果复制发生超过16次， JVM 会停止复制并把他们移到老年代中去。  </li>
  <li>如果一个对象不能在 Eden 中被创建，它会直接被创建在老年代中。 如果老年代的空间被占满会触发老年代的 GC，也被称为 Full GC。full GC 是一个压缩处理过程，所以它比 Minor GC 要慢很多。  </li>
</ol>

<h2 id="gc-1">GC算法</h2>

<h3 id="serial-collector">Serial Collector</h3>

<p>大部分平台默认，或者强制 java -client。
Young Generation  = Serial
Old Generation  = Serial (Mark-Sweep-Compact)
这种方法的缺点很明显：Stop-the-world, 速度慢，服务器应用不推荐使用。</p>

<h3 id="parallel-collector">Parallel Collector</h3>

<p>在Linux x64上默认是这种算法，其他平台要加 java -server 参数。
Young Generation = parallel，多个thread同时copy
Old Generation = Mark-Sweep-Compact = 1
优点：新生代回收更快。因为系统大部分时间做的GC都是新生代的，这样提高了Throughput(CPU用于非GC时间)。
缺点：当运行在8G/16G Server 上 Old Generation 存活对象太多的时候暂停时间(Pause Time)过长。</p>

<h3 id="parallel-compacting-collector-parallelold">Parallel Compacting Collector (ParallelOld)</h3>

<p>Young Generation = parallel 
Old Generation = parallel
优点：Old Generation 上性能较 Parallel Collector 方式有提高。
缺点：大部分Server系统Old Generation内存占用会达到60%-80%, Compact方面开销比起Parallel Collector并没明显减少。</p>

<h3 id="concurent-mark-sweepcms-collector-low-latency-collector">Concurent Mark-Sweep(CMS) Collector (low-latency collector)</h3>

<p>Young Generation = parallel 
Old Generation = CMS
同时不做 compact 操作。
优点：Pause Time会降低，Pause Time敏感但CPU有空闲的场景需要建议使用。缺点：CPU占用过多，CPU密集型服务器不适合。需要更大的堆空间，会造成很多碎片。</p>

<table border="1">
<tbody>
<tr>
<td width="173" valign="top" />
<td width="100" valign="top">Generational Area</td>
<td width="550" valign="top">Characteristics</td>
</tr>
<tr>
<td width="173" valign="top">Serial</td>
<td width="100" valign="top">Young</td>
<td width="550" valign="top">Stop The World, Copying Collector, Single GC thread.   (works as described in the previous article).</td>
</tr>
<tr>
<td width="173" valign="top">Serial Old (MSC)</td>
<td width="100" valign="top">Old</td>
<td width="550" valign="top">Stop the World, Mark Sweep Compact (MSC), Single GC thread</td>
</tr>
<tr>
<td width="173" valign="top">Parallel Scavenge</td>
<td width="100" valign="top">Young</td>
<td width="550" valign="top">Stop the World, copying collector, multiple GC threads.   Provides higher throughput by executing GC tasks in parallel with each other   (but not the app).<p />
<p>Cannot run during concurrent phases of the CMS.</p></td>
</tr>
<tr>
<td width="173" valign="top">Parallel New</td>
<td width="100" valign="top">Young</td>
<td width="550" valign="top">As Parallel Scavenge, but can run during the concurrent   phases of the CMS</td>
</tr>
<tr>
<td width="173" valign="top">Parallel Old/ Parallel Compacting</td>
<td width="100" valign="top">Old</td>
<td width="550" valign="top">Similar to Parallel Scavenge, but operates on the old generation.<p />
<p>uses multiple GC threads to speed up the work of Serial   Old (MSC).</p>
<p>STW collector, but higher throughput for old generation   collections.</p></td>
</tr>
<tr>
<td width="173" valign="top">Concurrent Mark-Sweep (CMS)</td>
<td width="100" valign="top">Old</td>
<td width="550" valign="top">Breaks up its work into phases, and executes most of its phases concurrently with the application thread – resulting in low latency. However, it introduces substantial management overhead and results in a fragmented heap.</td>
</tr>
</tbody>
</table>

<h2 id="section">垃圾收集器的选择</h2>

<table border="1">
<tbody>
<tr>
<td width="179" valign="top"><strong>Switch </strong></td>
<td width="151" valign="top"><strong>Young Generation</strong></td>
<td width="385" valign="top"><strong>Old Generation</strong></td>
</tr>
<tr>
<td width="179" valign="top">UseSerialGC</td>
<td width="151" valign="top"><em>Serial</em></td>
<td width="385" valign="top">Serial Old (MSC)</td>
</tr>
<tr>
<td width="179" valign="top">UseParNewGC</td>
<td width="151" valign="top">ParNew</td>
<td width="385" valign="top">Serial Old (MSC)</td>
</tr>
<tr>
<td width="179" valign="top">UseConcMarkSweepGC</td>
<td width="151" valign="top">ParNew</td>
<td width="385" valign="top"><em>CMS (mostly used)</em><p />
<p>Serial Old (used when concurrent mode failure occurs)</p></td>
</tr>
<tr>
<td width="179" valign="top">+UseParallelGC</td>
<td width="151" valign="top"><em>Parallel Scavenge</em></td>
<td width="385" valign="top">Serial Old</td>
</tr>
<tr>
<td width="179" valign="top">UseParallelOldGC</td>
<td width="151" valign="top"><em>Parallel Scavenge</em></td>
<td width="385" valign="top"><em>Parallel Old</em></td>
</tr>
<tr>
<td width="179" valign="top">+UseConcMarkSweepGC<br />
-UseParNewGC</td>
<td width="151" valign="top"><em>Serial</em></td>
<td width="385" valign="top"><em>CMS<br />
<span style="font-style: normal;">Serial Old</span></em><p />
<p><em> </em></p></td>
</tr>
</tbody>
</table>

<h2 id="jvm-1">JVM的默认设置</h2>

<p>堆（heap）即（New Generation 和 Old Generaion 之和）的设置</p>

<ul>
  <li>初始分配的内存由 -Xms 指定，默认是物理内存的1/64但小于1G。</li>
  <li>最大分配的内存由 -Xmx 指定，默认是物理内存的1/4但小于1G。</li>
  <li>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以由 -XX:MinHeapFreeRatio 指定。</li>
  <li>默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以由 -XX:MaxHeapFreeRatio 指定。</li>
  <li>服务器一般设置 -Xms 、 -Xmx 相等以避免在每次GC后调整堆的大小，所以上面的两个参数没啥用。 </li>
  <li>-Xmn 设置Young Generation的heap大小。</li>
  <li>-XX:MinHeapFreeRatio 与 -XX:MaxHeapFreeRatio 设定空闲内存占总内存的比例范围，这两个参数会影响GC的频率和单次GC的耗时。 -XX:NewRatio 决定Young与Old Generation的比例。Young generation空间越大，Minor GC频率越低，但是Old Generation空间小了，又可能导致Major GC频率增加。 -XX:NewSize 和 -XX:MaxNewSize 直接指定了Young Generation的缺省大小和最大大小。</li>
</ul>

<p>非堆内存的设置</p>

<p>默认分配为64M</p>

<p>-XX:PermSize 设置最小分配空间， -XX:MaxPermSize 设置最大分配空间。一般把这两个数值设为相同，以减少申请内存空间的时间。</p>

<h2 id="gc-2">GC调优</h2>

<p>参考：<a href="http://java.sun.com/docs/hotspot/gc1.4.2/example.html" title="GC调优例子">GC调优例子</a></p>

<ul>
  <li>设置Xms=Xmx=3/4物理内存(或50%-70%)，-Xmn为1/4的-Xmx值，新生代必须小于堆的一半大</li>
  <li>如果是CPU密集型服务器，使用–XX:+UseParallelOldGC, 否则–XX:+UseConcMarkSweepGC</li>
  <li>新生代,Parallel/ParallelOld可设大于Xmx1/4，CMS可设小，小于Xmx1/4</li>
  <li>通常情况下，JVM堆的大小应为物理内存的80%</li>
  <li>使用-verbose:gc和-XX:+PrintGCDetails观察GC性能</li>
</ul>

<h2 id="dump-heap">Dump heap</h2>

<p>Linux下： jmap -dump:file=xxx.hprof pid  (其中 pid 通过 ps -aux 命令查看)</p>

<p>命令行: jstat -gcutil pid p1 p2  (其中 p1 表示每多少毫秒打印一次； p2 表示一共打印几次)</p>

<p>输出的参数含义：</p>

<ul>
  <li>S0：Heap上的 Survivor space 0 段已使用空间的百分比</li>
  <li>S1：Heap上的 Survivor space 1 段已使用空间的百分比</li>
  <li>E： Heap上的 Eden space 段已使用空间的百分比</li>
  <li>O： Heap上的 Old space 段已使用空间的百分比</li>
  <li>P： Perm space 已使用空间的百分比</li>
  <li>YGC：从程序启动到采样时发生Young GC的次数</li>
  <li>YGCT：Young GC所用的时间(单位秒)</li>
  <li>FGC：从程序启动到采样时发生Full GC的次数</li>
  <li>FGCT：Full GC所用的时间(单位秒)</li>
  <li>GCT：用于垃圾回收的总时间(单位秒)</li>
</ul>

<p>jstat命令其他参数含义：</p>

<ul>
  <li>jstat -class pid:显示加载class的数量，及所占空间等信息。 </li>
  <li>jstat -compiler pid:显示VM实时编译的数量等信息。 </li>
  <li>jstat -gc pid:可以显示gc的信息，查看gc的次数，及时间。其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full  gc的时间，gc的总时间。 </li>
  <li>jstat -gccapacity:可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。其他的可以根据这个类推， OC是old内纯的占用量。 </li>
  <li>jstat -gcnew pid:new对象的信息。 </li>
  <li>jstat -gcnewcapacity pid:new对象的信息及其占用量。 </li>
  <li>jstat -gcold pid:old对象的信息。 </li>
  <li>jstat -gcoldcapacity pid:old对象的信息及其占用量。 </li>
  <li>jstat -gcpermcapacity pid: perm对象的信息及其占用量。 </li>
  <li>jstat -util pid:统计gc信息统计。 </li>
  <li>jstat -printcompilation pid:当前VM执行的信息。 </li>
</ul>

<p>GC日志： -Xloggc:d:\gc.log -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps – add time stamp </p>

<h2 id="javalangoutofmemoryerror">内存泄漏-java.lang.OutOfMemoryError</h2>

<p>Java heap space</p>

<ul>
  <li>Configuration issue: -Xmx</li>
  <li>Memory Leak: The excessive use of finalizers</li>
  <li>PermGen space: Too many classes -XX:MaxPermSize </li>
  <li>Requested array size exceeds VM limit: Need a so big array?</li>
  <li>Request <size> bytes for <reason>: Out of swap space?</reason></size></li>
  <li>Native Memory Leak</li>
  <li>
    <reason> <stack trace=""> (Native method)
</stack></reason>
  </li>
  <li>Native Memory Allocation Issue </li>
</ul>

<p>Perm Memory Leak</p>

<p>Too Many Interned String</p>

<ul>
  <li>String.intern()</li>
  <li>Constant String will be interned implicitly</li>
  <li>No Enough Info provided by Heap Dump on Interned String</li>
  <li>If Perm Memory increased dynamically, be careful</li>
</ul>

<p>Too Many Classes or Class Load Leak</p>

<ul>
  <li>Enlarge the perm generation</li>
  <li>Avoid duplicated class loader</li>
</ul>

<p>Out of Swap Space</p>

<ul>
  <li>Enlarge the swap space</li>
  <li>Systems with 4GB of ram or less require a minimum of 2GB of swap space</li>
  <li>Systems with 4GB to 16GB of ram require a minimum of 4GB of swap space</li>
  <li>For Unix Family OS, use pmdump or pmap, libumem for Solaris</li>
</ul>



<br><br>

<div id="disqus_thread" style="width:700px"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'zhixingheyi'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<hr>

Zhixingheyi - <a href="http://liuxuan.info">http://liuxuan.info/</a>
</div>

<script src="/javascript/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<!-- Google Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17293168-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
  var sc_project=8495631;
  var sc_invisible=1;
  var sc_security="5b0817e1";
  var scJsHost = (("https:" == document.location.protocol) ?
  "https://secure." : "http://www.");
  document.write("<sc"+"ript type='text/javascript' src='" +
  scJsHost +
  "statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript>
  <div class="statcounter"><a title="website
  statistics" href="http://statcounter.com/"
  target="_blank"><img class="statcounter"
  src="https://c.statcounter.com/8495631/0/5b0817e1/1/"
  alt="website statistics"></a></div>
</noscript>
<!-- End of StatCounter Code for Default Guide -->

</body>
</html>