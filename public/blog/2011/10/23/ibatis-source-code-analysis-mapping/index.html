<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Foredoomed">
  <meta name="generator" content="jekyll">
  <meta name="description" content="The homepage of Zhixingheyi">
  <link href="favicon.ico" rel="icon" type="image/x-icon" />
  <link rel="stylesheet" href="/css/highlight.css" type="text/css">
  <title></title>
</head>

<body>

<div style="width:700px">
  <h1>iBatis源码分析之映射</h1>

<em>By Foredoomed on <time date="2011-10-23 19:14:00 +0800">October 23, 2011</time></em>

<h2 id="section">包结构分析</h2>

<table border="1" width="100%" cellpadding="3" cellspacing="0" summary="">
<tbody><tr>
<th align="left" colspan="2" style="background-color:#CCCCFF">
<b>Packages</b></th></tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.builder.xml</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.common.xml</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.mapping.parameter</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.mapping.result</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.mapping.result.loader</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.mapping.sql</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.mapping.sql.dynamic</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.mapping.sql.dynamic.elements</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.mapping.sql.raw</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.mapping.sql.simple</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.mapping.sql.stat</b></td>
<td>&nbsp;</td>
</tr>
<tr bgcolor="white">
<td width="20%"><b>com.ibatis.sqlmap.engine.mapping.statement</b></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>

<p>iBatis处理映射的包结构应该说还是比较清晰的，基本上看到包名就可以知道包下面的类是做什么用的。但是我们看到关于映射的包一共有10个，但是像dynamic，raw，simple，stat这些包下都只有一个类，显然这种分法是有问题的，我们应当尽可能地减少包，包越少结构就越清晰，但并不是说把类都放一个包下，要在这两者之间寻求平衡。</p>

<h2 id="section-1">源码分析</h2>

<pre><code>public static SqlMapClient buildSqlMapClient(Reader reader) {
    return new SqlMapConfigParser().parse(reader);
}</code></pre>

<p>我们要对数据库操作，首先要创建SqlMapClient接口，而SqlMapClientBuilder类就是用来创建SqlMapClient接口的。在buildSqlMapClient方法里创建了SqlMapConfigParser类，然后再调用该类的parse方法来解析XML配置文件。其实代码读到这里就可以看出SqlMapClient接口是线程安全的。</p>

<pre><code>public SqlMapConfigParser() {
    parser.setValidation(true);
    parser.setEntityResolver(new SqlMapClasspathEntityResolver());

    addSqlMapConfigNodelets();
    addGlobalPropNodelets();
    addSettingsNodelets();
    addTypeAliasNodelets();
    addTypeHandlerNodelets();
    addTransactionManagerNodelets();
    addSqlMapNodelets();
    addResultObjectFactoryNodelets();

}</code></pre>

<p>首先在创建SqlMapConfigParser类的时候就会为NodeletParser类预先定义好XML文件里各种DOM类型的解析方法，这个是通过实现Nodelet接口的process方法来实现的(Nodelet实际上就是回调接口)。我们可以看到iBatis对各种DOM类型自定义了一套表示方法，他们的定义在NodeletParser类里。在SqlMapConfigParser类的parse方法里再调用NodeletParser的parse方法解析XML文件。</p>

<pre><code>/**
   * Registers a nodelet for the specified XPath.  Current XPaths supported
   * are:
   * &lt;ul&gt;
   * &lt;li&gt; Text Path - /rootElement/childElement/text()
   * &lt;li&gt; Attribute Path  - /rootElement/childElement/@theAttribute
   * &lt;li&gt; Element Path - /rootElement/childElement/theElement
   * &lt;li&gt; All Elements Named - //theElement
   * &lt;/ul&gt;
   */
  public void addNodelet(String xpath, Nodelet nodelet) {
    letMap.put(xpath, nodelet);
  }

  /**
   * A recursive method that walkes the DOM tree, registers XPaths and
   * calls Nodelets registered under those XPaths.
   */
  private void process(Node node, Path path) {
    if (node instanceof Element) {
      // Element
      String elementName = node.getNodeName();
      path.add(elementName);
      processNodelet(node, path.toString());
      processNodelet(node, new StringBuffer(&quot;//&quot;).append(elementName).toString());

      // Attribute
      NamedNodeMap attributes = node.getAttributes();
      int n = attributes.getLength();
      for (int i = 0; i &lt; n; i++) {
        Node att = attributes.item(i);
        String attrName = att.getNodeName();
        path.add(&quot;@&quot; + attrName);
        processNodelet(att, path.toString());
        processNodelet(node, new StringBuffer(&quot;//@&quot;).append(attrName).toString());
        path.remove();
      }

      // Children
      NodeList children = node.getChildNodes();
      for (int i = 0; i &lt; children.getLength(); i++) {
        process(children.item(i), path);
      }
      path.add(&quot;end()&quot;);
      processNodelet(node, path.toString());
      path.remove();
      path.remove();
    } else if (node instanceof Text) {
      // Text
      path.add(&quot;text()&quot;);
      processNodelet(node, path.toString());
      processNodelet(node, &quot;//text()&quot;);
      path.remove();
    }
  }

  ...</code></pre>

<p>解析XML采用的是SAX方式，为了区分XML中的元素类型自定义了一套XPath，然后根据XPath进行相应的处理。processNodelet方法里调用Nodelet接口的process方法，而这个process方法已经在创建SqlMapConfigParser类的时候实现了。</p>

<pre><code>public class SqlStatementParser {

  public void parseGeneralStatement(Node node, MappedStatement statement) {

    // get attributes
    Properties attributes = NodeletUtils.parseAttributes(node, state.getGlobalProps());
    String id = attributes.getProperty(&quot;id&quot;);
    String parameterMapName = state.applyNamespace(attributes.getProperty(&quot;parameterMap&quot;));
    String parameterClassName = attributes.getProperty(&quot;parameterClass&quot;);
    String resultMapName = attributes.getProperty(&quot;resultMap&quot;);
    String resultClassName = attributes.getProperty(&quot;resultClass&quot;);
    String cacheModelName = state.applyNamespace(attributes.getProperty(&quot;cacheModel&quot;));
    String xmlResultName = attributes.getProperty(&quot;xmlResultName&quot;);
    String resultSetType = attributes.getProperty(&quot;resultSetType&quot;);
    String fetchSize = attributes.getProperty(&quot;fetchSize&quot;);
    String allowRemapping = attributes.getProperty(&quot;remapResults&quot;);
    String timeout = attributes.getProperty(&quot;timeout&quot;);

    if (state.isUseStatementNamespaces()) {
      id = state.applyNamespace(id);
    }
    String[] additionalResultMapNames = null;
    if (resultMapName != null) {
      additionalResultMapNames = state.getAllButFirstToken(resultMapName);
      resultMapName = state.getFirstToken(resultMapName);
      resultMapName = state.applyNamespace(resultMapName);
      for (int i = 0; i &lt; additionalResultMapNames.length; i++) {
        additionalResultMapNames[i] = state.applyNamespace(additionalResultMapNames[i]);
      }
    }

    String[] additionalResultClassNames = null;
    if (resultClassName != null) {
      additionalResultClassNames = state.getAllButFirstToken(resultClassName);
      resultClassName = state.getFirstToken(resultClassName);
    }
    Class[] additionalResultClasses = null;
    if (additionalResultClassNames != null) {
      additionalResultClasses = new Class[additionalResultClassNames.length];
      for (int i = 0; i &lt; additionalResultClassNames.length; i++) {
        additionalResultClasses[i] = resolveClass(additionalResultClassNames[i]);
      }
    }

    state.getConfig().getErrorContext().setMoreInfo(&quot;Check the parameter class.&quot;);
    Class parameterClass = resolveClass(parameterClassName);

    state.getConfig().getErrorContext().setMoreInfo(&quot;Check the result class.&quot;);
    Class resultClass = resolveClass(resultClassName);

    Integer timeoutInt = timeout == null ? null : new Integer(timeout);
    Integer fetchSizeInt = fetchSize == null ? null : new Integer(fetchSize);
    boolean allowRemappingBool = &quot;true&quot;.equals(allowRemapping);

    MappedStatementConfig statementConf = state.getConfig().newMappedStatementConfig(id, statement,
        new XMLSqlSource(state, node), parameterMapName, parameterClass, resultMapName, additionalResultMapNames,
        resultClass, additionalResultClasses, resultSetType, fetchSizeInt, allowRemappingBool, timeoutInt, cacheModelName,
        xmlResultName);

    findAndParseSelectKey(node, statementConf);
  }
}</code></pre>

<p>在SqlStatementParser类的parseGeneralStatement方法中创建MappedStatementConfig对象。</p>

<pre><code>MappedStatementConfig(SqlMapConfiguration config, String id, MappedStatement statement, SqlSource processor,
                        String parameterMapName, Class parameterClass, String resultMapName,
                        String[] additionalResultMapNames, Class resultClass, Class[] additionalResultClasses,
                        String cacheModelName, String resultSetType, Integer fetchSize, boolean allowRemapping,
                        Integer timeout, Integer defaultStatementTimeout, String xmlResultName) {
    this.errorContext = config.getErrorContext();
    this.client = config.getClient();
    SqlMapExecutorDelegate delegate = client.getDelegate();
    this.typeHandlerFactory = config.getTypeHandlerFactory();
    errorContext.setActivity(&quot;parsing a mapped statement&quot;);
    errorContext.setObjectId(id + &quot; statement&quot;);
    errorContext.setMoreInfo(&quot;Check the result map name.&quot;);
    if (resultMapName != null) {
      statement.setResultMap(client.getDelegate().getResultMap(resultMapName));
      if (additionalResultMapNames != null) {
        for (int i = 0; i &lt; additionalResultMapNames.length; i++) {
          statement.addResultMap(client.getDelegate().getResultMap(additionalResultMapNames[i]));
        }
      }
    }
    errorContext.setMoreInfo(&quot;Check the parameter map name.&quot;);
    if (parameterMapName != null) {
      statement.setParameterMap(client.getDelegate().getParameterMap(parameterMapName));
    }
    statement.setId(id);
    statement.setResource(errorContext.getResource());
    if (resultSetType != null) {
      if (&quot;FORWARD_ONLY&quot;.equals(resultSetType)) {
        statement.setResultSetType(new Integer(ResultSet.TYPE_FORWARD_ONLY));
      } else if (&quot;SCROLL_INSENSITIVE&quot;.equals(resultSetType)) {
        statement.setResultSetType(new Integer(ResultSet.TYPE_SCROLL_INSENSITIVE));
      } else if (&quot;SCROLL_SENSITIVE&quot;.equals(resultSetType)) {
        statement.setResultSetType(new Integer(ResultSet.TYPE_SCROLL_SENSITIVE));
      }
    }
    if (fetchSize != null) {
      statement.setFetchSize(fetchSize);
    }

    // set parameter class either from attribute or from map (make sure to match)
    ParameterMap parameterMap = statement.getParameterMap();
    if (parameterMap == null) {
      statement.setParameterClass(parameterClass);
    } else {
      statement.setParameterClass(parameterMap.getParameterClass());
    }

    // process SQL statement, including inline parameter maps
    errorContext.setMoreInfo(&quot;Check the SQL statement.&quot;);
    Sql sql = processor.getSql();
    setSqlForStatement(statement, sql);

    // set up either null result map or automatic result mapping
    ResultMap resultMap = (ResultMap) statement.getResultMap();
    if (resultMap == null &amp;&amp; resultClass == null) {
      statement.setResultMap(null);
    } else if (resultMap == null) {
      resultMap = buildAutoResultMap(allowRemapping, statement, resultClass, xmlResultName);
      statement.setResultMap(resultMap);
      if (additionalResultClasses != null) {
        for (int i = 0; i &lt; additionalResultClasses.length; i++) {
          statement.addResultMap(buildAutoResultMap(allowRemapping, statement, additionalResultClasses[i], xmlResultName));
        }
      }

    }
    
    ...
}</code></pre>

<p>在MappedStatementConfig类的构造方法里又调用了SqlSource接口的getSql方法，而SqlSource接口只有一个实现类XMLSqlSource，继续看XMLSqlSource类里的getSql方法是怎么实现的。</p>

<pre><code>public Sql getSql() {
    state.getConfig().getErrorContext().setActivity(&quot;processing an SQL statement&quot;);

    boolean isDynamic = false;
    StringBuffer sqlBuffer = new StringBuffer();
    DynamicSql dynamic = new DynamicSql(state.getConfig().getClient().getDelegate());
    isDynamic = parseDynamicTags(parentNode, dynamic, sqlBuffer, isDynamic, false);
    String sqlStatement = sqlBuffer.toString();
    if (isDynamic) {
      return dynamic;
    } else {
      return new RawSql(sqlStatement);
    }
}</code></pre>

<p>接下来我们就来看一下iBatis是怎么处理SQL映射的:</p>

<pre><code>private void processBodyChildren(StatementScope statementScope, SqlTagContext ctx, Object     parameterObject, Iterator localChildren, PrintWriter out) {
    while (localChildren.hasNext()) {
      SqlChild child = (SqlChild) localChildren.next();
      if (child instanceof SqlText) {
        SqlText sqlText = (SqlText) child;
        String sqlStatement = sqlText.getText();
        if (sqlText.isWhiteSpace()) {
          out.print(sqlStatement);
        } else if (!sqlText.isPostParseRequired()) {

          // BODY OUT
          out.print(sqlStatement);

          ParameterMapping[] mappings = sqlText.getParameterMappings();
          if (mappings != null) {
            for (int i = 0, n = mappings.length; i &lt; n; i++) {
              ctx.addParameterMapping(mappings[i]);
            }
          }
        } else {

          IterateContext itCtx = ctx.peekIterateContext();

          if(null != itCtx &amp;&amp; itCtx.isAllowNext()){
            itCtx.next();
            itCtx.setAllowNext(false);
            if(!itCtx.hasNext()) {
              itCtx.setFinal(true);
            }
          }

          if(itCtx!=null) {
            StringBuffer sqlStatementBuffer = new StringBuffer(sqlStatement);
            iteratePropertyReplace(sqlStatementBuffer, itCtx);
            sqlStatement = sqlStatementBuffer.toString();
          }

          sqlText = PARAM_PARSER.parseInlineParameterMap(delegate.getTypeHandlerFactory(), sqlStatement);

          ParameterMapping[] mappings = sqlText.getParameterMappings();
          out.print(sqlText.getText());
          if (mappings != null) {
             for (int i = 0, n = mappings.length; i &lt; n; i++) {
               ctx.addParameterMapping(mappings[i]);
             }
          }
        }
      } else if (child instanceof SqlTag) {
        ...
      }
    }
}</code></pre>

<p>注意到在processBodyChildren方法里调用了InlineParameterMapParser类的parseInlineParameterMap方法，继续跟踪下去。</p>

<pre><code>public SqlText parseInlineParameterMap(TypeHandlerFactory typeHandlerFactory, String sqlStatement, Class parameterClass) {

    String newSql = sqlStatement;

    List mappingList = new ArrayList();

    StringTokenizer parser = new StringTokenizer(sqlStatement, PARAMETER_TOKEN, true);
    StringBuffer newSqlBuffer = new StringBuffer();

    String token = null;
    String lastToken = null;
    while (parser.hasMoreTokens()) {
      token = parser.nextToken();
      if (PARAMETER_TOKEN.equals(lastToken)) {
        if (PARAMETER_TOKEN.equals(token)) {
          newSqlBuffer.append(PARAMETER_TOKEN);
          token = null;
        } else {
          ParameterMapping mapping = null;
          if (token.indexOf(PARAM_DELIM) &gt; -1) {
            mapping = oldParseMapping(token, parameterClass, typeHandlerFactory);
          } else {
            mapping = newParseMapping(token, parameterClass, typeHandlerFactory);
          }

          mappingList.add(mapping);
          newSqlBuffer.append(&quot;?&quot;);
          token = parser.nextToken();
          if (!PARAMETER_TOKEN.equals(token)) {
            throw new SqlMapException(&quot;Unterminated inline parameter in mapped statement (&quot; + &quot;statement.getId()&quot; + &quot;).&quot;);
          }
          token = null;
        }
      } else {
        if (!PARAMETER_TOKEN.equals(token)) {
          newSqlBuffer.append(token);
        }
      }

      lastToken = token;
    }

    newSql = newSqlBuffer.toString();

    ParameterMapping[] mappingArray = (ParameterMapping[]) mappingList.toArray(new ParameterMapping[mappingList.size()]);

    SqlText sqlText = new SqlText();
    sqlText.setText(newSql);
    sqlText.setParameterMappings(mappingArray);
    return sqlText;
}</code></pre>

<p>终于找到解析SQL的类了，在parseInlineParameterMap方法中会将下面的SQL</p>

<pre><code>SELECT * FROM TABLE WHERE ID = #ID#</code></pre>

<p>解析成能被JDBC执行的SQL</p>

<pre><code>SELECT * FROM TABLE WHERE ID = ?</code></pre>

<p>等到解析完成后会把SQL保存到SqlText类中，再把SqlText保存到MappedStatement类里，有了MappedStatement对象就可以执行相应的CRUD操作了。</p>



<br><br>

<div id="disqus_thread" style="width:700px"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'zhixingheyi'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<hr>

Zhixingheyi - <a href="http://liuxuan.info">http://liuxuan.info/</a>
</div>

<script src="/javascript/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<!-- Google Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17293168-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
  var sc_project=8495631;
  var sc_invisible=1;
  var sc_security="5b0817e1";
  var scJsHost = (("https:" == document.location.protocol) ?
  "https://secure." : "http://www.");
  document.write("<sc"+"ript type='text/javascript' src='" +
  scJsHost +
  "statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript>
  <div class="statcounter"><a title="website
  statistics" href="http://statcounter.com/"
  target="_blank"><img class="statcounter"
  src="https://c.statcounter.com/8495631/0/5b0817e1/1/"
  alt="website statistics"></a></div>
</noscript>
<!-- End of StatCounter Code for Default Guide -->

</body>
</html>