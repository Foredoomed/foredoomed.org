<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Foredoomed">
  <meta name="generator" content="jekyll">
  <meta name="description" content="The homepage of Zhixingheyi">
  <link href="favicon.ico" rel="icon" type="image/x-icon" />
  <link rel="stylesheet" href="/css/highlight.css" type="text/css">
  <title></title>
</head>

<body>

<div style="width:700px">
  <h1>浏览器是如何工作的(五)</h1>

<em>By Foredoomed on <time date="2011-12-11 17:14:00 +0800">December 11, 2011</time></em>

<h3 id="section">3.2.6 标记算法</h3>

<p>这个算法的输出是一个HTML标记，它可以用状态机来表示。每个状态消费输入流的一个或多个字符，然后根据这些字符更新下一个状态。状态的更新是由当前标记状态和树构造状态决定的。这意味着根据当前状态，同样的字符会对下一个正确的状态产生不同的结果。这个算法太复杂，所以不能完全描述清楚，所以让我来看一个简单的例子，这个例子会帮助我们理解这个算法。</p>

<p>标记下面的HTML：</p>

<pre><code>&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>初始状态是“<strong>Data state</strong>”。当遇到字符 &lt; 后，状态被改变成”<strong>Tag open state</strong>”。消费一个a到z的字符会创建”<strong>Start tag token</strong>”，而状态会变成”<strong>Tag name state</strong>”。然后状态一直保持到遇到 &gt; 字符。每个字符被加在了新标记名称之后，在这个例子中，被创建的标记是html。</p>

<p>当遇到 &gt; 字符后，当前状态被改回成”<strong>Data state</strong>”。下面的&lt;body&gt;标签是同样的处理步骤。到目前为止，&lt;html&gt;和&lt;body&gt;标签处理完成了，回到了”<strong>Data state</strong>”状态。然后碰到的是Hello world中的H字符，这会导致标记的创建直到遇到&lt;/body&gt;标签的 &lt; 字符，然后为Hello world的每个字符释放字符标记。</p>

<p>我们现在回到了”<strong>Tag open state</strong>”状态。下面一个遇到的字符是/，这会导致创建 end tag token 并且状态改变为”<strong>Tag name state</strong>”。同样，这个状态持续到遇到 &gt; 字符。然后新的标签会被释放，回到”<strong>Data state</strong>”状态。&lt;/html&gt;标签是同样的处理流程。</p>

<p><img src="http://i1256.photobucket.com/albums/ii494/Foredoomed/tokenizing_zps056f885c.png" alt="tokenizing" title="tokenizing" /></p>

<h3 id="section-1">3.2.7 树的构造算法</h3>

<p>当解析器被创建的时候，文档对象就被创建了。在整个构造树的过程中，DOM树的根结点会被修改或者添加元素。每个节点的释放由树构造器处理。对于每个标记，规范定义了与之相对应的DOM元素，所以会创建相对应的DOM元素。除了向DOM树中添加元素外，还会向开放元素的栈中添加。这个栈是被用来纠正嵌套错误和未关闭的标签。这个算法也被描述为一个状态机，那些状态被称为<strong>插入模式</strong>(insertion modes)。</p>

<p>让我们来看一下树的构造过程，比如下面的输入：</p>

<pre><code>&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>输入对于构造树的阶段来说，是一个初始模式是”<strong>initial mode</strong>”的标记序列。获取HTML标记会引发向”<strong>before html</strong>”模式的移动，并且在那个模式下的再次处理。这会造成HTMLHtmlElement元素的创建，然后被附加到对象模型的根结点上去。</p>

<p>然后状态会变成”<strong>before head</strong>”。尽管没有head标记，当得到body标记，HTMLHeadElement元素会被隐式地创建，然后加入到树中。</p>

<p>现在模式移动，从”<strong>in head</strong>”模式再到”<strong>after head</strong>”模式。body标记被再次处理，HTMLBodyElement元素被创建，并且模式被转移到了”<strong>in body</strong>”。</p>

<p>现在碰到的是Hello world字符串的字符标记。首先会创建和插入Text节点，其他字符会附加到这个节点上去。</p>

<p>如果碰到body的关闭标记的话会使模式转入”<strong>after body</strong>”。然后碰到html关闭标签，模式转换成”<strong>after after body</strong>“。碰到文件结束标记后，解析结束。</p>

<p><img src="http://i1256.photobucket.com/albums/ii494/Foredoomed/treeconstruction_zpsd983ece9.gif" alt="tree construction" title="tree construction" /></p>

<h3 id="section-2">3.2.8 解析结束后</h3>

<p>解析结束后会标记文档为interactive，然后开始解析应该在文档解析完成后执行的脚本。这个文档状态会被设置成”complete”，而且”load”事件会被触发。</p>

<h3 id="section-3">3.2.9 浏览器的容错性</h3>

<p>你永远不会在HTML页面上得到一个”Invalid Syntax”错误。浏览器会修复任何一个非法的文档，使它能够正常运行。</p>

<p>拿下面这个例子来说：</p>

<pre><code>&lt;html&gt;
  &lt;mytag&gt;
  &lt;/mytag&gt;
  &lt;div&gt;
  &lt;p&gt;
  &lt;/div&gt;
    Really lousy HTML
  &lt;/p&gt;
&lt;/html&gt;</code></pre>

<p>在这个例子中我犯了许多错误：mytag不是标准标签，p和div元素都嵌套错误。但即使这样，浏览器也能正确执行这段HTML，所以这些错误都被浏览器给纠正了。</p>

<p>错误处理在各个浏览器中是非常一致的，但是令人惊奇的是这并不是HTML当前规范的一部分。就像书签和前进/后退按钮一样，这是在浏览器多年进化的结果。</p>

<p>HTML5规范定义了一些上述的需求。Webkit在它的HTML解析类的开头美妙地总结如下：</p>

<blockquote>
  <p>The parser parses tokenized input into the document, building up the document tree. If the document is well-formed, parsing it is straightforward.  </p>
</blockquote>

<blockquote>
  <p>Unfortunately, we have to handle many HTML documents that are not well-formed, so the parser has to be tolerant about errors.  </p>
</blockquote>

<blockquote>
  <p>We have to take care of at least the following error conditions:  </p>
</blockquote>

<blockquote>
  <ol>
    <li>The element being added is explicitly forbidden inside some outer tag. In this case we should close all tags up to the one, which forbids the element, and add it afterwards.</li>
    <li>We are not allowed to add the element directly. It could be that the person writing the document forgot some tag in between (or that the tag in between is optional). This could be the case with the following tags: HTML HEAD BODY TBODY TR TD LI (did I forget any?).</li>
    <li>We want to add a block element inside to an inline element. Close all inline elements up to the next higher block element.</li>
    <li>If this doesn’t help, close elements until we are allowed to add the element or ignore the tag.</li>
  </ol>
</blockquote>

<p>让我们来看一些Webkit的容错例子:</p>

<h4 id="brbr">&lt;/br&gt;代替&lt;br&gt;</h4>

<p>有些站点使用&lt;/br&gt;代替&lt;br&gt;，为了跟IE和Firefox兼容，Webkit会把&lt;/br&gt;处理成&lt;br&gt;。</p>

<p>Webkit代码：</p>

<pre><code>if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) {
     reportError(MalformedBRError);
     t-&gt;beginTag = true;
}</code></pre>

<p>注意：错误处理只在内部执行，不会展现给用户。</p>

<h4 id="a-stray-table">A stray table</h4>

<p>stras table指的是一个table元素里直接里包含了另一个table元素，就像下面的例子：</p>

<pre><code>&lt;table&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</code></pre>

<p>Webkit会改变它的继承结构为两个同级别的table：</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</code></pre>

<p>处理这部分的代码为：</p>

<pre><code>if (m_inStrayTableContent &amp;&amp; localName == tableTag)
        popBlock(tableTag);</code></pre>

<p>Webkit利用栈来保存当前内容，它会弹出内部的table，这样的话这两个table就是同级别的了。</p>

<h4 id="section-4">从元素嵌套</h4>

<p>为了防止用户把一个form放到另一个form内，内部的form将被丢弃，代码为：</p>

<pre><code>if (!m_currentFormElement) {
        m_currentFormElement = new HTMLFormElement(formTag,    m_document);
}</code></pre>

<h4 id="section-5">过深的标签嵌套</h4>

<p>注释说明的非常清楚：</p>

<pre><code>// www.liceo.edu.mx is an example of a site that achieves a level of nesting of about 
// 1500 tags, all from a bunch of &lt;b&gt;s. We will only allow at most 20 nested tags   
// of the same type before just ignoring them all together.
bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName)
{

unsigned i = 0;
for (HTMLStackElem* curr = m_blockStack;
         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName;
     curr = curr-&gt;next, i++) { }
return i != cMaxRedundantTagDepth;
}</code></pre>

<h4 id="htmlbody">html或者body的关闭标签位置错误</h4>

<p>同样，注释说明的非常清楚：</p>

<pre><code>// Support for really broken html. We never close the body tag, since some stupid web pages 
// close it before the actual end of the doc. Let's rely on th//e end() call to close things.
if (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag )
        return;</code></pre>

<p>所以web开发人员要注意，除非你想作为Webkit的容错代码片段的例子出现，否则要写格式良好的HTML。</p>



<br><br>

<div id="disqus_thread" style="width:700px"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'zhixingheyi'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<hr>

Zhixingheyi - <a href="http://liuxuan.info">http://liuxuan.info/</a>
</div>

<script src="/javascript/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<!-- Google Analytics -->
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17293168-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
  var sc_project=8495631;
  var sc_invisible=1;
  var sc_security="5b0817e1";
  var scJsHost = (("https:" == document.location.protocol) ?
  "https://secure." : "http://www.");
  document.write("<sc"+"ript type='text/javascript' src='" +
  scJsHost +
  "statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript>
  <div class="statcounter"><a title="website
  statistics" href="http://statcounter.com/"
  target="_blank"><img class="statcounter"
  src="https://c.statcounter.com/8495631/0/5b0817e1/1/"
  alt="website statistics"></a></div>
</noscript>
<!-- End of StatCounter Code for Default Guide -->

</body>
</html>